{"version":3,"mappings":"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","names":["validationRules","message","test","value","trim","length","min","validateField","rules","errors","rule","push","isValid","validateForm","data","results","field","fieldRules","Object","entries","sanitizeInput","input","replace","validationSchemas","signUp","email","password","username","signIn","convertPocketbaseUser","async","pocketbaseUser","debugLogger","log","userId","id","convertedUser","split","level","totalXp","total_xp","coins","gems","createdAt","created","Date","toISOString","lastActive","last_active","preferences","theme","language","notifications","soundEffects","dailyGoal","timezone","error","stack","Error","fallbackUser","handleSignUpError","includes","handleSignInError","useAuthStore","create","set","get","user","session","isAuthenticated","isLoading","passwordLength","validationResults","validationErrors","filter","_","result","map","join","validateSignUpInputs","userData","passwordConfirm","createPocketBaseUserData","newUser","pb","collection","authData","authWithPassword","record","hasToken","token","isDemoLogin","timeoutId","setTimeout","warn","undefined","validateSignInInputs","sanitizedEmail","emailError","performPocketBaseAuth","hasRecord","update","updateError","updateUserLastActive","clearTimeout","signOut","authStore","clear","resetPassword","requestPasswordReset","errorMessage","updatePassword","newPassword","currentState","hasUser","hasSession","errorType","constructor","name","updateProfile","updates","keys","updateData","clearError","initializeAuth","model","info","login","register","logout","updateUser","onChange","timestamp","then","setState","catch","useThemeStore","persist","systemTheme","setTheme","document","documentElement","classList","add","remove","toggleTheme","newTheme","initializeTheme","window","matchMedia","matches","addEventListener","e","newSystemTheme","partialize","state","mockAchievements","description","icon","category","requirements","type","operator","xpReward","coinReward","isSecret","rarity","mockChallenges","title","target","rewards","amount","startDate","endDate","now","isActive","participantCount","itemId","mockLeaderboards","xp_weekly","period","score","rank","change","updatedAt","streak_all_time","calculateLevel","xp","Math","floor","sqrt","calculateXPToNextLevel","pow","useGamificationStore","userStats","totalCards","cardsStudiedToday","cardsStudiedThisWeek","cardsStudiedThisMonth","averageAccuracy","totalStudyTime","studyTimeToday","studyTimeThisWeek","decksCreated","decksCompleted","longestStreak","currentStreak","gold","diamonds","xpToNextLevel","isFirstTimeUser","isInitialized","achievements","userAchievements","userStreak","activeChallenges","userChallengeParticipations","leaderboards","updateUserStats","stats","newStats","addUserAchievement","achievementId","find","ua","toString","earnedAt","updateStreak","streak","joinChallenge","challengeId","p","progress","completed","joinedAt","milestoneProgress","weeklyProgress","bestWeek","updateChallengeProgress","claimChallengeReward","challenge","c","participation","xpGained","_coinsGained","forEach","reward","initializeMockData","lastStudyDate","freezeCount","cards_studied_today","completedAt","milestone_1","cards_studied_week","milestone_2","week","storyUnlocked","initializeNewUser","resetAllUserData","addCurrency","spendCurrency","initializeUserData","isDemo","updateMilestoneProgress","milestoneId","updateWeeklyProgress","weekData","w","updateChallengeStreak","unlockStoryChapter","claimMilestoneReward","contributeToCommunityGoal","goalId","contribution","awardStudyXP","cardsStudied","correctAnswers","milestoneBonus","newXP","newLevel","newXPToNextLevel","createNewCard","frontContent","backContent","cardType","mediaRefs","queue","due","ivl","factor","reps","lapses","left","learningStep","graduationInterval","easyInterval","averageAnswerTime","flags","originalDue","originalDeck","xpAwarded","difficultyRating","defaultDeckSettings","newCardsPerDay","maxReviewsPerDay","easyBonus","intervalModifier","maximumInterval","minimumInterval","cleanFieldContent","content","parseApkgFile","file","default","JSZip","initSqlJs","Promise","all","__vitePreload","import","n","j","__VITE_PRELOAD__","s","SQL","locateFile","endsWith","arrayBuffer","zip","dbFile","loadAsync","dbArrayBuffer","db","Database","Uint8Array","deckQuery","exec","deckName","values","decksJson","decks","JSON","parse","deckIds","notesQuery","cards","sampleSize","sampleFields","i","fields","frontIndex","backIndex","fieldCount","combinations","front","back","validPairs","match","normalizedScore","sort","a","b","detectBestFieldCombination","row","max","close","useDeckStore","currentStudySession","importProgress","importStatus","createDeck","deckData","deck","crypto","randomUUID","settings","updateDeck","deleteDeck","_deletedCards","remainingCards","getDeck","addCard","deckId","cardData","card","easeFactor","intervalDays","nextReview","reviewCount","lapseCount","updatedCards","cardCount","addCardBulk","existingCards","cardKey","toLowerCase","some","createDeckBulk","addCardsBatch","cardsData","existingCardSet","Set","uniqueCardsData","has","updateCard","cardId","newCards","deleteCard","targetDeckId","findIndex","getCards","importAnkiDeck","setImportProgress","resetImportProgress","fileName","d","isPublic","uniqueCards","seenCards","batchSize","successfulImports","batch","slice","batchCards","resolve","cardError","originalCard","individualError","text","separator","cleanText","importFromText","lines","line","validCards","skippedLines","parts","part","uniqueValidCards","loadExampleDecks","existingTitles","exampleDecks","tags","setLoading","loading","removeDuplicateCards","deckCards","uniqueCardsMap","Map","duplicatesRemoved","Array","from","status","startStudySession","studyCards","studyCardIds","currentCardIndex","sessionStats","total","correct","incorrect","startedAt","updateStudySession","clearStudySession","getStudySession","resetAllStudyData","resetCards","restOfState","useCurrentCard","store","currentCardId"],"ignoreList":[],"sources":["../../src/utils/validation.ts","../../src/stores/authStore.ts","../../src/stores/themeStore.ts","../../src/stores/gamificationStore.ts","../../src/utils/cardDefaults.ts","../../src/stores/deckStore.ts"],"sourcesContent":["// Input validation utilities\r\n\r\nexport interface ValidationResult {\r\n  isValid: boolean\r\n  errors: string[]\r\n}\r\n\r\nexport interface ValidationRule {\r\n  test: (value: string) => boolean\r\n  message: string\r\n}\r\n\r\n// Common validation rules\r\nexport const validationRules = {\r\n  required: (message = 'This field is required'): ValidationRule => ({\r\n    test: (value: string) => value.trim().length > 0,\r\n    message\r\n  }),\r\n  \r\n  minLength: (min: number, message?: string): ValidationRule => ({\r\n    test: (value: string) => value.length >= min,\r\n    message: message || `Must be at least ${min} characters long`\r\n  }),\r\n  \r\n  maxLength: (max: number, message?: string): ValidationRule => ({\r\n    test: (value: string) => value.length <= max,\r\n    message: message || `Must be no more than ${max} characters long`\r\n  }),\r\n  \r\n  email: (message = 'Please enter a valid email address'): ValidationRule => ({\r\n    test: (value: string) => {\r\n      const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/\r\n      return emailRegex.test(value)\r\n    },\r\n    message\r\n  }),\r\n  \r\n  password: (message = 'Password must be at least 8 characters with uppercase, lowercase, number, and special character'): ValidationRule => ({\r\n    test: (value: string) => {\r\n      // At least 8 characters, one uppercase, one lowercase, one number, one special character\r\n      const passwordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&])[A-Za-z\\d@$!%*?&]{8,}$/\r\n      return passwordRegex.test(value)\r\n    },\r\n    message\r\n  }),\r\n  \r\n  username: (message = 'Username must be 3-50 characters and contain only letters, numbers, and underscores'): ValidationRule => ({\r\n    test: (value: string) => {\r\n      const usernameRegex = /^[a-zA-Z0-9_]{3,50}$/\r\n      return usernameRegex.test(value)\r\n    },\r\n    message\r\n  }),\r\n  \r\n  noXSS: (message = 'Invalid characters detected'): ValidationRule => ({\r\n    test: (value: string) => {\r\n      // Basic XSS prevention - reject common script tags and javascript protocols\r\n      const xssRegex = /<script|javascript:|data:|vbscript:|onload=|onerror=/i\r\n      return !xssRegex.test(value)\r\n    },\r\n    message\r\n  }),\r\n  \r\n  noSQLInjection: (message = 'Invalid characters detected'): ValidationRule => ({\r\n    test: (value: string) => {\r\n      // Basic SQL injection prevention\r\n      const patterns = [\r\n        /'/, // single quotes\r\n        /\\\\'/, // escaped quotes\r\n        /;/, // semicolons\r\n        /--/, // SQL comments\r\n        /\\/\\*/, // block comments start\r\n        /(union|select|insert|delete|update|drop|create|alter|exec|execute)\\s/i // SQL keywords\r\n      ]\r\n      const hasSQLInjection = patterns.some(pattern => pattern.test(value))\r\n      return !hasSQLInjection\r\n    },\r\n    message\r\n  })\r\n}\r\n\r\n// Validate a single field\r\nexport function validateField(value: string, rules: ValidationRule[]): ValidationResult {\r\n  const errors: string[] = []\r\n  \r\n  for (const rule of rules) {\r\n    if (!rule.test(value)) {\r\n      errors.push(rule.message)\r\n    }\r\n  }\r\n  \r\n  return {\r\n    isValid: errors.length === 0,\r\n    errors\r\n  }\r\n}\r\n\r\n// Validate multiple fields\r\nexport function validateForm(data: Record<string, string>, rules: Record<string, ValidationRule[]>): Record<string, ValidationResult> {\r\n  const results: Record<string, ValidationResult> = {}\r\n  \r\n  for (const [field, fieldRules] of Object.entries(rules)) {\r\n    const value = data[field] || ''\r\n    results[field] = validateField(value, fieldRules)\r\n  }\r\n  \r\n  return results\r\n}\r\n\r\n// Check if all validation results are valid\r\nexport function isFormValid(results: Record<string, ValidationResult>): boolean {\r\n  return Object.values(results).every(result => result.isValid)\r\n}\r\n\r\n// Sanitize input to prevent XSS\r\nexport function sanitizeInput(input: string): string {\r\n  return input\r\n    .replace(/</g, '&lt;')\r\n    .replace(/>/g, '&gt;')\r\n    .replace(/\"/g, '&quot;')\r\n    .replace(/'/g, '&#x27;')\r\n    .replace(/\\//g, '&#x2F;')\r\n    .trim()\r\n}\r\n\r\n// Validate and sanitize text content\r\nexport function validateAndSanitizeText(text: string, maxLength = 5000): { isValid: boolean; sanitized: string; errors: string[] } {\r\n  const validation = validateField(text, [\r\n    validationRules.required(),\r\n    validationRules.maxLength(maxLength),\r\n    validationRules.noXSS(),\r\n    validationRules.noSQLInjection()\r\n  ])\r\n  \r\n  return {\r\n    isValid: validation.isValid,\r\n    sanitized: sanitizeInput(text),\r\n    errors: validation.errors\r\n  }\r\n}\r\n\r\n// Pre-defined validation schemas for common forms\r\nexport const validationSchemas = {\r\n  signUp: {\r\n    email: [validationRules.required(), validationRules.email()],\r\n    password: [validationRules.required(), validationRules.password()],\r\n    username: [validationRules.required(), validationRules.username()]\r\n  },\r\n  \r\n  signIn: {\r\n    email: [validationRules.required()],\r\n    password: [validationRules.required(), validationRules.minLength(6)]\r\n  },\r\n  \r\n  profile: {\r\n    username: [validationRules.required(), validationRules.username()],\r\n    email: [validationRules.required(), validationRules.email()]\r\n  },\r\n  \r\n  card: {\r\n    front_content: [validationRules.required(), validationRules.maxLength(5000), validationRules.noXSS()],\r\n    back_content: [validationRules.required(), validationRules.maxLength(5000), validationRules.noXSS()]\r\n  },\r\n  \r\n  deck: {\r\n    title: [validationRules.required(), validationRules.maxLength(200), validationRules.noXSS()],\r\n    description: [validationRules.maxLength(1000), validationRules.noXSS()]\r\n  }\r\n}","import { create } from 'zustand'\r\nimport { pb } from '../lib/pocketbase'\r\nimport type { User } from '../types'\r\nimport { debugLogger } from '../utils/debugLogger'\r\nimport { validateForm, validationSchemas, sanitizeInput } from '../utils/validation'\r\n\r\ninterface AuthState {\r\n  user: User | null\r\n  session: { record: Record<string, unknown>; token: string } | null // PocketBase auth record\r\n  isAuthenticated: boolean\r\n  isLoading: boolean\r\n  error: string | null\r\n  \r\n  // Primary Actions (unified interface for components)\r\n  login: (email: string, password: string) => Promise<void>\r\n  register: (email: string, username: string, password: string) => Promise<void>\r\n  logout: () => void\r\n  updateUser: (updates: Partial<User>) => void\r\n  \r\n  // PocketBase-specific Actions\r\n  signUp: (email: string, password: string, username: string) => Promise<void>\r\n  signIn: (email: string, password: string) => Promise<void>\r\n  signOut: () => Promise<void>\r\n  resetPassword: (email: string) => Promise<void>\r\n  updatePassword: (newPassword: string) => Promise<void>\r\n  updateProfile: (updates: Partial<User>) => Promise<void>\r\n  clearError: () => void\r\n  initializeAuth: () => Promise<void>\r\n}\r\n\r\n// Helper function to convert PocketBase user to our User type\r\nconst convertPocketbaseUser = async (pocketbaseUser: Record<string, unknown>): Promise<User> => {\r\n  debugLogger.log('[POCKETBASE_AUTH_STORE]', 'START - convertPocketbaseUser', {\r\n    userId: pocketbaseUser.id,\r\n    email: pocketbaseUser.email,\r\n    username: pocketbaseUser.username\r\n  });\r\n\r\n  try {\r\n    const convertedUser = {\r\n      id: pocketbaseUser.id,\r\n      email: pocketbaseUser.email,\r\n      username: pocketbaseUser.username || pocketbaseUser.email?.split('@')[0] || 'User',\r\n      level: pocketbaseUser.level || 1,\r\n      totalXp: pocketbaseUser.total_xp || 0,\r\n      coins: pocketbaseUser.coins || 100,\r\n      gems: pocketbaseUser.gems || 10,\r\n      createdAt: pocketbaseUser.created || new Date().toISOString(),\r\n      lastActive: pocketbaseUser.last_active || new Date().toISOString(),\r\n      preferences: pocketbaseUser.preferences || {\r\n        theme: 'system' as const,\r\n        language: 'en',\r\n        notifications: true,\r\n        soundEffects: true,\r\n        dailyGoal: 50,\r\n        timezone: 'UTC'\r\n      }\r\n    };\r\n\r\n    debugLogger.log('[POCKETBASE_AUTH_STORE]', 'END - convertPocketbaseUser', convertedUser);\r\n    return convertedUser;\r\n  } catch (error) {\r\n    debugLogger.error('[POCKETBASE_AUTH_STORE]', 'Error in convertPocketbaseUser', {\r\n      error,\r\n      stack: error instanceof Error ? error.stack : undefined,\r\n      userId: pocketbaseUser.id\r\n    });\r\n    \r\n    // Fallback: create a basic user object\r\n    const fallbackUser = {\r\n      id: pocketbaseUser.id,\r\n      email: pocketbaseUser.email || 'unknown@example.com',\r\n      username: pocketbaseUser.username || pocketbaseUser.email?.split('@')[0] || 'User',\r\n      level: 1,\r\n      totalXp: 0,\r\n      coins: 100,\r\n      gems: 10,\r\n      createdAt: pocketbaseUser.created || new Date().toISOString(),\r\n      lastActive: new Date().toISOString(),\r\n      preferences: {\r\n        theme: 'system' as const,\r\n        language: 'en',\r\n        notifications: true,\r\n        soundEffects: true,\r\n        dailyGoal: 50,\r\n        timezone: 'UTC'\r\n      }\r\n    };\r\n\r\n    debugLogger.log('[POCKETBASE_AUTH_STORE]', 'END - convertPocketbaseUser (fallback)', fallbackUser);\r\n    return fallbackUser;\r\n  }\r\n}\r\n\r\n// Helper functions for authentication operations\r\nconst validateSignUpInputs = (email: string, password: string, username: string) => {\r\n  const validationResults = validateForm(\r\n    { email, password, username },\r\n    validationSchemas.signUp\r\n  )\r\n  \r\n  const validationErrors = Object.entries(validationResults)\r\n    .filter(([_, result]) => !result.isValid)\r\n    .map(([field, result]) => `${field}: ${result.errors.join(', ')}`)\r\n  \r\n  if (validationErrors.length > 0) {\r\n    throw new Error(validationErrors.join('; '))\r\n  }\r\n}\r\n\r\nconst validateSignInInputs = (email: string, password: string) => {\r\n  const validationResults = validateForm(\r\n    { email, password },\r\n    validationSchemas.signIn\r\n  )\r\n  \r\n  const validationErrors = Object.entries(validationResults)\r\n    .filter(([_, result]) => !result.isValid)\r\n    .map(([field, result]) => `${field}: ${result.errors.join(', ')}`)\r\n  \r\n  if (validationErrors.length > 0) {\r\n    throw new Error(validationErrors.join('; '))\r\n  }\r\n}\r\n\r\nconst createPocketBaseUserData = (email: string, username: string, password: string) => ({\r\n  username: sanitizeInput(username),\r\n  email: sanitizeInput(email),\r\n  password,\r\n  passwordConfirm: password,\r\n  level: 1,\r\n  total_xp: 0,\r\n  coins: 100,\r\n  gems: 10,\r\n  last_active: new Date().toISOString(),\r\n  preferences: {\r\n    theme: 'system',\r\n    language: 'en',\r\n    notifications: true,\r\n    soundEffects: true,\r\n    dailyGoal: 50,\r\n    timezone: 'UTC'\r\n  }\r\n})\r\n\r\nconst createDemoUser = (): User => ({\r\n  id: 'demo-user',\r\n  email: 'demo@studymaster.app',\r\n  username: 'DemoUser',\r\n  level: 5,\r\n  totalXp: 2500,\r\n  coins: 150,\r\n  gems: 25,\r\n  createdAt: new Date().toISOString(),\r\n  lastActive: new Date().toISOString(),\r\n  preferences: {\r\n    theme: 'system',\r\n    language: 'en',\r\n    notifications: true,\r\n    soundEffects: true,\r\n    dailyGoal: 50,\r\n    timezone: 'UTC'\r\n  }\r\n})\r\n\r\nconst handleSignUpError = (error: unknown): string => {\r\n  if (!(error instanceof Error)) return 'Registration failed'\r\n  \r\n  if (error.message.includes('username')) {\r\n    return 'Username already exists or is invalid'\r\n  } else if (error.message.includes('email')) {\r\n    return 'Email already exists or is invalid'\r\n  } else {\r\n    return error.message\r\n  }\r\n}\r\n\r\nconst handleSignInError = (error: unknown): string => {\r\n  if (!(error instanceof Error)) return 'Login failed'\r\n  \r\n  if (error.message.includes('Failed to authenticate')) {\r\n    return 'Invalid email/username or password. Please check your credentials and try again.'\r\n  } else if (error.message.includes('Too many requests')) {\r\n    return 'Too many login attempts. Please wait a moment and try again.'\r\n  } else {\r\n    return error.message\r\n  }\r\n}\r\n\r\nconst isDemoLogin = (email: string, password: string): boolean => {\r\n  const isDevelopment = import.meta.env.NODE_ENV === 'development' || import.meta.env.VITE_ENABLE_DEBUG_LOGGING === 'true'\r\n  const demoPassword = import.meta.env.VITE_DEMO_PASSWORD || 'demo123456'\r\n  return isDevelopment && email === 'demo' && password === demoPassword\r\n}\r\n\r\nconst performPocketBaseAuth = async (email: string, password: string) => {\r\n  const sanitizedEmail = sanitizeInput(email)\r\n  \r\n  // Try email first, then username fallback\r\n  try {\r\n    return await pb.collection('users').authWithPassword(sanitizedEmail, password)\r\n  } catch (emailError) {\r\n    debugLogger.log('[POCKETBASE_AUTH_STORE]', 'Email login failed, trying username');\r\n    return await pb.collection('users').authWithPassword(sanitizedEmail, password)\r\n  }\r\n}\r\n\r\nconst updateUserLastActive = async (userId: string) => {\r\n  try {\r\n    await pb.collection('users').update(userId, {\r\n      last_active: new Date().toISOString()\r\n    })\r\n    debugLogger.log('[POCKETBASE_AUTH_STORE]', 'Updated last active time');\r\n  } catch (updateError) {\r\n    debugLogger.warn('[POCKETBASE_AUTH_STORE]', 'Could not update last active time', {\r\n      error: updateError\r\n    });\r\n  }\r\n}\r\n\r\n// Consolidated authentication store - combines PocketBase + local fallback\r\n// This replaces the dual authStore/pocketbaseAuthStore pattern\r\nexport const useAuthStore = create<AuthState>()((set, get) => ({\r\n  user: null,\r\n  session: null,\r\n  isAuthenticated: false,\r\n  isLoading: false,\r\n  error: null,\r\n\r\n  signUp: async (email: string, password: string, username: string) => {\r\n    debugLogger.log('[POCKETBASE_AUTH_STORE]', 'START - signUp', {\r\n      email,\r\n      username,\r\n      passwordLength: password.length\r\n    });\r\n\r\n    set({ isLoading: true, error: null })\r\n    \r\n    try {\r\n      validateSignUpInputs(email, password, username)\r\n      \r\n      const userData = createPocketBaseUserData(email, username, password)\r\n      debugLogger.log('[POCKETBASE_AUTH_STORE]', 'Creating user in PocketBase', {\r\n        email: userData.email,\r\n        username: userData.username\r\n      });\r\n\r\n      const newUser = await pb.collection('users').create(userData)\r\n      debugLogger.log('[POCKETBASE_AUTH_STORE]', 'User created successfully', {\r\n        userId: newUser.id\r\n      });\r\n\r\n      // Authenticate the newly created user\r\n      const authData = await pb.collection('users').authWithPassword(userData.email, password)\r\n      debugLogger.log('[POCKETBASE_AUTH_STORE]', 'SignUp with auth successful', {\r\n        userId: authData.record.id,\r\n        hasToken: !!authData.token\r\n      });\r\n\r\n      const user = await convertPocketbaseUser(authData.record)\r\n      \r\n      set({\r\n        user,\r\n        session: authData,\r\n        isAuthenticated: true,\r\n        isLoading: false,\r\n        error: null\r\n      })\r\n\r\n    } catch (error) {\r\n      debugLogger.error('[POCKETBASE_AUTH_STORE]', 'SignUp error', {\r\n        error,\r\n        stack: error instanceof Error ? error.stack : undefined\r\n      });\r\n\r\n      set({\r\n        error: handleSignUpError(error),\r\n        isLoading: false\r\n      })\r\n    }\r\n\r\n    debugLogger.log('[POCKETBASE_AUTH_STORE]', 'END - signUp');\r\n  },\r\n\r\n  signIn: async (email: string, password: string) => {\r\n    debugLogger.log('[POCKETBASE_AUTH_STORE]', 'START - signIn', {\r\n      email,\r\n      passwordLength: password.length,\r\n      isDemoLogin: email === 'demo'\r\n    });\r\n\r\n    set({ isLoading: true, error: null })\r\n    \r\n    const timeoutId = setTimeout(() => {\r\n      debugLogger.warn('[POCKETBASE_AUTH_STORE]', 'SignIn timeout reached');\r\n      set({ isLoading: false, error: 'Login timed out. Please try again.' })\r\n    }, 10000)\r\n    \r\n    try {\r\n      // Handle demo login in development\r\n      if (isDemoLogin(email, password)) {\r\n        debugLogger.info('[POCKETBASE_AUTH_STORE]', 'Demo login detected (development mode)');\r\n        const demoUser = createDemoUser()\r\n        \r\n        clearTimeout(timeoutId)\r\n        set({\r\n          user: demoUser,\r\n          session: null,\r\n          isAuthenticated: true,\r\n          isLoading: false,\r\n          error: null\r\n        })\r\n        \r\n        debugLogger.log('[POCKETBASE_AUTH_STORE]', 'END - signIn (demo user)');\r\n        return\r\n      }\r\n\r\n      // Validate inputs for regular login\r\n      validateSignInInputs(email, password)\r\n      \r\n      // Perform PocketBase authentication\r\n      debugLogger.log('[POCKETBASE_AUTH_STORE]', 'Attempting PocketBase authentication');\r\n      const authData = await performPocketBaseAuth(email, password)\r\n\r\n      debugLogger.log('[POCKETBASE_AUTH_STORE]', 'SignIn response', {\r\n        hasRecord: !!authData.record,\r\n        hasToken: !!authData.token,\r\n        userId: authData.record?.id\r\n      });\r\n\r\n      if (authData.record && authData.token) {\r\n        debugLogger.log('[POCKETBASE_AUTH_STORE]', 'SignIn successful, converting user profile');\r\n        \r\n        const user = await convertPocketbaseUser(authData.record)\r\n        await updateUserLastActive(authData.record.id)\r\n        \r\n        clearTimeout(timeoutId)\r\n        \r\n        set({\r\n          user,\r\n          session: authData,\r\n          isAuthenticated: true,\r\n          isLoading: false,\r\n          error: null\r\n        })\r\n        \r\n        debugLogger.log('[POCKETBASE_AUTH_STORE]', 'END - signIn (success)');\r\n      } else {\r\n        debugLogger.warn('[POCKETBASE_AUTH_STORE]', 'No user or token in response');\r\n        clearTimeout(timeoutId)\r\n        set({\r\n          error: 'Invalid login response - no user or token',\r\n          isLoading: false\r\n        })\r\n      }\r\n    } catch (error) {\r\n      debugLogger.error('[POCKETBASE_AUTH_STORE]', 'SignIn error', {\r\n        error,\r\n        stack: error instanceof Error ? error.stack : undefined\r\n      });\r\n      \r\n      clearTimeout(timeoutId)\r\n      set({\r\n        error: handleSignInError(error),\r\n        isLoading: false\r\n      })\r\n    }\r\n\r\n    debugLogger.log('[POCKETBASE_AUTH_STORE]', 'END - signIn');\r\n  },\r\n\r\n  signOut: async () => {\r\n    debugLogger.log('[POCKETBASE_AUTH_STORE]', 'START - signOut');\r\n    \r\n    try {\r\n      debugLogger.log('[POCKETBASE_AUTH_STORE]', 'Calling PocketBase authStore.clear');\r\n      pb.authStore.clear()\r\n      \r\n      debugLogger.log('[POCKETBASE_AUTH_STORE]', 'Clearing auth state');\r\n      set({ \r\n        user: null,\r\n        session: null,\r\n        isAuthenticated: false, \r\n        error: null \r\n      })\r\n      \r\n      debugLogger.log('[POCKETBASE_AUTH_STORE]', 'END - signOut (success)');\r\n    } catch (error) {\r\n      debugLogger.error('[POCKETBASE_AUTH_STORE]', 'SignOut error', {\r\n        error,\r\n        stack: error instanceof Error ? error.stack : undefined\r\n      });\r\n      \r\n      set({\r\n        error: error instanceof Error ? error.message : 'Logout failed'\r\n      })\r\n    }\r\n  },\r\n\r\n  resetPassword: async (email: string) => {\r\n    debugLogger.log('[POCKETBASE_AUTH_STORE]', 'START - resetPassword', { email });\r\n    \r\n    set({ isLoading: true, error: null })\r\n    \r\n    try {\r\n      await pb.collection('users').requestPasswordReset(email)\r\n      \r\n      set({\r\n        isLoading: false,\r\n        error: null\r\n      })\r\n      \r\n      debugLogger.log('[POCKETBASE_AUTH_STORE]', 'END - resetPassword (success)');\r\n    } catch (error) {\r\n      debugLogger.error('[POCKETBASE_AUTH_STORE]', 'Reset password error', {\r\n        error,\r\n        stack: error instanceof Error ? error.stack : undefined\r\n      });\r\n      \r\n      let errorMessage = 'Password reset failed'\r\n      if (error instanceof Error) {\r\n        if (error.message.includes('Invalid email')) {\r\n          errorMessage = 'Please enter a valid email address.'\r\n        } else if (error.message.includes('not found')) {\r\n          errorMessage = 'No account found with this email address.'\r\n        } else {\r\n          errorMessage = error.message\r\n        }\r\n      }\r\n      \r\n      set({\r\n        error: errorMessage,\r\n        isLoading: false\r\n      })\r\n    }\r\n  },\r\n\r\n  updatePassword: async (newPassword: string) => {\r\n    debugLogger.log('[POCKETBASE_AUTH_STORE]', 'START - updatePassword', {\r\n      passwordLength: newPassword.length\r\n    });\r\n    \r\n    const currentState = get();\r\n    debugLogger.log('[POCKETBASE_AUTH_STORE]', 'Current auth state', {\r\n      hasUser: !!currentState.user,\r\n      hasSession: !!currentState.session,\r\n      isAuthenticated: currentState.isAuthenticated\r\n    });\r\n    \r\n    set({ isLoading: true, error: null });\r\n    \r\n    try {\r\n      // Validate password\r\n      if (!newPassword || newPassword.length < 6) {\r\n        throw new Error(\"Password must be at least 6 characters long.\");\r\n      }\r\n\r\n      if (!currentState.user?.id) {\r\n        throw new Error('No authenticated user found');\r\n      }\r\n\r\n      debugLogger.log('[POCKETBASE_AUTH_STORE]', 'Calling pb.collection.update');\r\n\r\n      await pb.collection('users').update(currentState.user.id, {\r\n        password: newPassword,\r\n        passwordConfirm: newPassword\r\n      });\r\n\r\n      debugLogger.log('[POCKETBASE_AUTH_STORE]', 'Password update successful');\r\n\r\n      set({ isLoading: false, error: null });\r\n      \r\n      debugLogger.log('[POCKETBASE_AUTH_STORE]', 'END - updatePassword (success)');\r\n    } catch (error) {\r\n      const errorMessage =\r\n        error instanceof Error\r\n          ? error.message\r\n          : \"An unknown error occurred during password update.\";\r\n      \r\n      debugLogger.error('[POCKETBASE_AUTH_STORE]', 'UpdatePassword failed', {\r\n        error: errorMessage,\r\n        errorType: error?.constructor?.name,\r\n        stack: error instanceof Error ? error.stack : undefined\r\n      });\r\n      \r\n      set({ isLoading: false, error: errorMessage });\r\n      \r\n      throw new Error(errorMessage);\r\n    }\r\n  },\r\n\r\n  updateProfile: async (updates: Partial<User>) => {\r\n    const { user } = get()\r\n    \r\n    debugLogger.log('[POCKETBASE_AUTH_STORE]', 'START - updateProfile', {\r\n      userId: user?.id,\r\n      updates: Object.keys(updates)\r\n    });\r\n    \r\n    if (!user) {\r\n      debugLogger.warn('[POCKETBASE_AUTH_STORE]', 'No user found for profile update');\r\n      return\r\n    }\r\n    \r\n    try {\r\n      const updateData = {\r\n        username: updates.username,\r\n        level: updates.level,\r\n        total_xp: updates.totalXp,\r\n        coins: updates.coins,\r\n        gems: updates.gems,\r\n        preferences: updates.preferences,\r\n        last_active: new Date().toISOString()\r\n      };\r\n      \r\n      debugLogger.log('[POCKETBASE_AUTH_STORE]', 'Updating profile in database', updateData);\r\n      \r\n      await pb.collection('users').update(user.id, updateData)\r\n      \r\n      debugLogger.log('[POCKETBASE_AUTH_STORE]', 'Updating local user state');\r\n      set({ user: { ...user, ...updates } })\r\n      \r\n      debugLogger.log('[POCKETBASE_AUTH_STORE]', 'END - updateProfile (success)');\r\n    } catch (error) {\r\n      debugLogger.error('[POCKETBASE_AUTH_STORE]', 'Profile update error', {\r\n        error,\r\n        stack: error instanceof Error ? error.stack : undefined\r\n      });\r\n      \r\n      set({\r\n        error: error instanceof Error ? error.message : 'Profile update failed'\r\n      })\r\n    }\r\n  },\r\n\r\n  clearError: () => {\r\n    debugLogger.log('[POCKETBASE_AUTH_STORE]', 'Clearing error state');\r\n    set({ error: null })\r\n  },\r\n\r\n  initializeAuth: async () => {\r\n    debugLogger.log('[POCKETBASE_AUTH_STORE]', 'START - initializeAuth');\r\n    \r\n    try {\r\n      if (pb.authStore.isValid && pb.authStore.model) {\r\n        debugLogger.log('[POCKETBASE_AUTH_STORE]', 'Valid auth store found, converting user', {\r\n          userId: pb.authStore.model.id,\r\n          email: pb.authStore.model.email\r\n        });\r\n        \r\n        const user = await convertPocketbaseUser(pb.authStore.model)\r\n        \r\n        debugLogger.log('[POCKETBASE_AUTH_STORE]', 'Setting authenticated state from initialization');\r\n        set({\r\n          user,\r\n          session: {\r\n            record: pb.authStore.model,\r\n            token: pb.authStore.token\r\n          },\r\n          isAuthenticated: true\r\n        })\r\n      } else {\r\n        debugLogger.info('[POCKETBASE_AUTH_STORE]', 'No valid auth store found during initialization');\r\n      }\r\n      \r\n      debugLogger.log('[POCKETBASE_AUTH_STORE]', 'END - initializeAuth');\r\n    } catch (error) {\r\n      debugLogger.error('[POCKETBASE_AUTH_STORE]', 'Auth initialization error', {\r\n        error,\r\n        stack: error instanceof Error ? error.stack : undefined\r\n      });\r\n      \r\n      set({ \r\n        user: null,\r\n        session: null,\r\n        isAuthenticated: false \r\n      })\r\n    }\r\n  },\r\n\r\n  // Unified methods for backward compatibility with existing components\r\n  login: async (email: string, password: string) => {\r\n    const { signIn } = get()\r\n    await signIn(email, password)\r\n  },\r\n\r\n  register: async (email: string, username: string, password: string) => {\r\n    const { signUp } = get()\r\n    await signUp(email, password, username)\r\n  },\r\n\r\n  logout: () => {\r\n    const { signOut } = get()\r\n    signOut()\r\n  },\r\n\r\n  updateUser: (updates: Partial<User>) => {\r\n    const { user } = get()\r\n    if (user) {\r\n      set({ user: { ...user, ...updates } })\r\n    }\r\n  }\r\n}))\r\n\r\n// Set up auth state change listener\r\npb.authStore.onChange((token, record) => {\r\n  debugLogger.info('[POCKETBASE_AUTH_STORE]', 'Auth state change detected', {\r\n    hasToken: !!token,\r\n    hasRecord: !!record,\r\n    userId: record?.id,\r\n    timestamp: new Date().toISOString()\r\n  });\r\n  \r\n  if (token && record) {\r\n    debugLogger.log('[POCKETBASE_AUTH_STORE]', 'Processing auth state change - user logged in');\r\n    \r\n    convertPocketbaseUser(record).then(user => {\r\n      debugLogger.log('[POCKETBASE_AUTH_STORE]', 'Updating auth store for logged in user');\r\n      useAuthStore.setState({\r\n        user,\r\n        session: { record, token },\r\n        isAuthenticated: true\r\n      })\r\n    }).catch(error => {\r\n      debugLogger.error('[POCKETBASE_AUTH_STORE]', 'Failed to convert user during auth change', {\r\n        error,\r\n        userId: record.id\r\n      });\r\n    });\r\n  } else {\r\n    debugLogger.log('[POCKETBASE_AUTH_STORE]', 'Processing auth state change - user logged out');\r\n    \r\n    useAuthStore.setState({\r\n      user: null,\r\n      session: null,\r\n      isAuthenticated: false\r\n    })\r\n  }\r\n})","import { create } from 'zustand'\r\nimport { persist } from 'zustand/middleware'\r\n\r\ntype Theme = 'light' | 'dark' | 'system'\r\n\r\ninterface ThemeState {\r\n  theme: Theme\r\n  systemTheme: 'light' | 'dark'\r\n  \r\n  // Actions\r\n  setTheme: (theme: Theme) => void\r\n  toggleTheme: () => void\r\n  initializeTheme: () => void\r\n}\r\n\r\nexport const useThemeStore = create<ThemeState>()(\r\n  persist(\r\n    (set, get) => ({\r\n      theme: 'system',\r\n      systemTheme: 'light',\r\n\r\n      setTheme: (theme: Theme) => {\r\n        set({ theme })\r\n        \r\n        // Apply theme immediately\r\n        const { systemTheme } = get()\r\n        const effectiveTheme = theme === 'system' ? systemTheme : theme\r\n        \r\n        if (effectiveTheme === 'dark') {\r\n          document.documentElement.classList.add('dark')\r\n        } else {\r\n          document.documentElement.classList.remove('dark')\r\n        }\r\n      },\r\n\r\n      toggleTheme: () => {\r\n        const { theme } = get()\r\n        const newTheme = theme === 'light' ? 'dark' : 'light'\r\n        get().setTheme(newTheme)\r\n      },\r\n\r\n      initializeTheme: () => {\r\n        // Detect system theme preference\r\n        const systemTheme = window.matchMedia('(prefers-color-scheme: dark)').matches \r\n          ? 'dark' \r\n          : 'light'\r\n        \r\n        set({ systemTheme })\r\n        \r\n        // Listen for system theme changes\r\n        window.matchMedia('(prefers-color-scheme: dark)')\r\n          .addEventListener('change', (e) => {\r\n            const newSystemTheme = e.matches ? 'dark' : 'light'\r\n            set({ systemTheme: newSystemTheme })\r\n            \r\n            // If using system theme, update the applied theme\r\n            const { theme } = get()\r\n            if (theme === 'system') {\r\n              if (newSystemTheme === 'dark') {\r\n                document.documentElement.classList.add('dark')\r\n              } else {\r\n                document.documentElement.classList.remove('dark')\r\n              }\r\n            }\r\n          })\r\n        \r\n        // Apply initial theme\r\n        const { theme } = get()\r\n        const effectiveTheme = theme === 'system' ? systemTheme : theme\r\n        \r\n        if (effectiveTheme === 'dark') {\r\n          document.documentElement.classList.add('dark')\r\n        } else {\r\n          document.documentElement.classList.remove('dark')\r\n        }\r\n      }\r\n    }),\r\n    {\r\n      name: 'theme-storage',\r\n      partialize: (state) => ({ theme: state.theme })\r\n    }\r\n  )\r\n)","import { create } from 'zustand'\r\nimport { persist } from 'zustand/middleware'\r\nimport type {\r\n  Achievement,\r\n  UserAchievement,\r\n  UserStreak,\r\n  Challenge,\r\n  ChallengeParticipation,\r\n  Leaderboard,\r\n  WeeklyProgress\r\n} from '@shared/types'\r\n\r\ninterface UserStats {\r\n  totalCards: number\r\n  cardsStudiedToday: number\r\n  cardsStudiedThisWeek: number\r\n  cardsStudiedThisMonth: number\r\n  averageAccuracy: number\r\n  totalStudyTime: number // in minutes\r\n  studyTimeToday: number // in minutes\r\n  studyTimeThisWeek: number // in minutes\r\n  decksCreated: number\r\n  decksCompleted: number\r\n  longestStreak: number\r\n  currentStreak: number\r\n  // Currency system\r\n  gold: number\r\n  diamonds: number\r\n  // User level and XP\r\n  level: number\r\n  xp: number\r\n  xpToNextLevel: number\r\n}\r\n\r\ninterface GamificationState {\r\n  // User stats\r\n  userStats: UserStats\r\n  \r\n  // Achievements\r\n  achievements: Achievement[]\r\n  userAchievements: UserAchievement[]\r\n  \r\n  // Streaks\r\n  userStreak: UserStreak | null\r\n  \r\n  // Challenges\r\n  activeChallenges: Challenge[]\r\n  userChallengeParticipations: ChallengeParticipation[]\r\n  \r\n  // Leaderboards\r\n  leaderboards: Record<string, Leaderboard>\r\n  \r\n  // User state tracking\r\n  isFirstTimeUser: boolean\r\n  isInitialized: boolean\r\n  \r\n  // Actions\r\n  updateUserStats: (stats: Partial<UserStats>) => void\r\n  addUserAchievement: (achievementId: string) => void\r\n  updateStreak: (streak: Partial<UserStreak>) => void\r\n  joinChallenge: (challengeId: string) => void\r\n  updateChallengeProgress: (challengeId: string, progress: Record<string, number>) => void\r\n  claimChallengeReward: (challengeId: string) => void\r\n  initializeMockData: () => void\r\n  initializeNewUser: () => void\r\n  initializeUserData: (isDemo?: boolean) => void\r\n  resetAllUserData: () => void\r\n  addCurrency: (gold: number, diamonds: number) => void\r\n  spendCurrency: (gold: number, diamonds: number) => boolean\r\n  awardStudyXP: (cardsStudied: number, correctAnswers: number) => void\r\n  \r\n  // Monthly Challenge Management\r\n  updateMilestoneProgress: (challengeId: string, milestoneId: string, completed: boolean) => void\r\n  updateWeeklyProgress: (challengeId: string, weekData: WeeklyProgress) => void\r\n  updateChallengeStreak: (challengeId: string, streak: number) => void\r\n  unlockStoryChapter: (challengeId: string, week: number) => void\r\n  claimMilestoneReward: (challengeId: string, milestoneId: string) => void\r\n  contributeToCommunityGoal: (goalId: string, contribution: number) => void\r\n}\r\n\r\n// Mock data\r\nconst mockAchievements: Achievement[] = [\r\n  {\r\n    id: '1',\r\n    name: 'First Steps',\r\n    description: 'Complete your first study session',\r\n    icon: '',\r\n    category: 'study_milestones',\r\n    requirements: [{ type: 'sessions_completed', value: 1, operator: 'gte' }],\r\n    xpReward: 50,\r\n    coinReward: 10,\r\n    isSecret: false,\r\n    rarity: 'common'\r\n  },\r\n  {\r\n    id: '2',\r\n    name: 'Streak Master',\r\n    description: 'Maintain a 7-day study streak',\r\n    icon: '',\r\n    category: 'streaks',\r\n    requirements: [{ type: 'current_streak', value: 7, operator: 'gte' }],\r\n    xpReward: 200,\r\n    coinReward: 50,\r\n    isSecret: false,\r\n    rarity: 'rare'\r\n  },\r\n  {\r\n    id: '3',\r\n    name: 'Perfect Score',\r\n    description: 'Get 100% accuracy in a 20+ card session',\r\n    icon: '',\r\n    category: 'accuracy',\r\n    requirements: [\r\n      { type: 'session_accuracy', value: 100, operator: 'eq' },\r\n      { type: 'session_cards', value: 20, operator: 'gte' }\r\n    ],\r\n    xpReward: 150,\r\n    coinReward: 30,\r\n    isSecret: false,\r\n    rarity: 'rare'\r\n  },\r\n  {\r\n    id: '4',\r\n    name: 'Speed Demon',\r\n    description: 'Complete 50 cards in under 10 minutes',\r\n    icon: '',\r\n    category: 'special',\r\n    requirements: [\r\n      { type: 'cards_in_session', value: 50, operator: 'gte' },\r\n      { type: 'session_time', value: 600, operator: 'lte' }\r\n    ],\r\n    xpReward: 300,\r\n    coinReward: 75,\r\n    isSecret: false,\r\n    rarity: 'epic'\r\n  },\r\n  {\r\n    id: '5',\r\n    name: 'Scholar',\r\n    description: 'Study 1000 cards total',\r\n    icon: '',\r\n    category: 'study_milestones',\r\n    requirements: [{ type: 'total_cards', value: 1000, operator: 'gte' }],\r\n    xpReward: 500,\r\n    coinReward: 100,\r\n    isSecret: false,\r\n    rarity: 'epic'\r\n  },\r\n  {\r\n    id: '6',\r\n    name: 'Legend',\r\n    description: 'Reach level 20',\r\n    icon: '',\r\n    category: 'special',\r\n    requirements: [{ type: 'user_level', value: 20, operator: 'gte' }],\r\n    xpReward: 1000,\r\n    coinReward: 500,\r\n    isSecret: false,\r\n    rarity: 'legendary'\r\n  }\r\n]\r\n\r\nconst mockChallenges: Challenge[] = [\r\n  {\r\n    id: '1',\r\n    title: 'Daily Grind',\r\n    description: 'Study 25 cards today',\r\n    type: 'daily',\r\n    requirements: [{ type: 'cards_studied_today', target: 25, description: 'Study 25 cards' }],\r\n    rewards: [\r\n      { type: 'xp', amount: 50 },\r\n      { type: 'coins', amount: 10 }\r\n    ],\r\n    startDate: new Date().toISOString(),\r\n    endDate: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString(),\r\n    isActive: true,\r\n    participantCount: 1247\r\n  },\r\n  {\r\n    id: '2',\r\n    title: 'Weekly Warrior',\r\n    description: 'Complete 200 cards this week',\r\n    type: 'weekly',\r\n    requirements: [{ type: 'cards_studied_week', target: 200, description: 'Study 200 cards this week' }],\r\n    rewards: [\r\n      { type: 'xp', amount: 200 },\r\n      { type: 'coins', amount: 50 },\r\n      { type: 'gems', amount: 5 }\r\n    ],\r\n    startDate: new Date(Date.now() - 3 * 24 * 60 * 60 * 1000).toISOString(),\r\n    endDate: new Date(Date.now() + 4 * 24 * 60 * 60 * 1000).toISOString(),\r\n    isActive: true,\r\n    participantCount: 892\r\n  },\r\n  {\r\n    id: '3',\r\n    title: 'Accuracy Master',\r\n    description: 'Maintain 90%+ accuracy for 5 sessions',\r\n    type: 'weekly',\r\n    requirements: [{ type: 'accuracy_sessions', target: 5, description: 'Complete 5 sessions with 90%+ accuracy' }],\r\n    rewards: [\r\n      { type: 'xp', amount: 300 },\r\n      { type: 'coins', amount: 75 },\r\n      { type: 'badge', itemId: 'accuracy_master' }\r\n    ],\r\n    startDate: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000).toISOString(),\r\n    endDate: new Date(Date.now() + 5 * 24 * 60 * 60 * 1000).toISOString(),\r\n    isActive: true,\r\n    participantCount: 456\r\n  }\r\n]\r\n\r\nconst mockLeaderboards: Record<string, Leaderboard> = {\r\n  'xp_weekly': {\r\n    id: 'xp_weekly',\r\n    type: 'xp',\r\n    period: 'weekly',\r\n    entries: [\r\n      { userId: '1', username: 'DemoUser', score: 2500, rank: 1, change: 0 },\r\n      { userId: '2', username: 'StudyMaster', score: 2350, rank: 2, change: 1 },\r\n      { userId: '3', username: 'FlashcardPro', score: 2200, rank: 3, change: -1 },\r\n      { userId: '4', username: 'LearnFast', score: 2100, rank: 4, change: 2 },\r\n      { userId: '5', username: 'MemoryKing', score: 2050, rank: 5, change: -1 },\r\n      { userId: '6', username: 'QuizWhiz', score: 1980, rank: 6, change: 0 },\r\n      { userId: '7', username: 'CardShark', score: 1920, rank: 7, change: 3 },\r\n      { userId: '8', username: 'BrainBoost', score: 1850, rank: 8, change: -2 },\r\n      { userId: '9', username: 'StudyBuddy', score: 1800, rank: 9, change: 1 },\r\n      { userId: '10', username: 'FlashGenius', score: 1750, rank: 10, change: -1 }\r\n    ],\r\n    updatedAt: new Date().toISOString()\r\n  },\r\n  'streak_all_time': {\r\n    id: 'streak_all_time',\r\n    type: 'streak',\r\n    period: 'all_time',\r\n    entries: [\r\n      { userId: '2', username: 'StudyMaster', score: 45, rank: 1, change: 0 },\r\n      { userId: '3', username: 'FlashcardPro', score: 38, rank: 2, change: 0 },\r\n      { userId: '4', username: 'LearnFast', score: 32, rank: 3, change: 1 },\r\n      { userId: '1', username: 'DemoUser', score: 28, rank: 4, change: -1 },\r\n      { userId: '5', username: 'MemoryKing', score: 25, rank: 5, change: 0 },\r\n      { userId: '6', username: 'QuizWhiz', score: 22, rank: 6, change: 2 },\r\n      { userId: '7', username: 'CardShark', score: 20, rank: 7, change: -1 },\r\n      { userId: '8', username: 'BrainBoost', score: 18, rank: 8, change: -1 },\r\n      { userId: '9', username: 'StudyBuddy', score: 15, rank: 9, change: 0 },\r\n      { userId: '10', username: 'FlashGenius', score: 12, rank: 10, change: 0 }\r\n    ],\r\n    updatedAt: new Date().toISOString()\r\n  }\r\n}\r\n\r\n// Helper function to calculate level from XP\r\nconst calculateLevel = (xp: number): number => {\r\n  return Math.floor(Math.sqrt(xp / 100)) + 1\r\n}\r\n\r\n// Helper function to calculate XP needed for next level\r\nconst calculateXPToNextLevel = (level: number): number => {\r\n  const nextLevelXP = Math.pow(level, 2) * 100\r\n  return nextLevelXP\r\n}\r\n\r\n// Initial clean state for new users\r\nconst getInitialUserStats = (): UserStats => ({\r\n  totalCards: 0,\r\n  cardsStudiedToday: 0,\r\n  cardsStudiedThisWeek: 0,\r\n  cardsStudiedThisMonth: 0,\r\n  averageAccuracy: 0,\r\n  totalStudyTime: 0,\r\n  studyTimeToday: 0,\r\n  studyTimeThisWeek: 0,\r\n  decksCreated: 0,\r\n  decksCompleted: 0,\r\n  longestStreak: 0,\r\n  currentStreak: 0,\r\n  gold: 0,\r\n  diamonds: 0,\r\n  level: 1,\r\n  xp: 0,\r\n  xpToNextLevel: 100\r\n})\r\n\r\n// Demo data for demonstration purposes\r\nconst getDemoUserStats = (): UserStats => ({\r\n  totalCards: 1250,\r\n  cardsStudiedToday: 45,\r\n  cardsStudiedThisWeek: 180,\r\n  cardsStudiedThisMonth: 720,\r\n  averageAccuracy: 87.5,\r\n  totalStudyTime: 2400, // 40 hours\r\n  studyTimeToday: 35,\r\n  studyTimeThisWeek: 240, // 4 hours\r\n  decksCreated: 8,\r\n  decksCompleted: 3,\r\n  longestStreak: 28,\r\n  currentStreak: 12,\r\n  gold: 100,\r\n  diamonds: 10,\r\n  level: 8,\r\n  xp: 6400,\r\n  xpToNextLevel: 8100\r\n})\r\n\r\nexport const useGamificationStore = create<GamificationState>()(\r\n  persist(\r\n    (set, get) => ({\r\n      userStats: getInitialUserStats(),\r\n      isFirstTimeUser: true,\r\n      isInitialized: false,\r\n      \r\n      achievements: mockAchievements,\r\n      userAchievements: [],\r\n      \r\n      userStreak: null,\r\n      \r\n      activeChallenges: mockChallenges,\r\n      userChallengeParticipations: [],\r\n      \r\n      leaderboards: mockLeaderboards,\r\n      \r\n      updateUserStats: (stats) => {\r\n        set((state) => {\r\n          const newStats = { ...state.userStats, ...stats }\r\n          \r\n          // Recalculate level and XP if XP changed\r\n          if (stats.xp !== undefined) {\r\n            newStats.level = calculateLevel(newStats.xp)\r\n            newStats.xpToNextLevel = calculateXPToNextLevel(newStats.level)\r\n          }\r\n          \r\n          return {\r\n            userStats: newStats,\r\n            isFirstTimeUser: false,\r\n            isInitialized: true\r\n          }\r\n        })\r\n      },\r\n      \r\n      addUserAchievement: (achievementId) => {\r\n        const { userAchievements } = get()\r\n        if (!userAchievements.find(ua => ua.achievementId === achievementId)) {\r\n          set((state) => ({\r\n            userAchievements: [\r\n              ...state.userAchievements,\r\n              {\r\n                id: Date.now().toString(),\r\n                userId: '1',\r\n                achievementId,\r\n                earnedAt: new Date().toISOString()\r\n              }\r\n            ]\r\n          }))\r\n        }\r\n      },\r\n      \r\n      updateStreak: (streak) => {\r\n        set((state) => ({\r\n          userStreak: state.userStreak ? { ...state.userStreak, ...streak } : null\r\n        }))\r\n      },\r\n      \r\n      joinChallenge: (challengeId) => {\r\n        const { userChallengeParticipations } = get()\r\n        if (!userChallengeParticipations.find(p => p.challengeId === challengeId)) {\r\n          set((state) => ({\r\n            userChallengeParticipations: [\r\n              ...state.userChallengeParticipations,\r\n              {\r\n                id: Date.now().toString(),\r\n                userId: '1',\r\n                challengeId,\r\n                progress: {},\r\n                completed: false,\r\n                joinedAt: new Date().toISOString(),\r\n                milestoneProgress: {},\r\n                weeklyProgress: [],\r\n                currentStreak: 0,\r\n                bestWeek: 0\r\n              }\r\n            ]\r\n          }))\r\n        }\r\n      },\r\n      \r\n      updateChallengeProgress: (challengeId, progress) => {\r\n        set((state) => ({\r\n          userChallengeParticipations: state.userChallengeParticipations.map(p =>\r\n            p.challengeId === challengeId\r\n              ? { ...p, progress: { ...p.progress, ...progress } }\r\n              : p\r\n          )\r\n        }))\r\n      },\r\n      \r\n      claimChallengeReward: (challengeId) => {\r\n        const { activeChallenges, userChallengeParticipations } = get()\r\n        const challenge = activeChallenges.find(c => c.id === challengeId)\r\n        const participation = userChallengeParticipations.find(p => p.challengeId === challengeId)\r\n        \r\n        if (challenge && participation && participation.completed) {\r\n          // Calculate total XP and coins from rewards\r\n          let xpGained = 0\r\n          // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n          let _coinsGained = 0\r\n          \r\n          challenge.rewards.forEach(reward => {\r\n            if (reward.type === 'xp' && reward.amount) {\r\n              xpGained += reward.amount\r\n            } else if (reward.type === 'coins' && reward.amount) {\r\n              _coinsGained += reward.amount\r\n            }\r\n          })\r\n          \r\n          // Update user stats with rewards\r\n          set((state) => ({\r\n            userStats: {\r\n              ...state.userStats,\r\n              totalCards: state.userStats.totalCards + xpGained / 10 // Rough conversion\r\n            },\r\n            // Remove the participation since reward is claimed\r\n            userChallengeParticipations: state.userChallengeParticipations.filter(\r\n              p => p.challengeId !== challengeId\r\n            )\r\n          }))\r\n        }\r\n      },\r\n      \r\n      initializeMockData: () => {\r\n        // This function can be called to load demo data\r\n        set({\r\n          userStats: getDemoUserStats(),\r\n          achievements: mockAchievements,\r\n          activeChallenges: mockChallenges,\r\n          leaderboards: mockLeaderboards,\r\n          userAchievements: [\r\n            {\r\n              id: '1',\r\n              userId: '1',\r\n              achievementId: '1',\r\n              earnedAt: new Date(Date.now() - 10 * 24 * 60 * 60 * 1000).toISOString()\r\n            },\r\n            {\r\n              id: '2',\r\n              userId: '1',\r\n              achievementId: '2',\r\n              earnedAt: new Date(Date.now() - 5 * 24 * 60 * 60 * 1000).toISOString()\r\n            }\r\n          ],\r\n          userStreak: {\r\n            id: '1',\r\n            userId: '1',\r\n            currentStreak: 12,\r\n            longestStreak: 28,\r\n            lastStudyDate: new Date().toISOString(),\r\n            freezeCount: 2,\r\n            createdAt: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString()\r\n          },\r\n          userChallengeParticipations: [\r\n            {\r\n              id: '1',\r\n              userId: '1',\r\n              challengeId: '1',\r\n              progress: { cards_studied_today: 45 } as Record<string, number>,\r\n              completed: true,\r\n              joinedAt: new Date().toISOString(),\r\n              completedAt: new Date().toISOString(),\r\n              milestoneProgress: { 'milestone_1': true },\r\n              weeklyProgress: [],\r\n              currentStreak: 5,\r\n              bestWeek: 1\r\n            },\r\n            {\r\n              id: '2',\r\n              userId: '1',\r\n              challengeId: '2',\r\n              progress: { cards_studied_week: 180 } as Record<string, number>,\r\n              completed: false,\r\n              joinedAt: new Date(Date.now() - 3 * 24 * 60 * 60 * 1000).toISOString(),\r\n              milestoneProgress: { 'milestone_1': true, 'milestone_2': false },\r\n              weeklyProgress: [\r\n                {\r\n                  week: 1,\r\n                  startDate: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString(),\r\n                  endDate: new Date().toISOString(),\r\n                  progress: { cards_studied_week: 180 },\r\n                  completed: true,\r\n                  completedAt: new Date().toISOString(),\r\n                  storyUnlocked: true\r\n                }\r\n              ],\r\n              currentStreak: 3,\r\n              bestWeek: 1\r\n            }\r\n          ] as ChallengeParticipation[],\r\n          isFirstTimeUser: false,\r\n          isInitialized: true\r\n        })\r\n      },\r\n\r\n      initializeNewUser: () => {\r\n        // Initialize a completely fresh user\r\n        set({\r\n          userStats: getInitialUserStats(),\r\n          userAchievements: [],\r\n          userStreak: null,\r\n          userChallengeParticipations: [],\r\n          isFirstTimeUser: false,\r\n          isInitialized: true\r\n        })\r\n      },\r\n\r\n      resetAllUserData: () => {\r\n        // Reset all user-specific data to initial state\r\n        set({\r\n          userStats: getInitialUserStats(),\r\n          userAchievements: [],\r\n          userStreak: null,\r\n          userChallengeParticipations: [],\r\n          isFirstTimeUser: true,\r\n          isInitialized: true\r\n        })\r\n      },\r\n\r\n      addCurrency: (gold, diamonds) => {\r\n        set((state) => ({\r\n          userStats: {\r\n            ...state.userStats,\r\n            gold: state.userStats.gold + gold,\r\n            diamonds: state.userStats.diamonds + diamonds\r\n          }\r\n        }))\r\n      },\r\n\r\n      spendCurrency: (gold, diamonds) => {\r\n        const { userStats } = get()\r\n        if (userStats.gold >= gold && userStats.diamonds >= diamonds) {\r\n          set((state) => ({\r\n            userStats: {\r\n              ...state.userStats,\r\n              gold: state.userStats.gold - gold,\r\n              diamonds: state.userStats.diamonds - diamonds\r\n            }\r\n          }))\r\n          return true\r\n        }\r\n        return false\r\n      },\r\n\r\n      // Initialize user data based on authentication status\r\n      initializeUserData: (isDemo: boolean = false) => {\r\n        const state = get()\r\n        \r\n        // Only initialize if not already done\r\n        if (!state.isInitialized) {\r\n          if (isDemo) {\r\n            // Load demo data for demo users\r\n            set({\r\n              userStats: getDemoUserStats(),\r\n              achievements: mockAchievements,\r\n              activeChallenges: mockChallenges,\r\n              leaderboards: mockLeaderboards,\r\n              userAchievements: [\r\n                {\r\n                  id: '1',\r\n                  userId: '1',\r\n                  achievementId: '1',\r\n                  earnedAt: new Date(Date.now() - 10 * 24 * 60 * 60 * 1000).toISOString()\r\n                },\r\n                {\r\n                  id: '2',\r\n                  userId: '1',\r\n                  achievementId: '2',\r\n                  earnedAt: new Date(Date.now() - 5 * 24 * 60 * 60 * 1000).toISOString()\r\n                }\r\n              ],\r\n              userStreak: {\r\n                id: '1',\r\n                userId: '1',\r\n                currentStreak: 12,\r\n                longestStreak: 28,\r\n                lastStudyDate: new Date().toISOString(),\r\n                freezeCount: 2,\r\n                createdAt: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString()\r\n              },\r\n              userChallengeParticipations: [\r\n                {\r\n                  id: '1',\r\n                  userId: '1',\r\n                  challengeId: '1',\r\n                  progress: { cards_studied_today: 45 } as Record<string, number>,\r\n                  completed: true,\r\n                  joinedAt: new Date().toISOString(),\r\n                  completedAt: new Date().toISOString()\r\n                },\r\n                {\r\n                  id: '2',\r\n                  userId: '1',\r\n                  challengeId: '2',\r\n                  progress: { cards_studied_week: 180 } as Record<string, number>,\r\n                  completed: false,\r\n                  joinedAt: new Date(Date.now() - 3 * 24 * 60 * 60 * 1000).toISOString()\r\n                }\r\n              ] as ChallengeParticipation[],\r\n              isFirstTimeUser: false,\r\n              isInitialized: true\r\n            })\r\n          } else {\r\n            // Initialize fresh user data for new authenticated users\r\n            set({\r\n              userStats: getInitialUserStats(),\r\n              userAchievements: [],\r\n              userStreak: null,\r\n              userChallengeParticipations: [],\r\n              isFirstTimeUser: false,\r\n              isInitialized: true\r\n            })\r\n          }\r\n        }\r\n      },\r\n\r\n      // Monthly Challenge Management Methods\r\n      updateMilestoneProgress: (challengeId, milestoneId, completed) => {\r\n        set((state) => ({\r\n          userChallengeParticipations: state.userChallengeParticipations.map(p =>\r\n            p.challengeId === challengeId\r\n              ? {\r\n                  ...p,\r\n                  milestoneProgress: {\r\n                    ...p.milestoneProgress,\r\n                    [milestoneId]: completed\r\n                  }\r\n                }\r\n              : p\r\n          )\r\n        }))\r\n      },\r\n\r\n      updateWeeklyProgress: (challengeId, weekData) => {\r\n        set((state) => ({\r\n          userChallengeParticipations: state.userChallengeParticipations.map(p =>\r\n            p.challengeId === challengeId\r\n              ? {\r\n                  ...p,\r\n                  weeklyProgress: p.weeklyProgress\r\n                    ? [...p.weeklyProgress.filter(w => w.week !== weekData.week), weekData]\r\n                    : [weekData]\r\n                }\r\n              : p\r\n          )\r\n        }))\r\n      },\r\n\r\n      updateChallengeStreak: (challengeId, streak) => {\r\n        set((state) => ({\r\n          userChallengeParticipations: state.userChallengeParticipations.map(p =>\r\n            p.challengeId === challengeId\r\n              ? { ...p, currentStreak: streak }\r\n              : p\r\n          )\r\n        }))\r\n      },\r\n\r\n      unlockStoryChapter: (challengeId, week) => {\r\n        set((state) => ({\r\n          userChallengeParticipations: state.userChallengeParticipations.map(p =>\r\n            p.challengeId === challengeId\r\n              ? {\r\n                  ...p,\r\n                  weeklyProgress: p.weeklyProgress?.map(w =>\r\n                    w.week === week\r\n                      ? { ...w, storyUnlocked: true }\r\n                      : w\r\n                  ) || []\r\n                }\r\n              : p\r\n          )\r\n        }))\r\n      },\r\n\r\n      claimMilestoneReward: (challengeId, milestoneId) => {\r\n        // Find the challenge and milestone to get reward details\r\n        const { activeChallenges } = get()\r\n        const challenge = activeChallenges.find(c => c.id === challengeId)\r\n        \r\n        if (challenge) {\r\n          // Add milestone reward logic here\r\n          // For now, just mark milestone as claimed\r\n          set((state) => ({\r\n            userChallengeParticipations: state.userChallengeParticipations.map(p =>\r\n              p.challengeId === challengeId\r\n                ? {\r\n                    ...p,\r\n                    milestoneProgress: {\r\n                      ...p.milestoneProgress,\r\n                      [`${milestoneId}_claimed`]: true\r\n                    }\r\n                  }\r\n                : p\r\n            )\r\n          }))\r\n        }\r\n      },\r\n\r\n      contributeToCommunityGoal: (goalId, contribution) => {\r\n        // Update community goal progress\r\n        // This would typically involve API calls to update server-side data\r\n        // For now, we'll just update local state\r\n        console.log(`Contributing ${contribution} to community goal ${goalId}`)\r\n        \r\n        // Update user stats to reflect contribution\r\n        set((state) => ({\r\n          userStats: {\r\n            ...state.userStats,\r\n            // Add contribution tracking if needed\r\n          }\r\n        }))\r\n      },\r\n\r\n      awardStudyXP: (cardsStudied, correctAnswers) => {\r\n        // Award XP based on study performance\r\n        // Base XP: 1 XP per card studied\r\n        // Bonus XP: 1 additional XP per correct answer (rating higher than \"Again\")\r\n        // Milestone bonus: 10 XP for every 10 cards studied with good performance\r\n        \r\n        let xpGained = cardsStudied // Base XP\r\n        xpGained += correctAnswers // Bonus for correct answers\r\n        \r\n        // Milestone bonus: 10 XP for every 10 cards with good performance\r\n        const milestoneBonus = Math.floor(correctAnswers / 10) * 10\r\n        xpGained += milestoneBonus\r\n        \r\n        if (xpGained > 0) {\r\n          set((state) => {\r\n            const newXP = state.userStats.xp + xpGained\r\n            const newLevel = calculateLevel(newXP)\r\n            const newXPToNextLevel = calculateXPToNextLevel(newLevel)\r\n            \r\n            console.log(` XP Awarded: +${xpGained} XP (${cardsStudied} cards, ${correctAnswers} correct, ${milestoneBonus} milestone bonus)`)\r\n            console.log(` Total XP: ${state.userStats.xp}  ${newXP} (Level ${state.userStats.level}  ${newLevel})`)\r\n            \r\n            return {\r\n              userStats: {\r\n                ...state.userStats,\r\n                xp: newXP,\r\n                level: newLevel,\r\n                xpToNextLevel: newXPToNextLevel,\r\n                totalCards: state.userStats.totalCards + cardsStudied,\r\n                cardsStudiedToday: state.userStats.cardsStudiedToday + cardsStudied\r\n              }\r\n            }\r\n          })\r\n        }\r\n      }\r\n    }),\r\n    {\r\n      name: 'gamification-storage',\r\n      partialize: (state) => ({\r\n        userStats: state.userStats,\r\n        userAchievements: state.userAchievements,\r\n        userStreak: state.userStreak,\r\n        userChallengeParticipations: state.userChallengeParticipations,\r\n        isFirstTimeUser: state.isFirstTimeUser,\r\n        isInitialized: state.isInitialized\r\n      })\r\n    }\r\n  )\r\n)","import { Card, CardType, MediaReference } from '../../../shared/types'\r\n\r\n/**\r\n * Create a new card with all required Anki-style fields populated with defaults\r\n */\r\nexport function createNewCard(\r\n  frontContent: string,\r\n  backContent: string,\r\n  cardType: CardType = { type: 'basic' },\r\n  mediaRefs: MediaReference[] = []\r\n): Omit<Card, 'id' | 'createdAt' | 'deckId' | 'easeFactor' | 'intervalDays' | 'nextReview' | 'reviewCount' | 'lapseCount'> {\r\n  return {\r\n    frontContent,\r\n    backContent,\r\n    cardType,\r\n    mediaRefs,\r\n    \r\n    // Enhanced Anki-style fields with defaults\r\n    state: 'new',\r\n    queue: 0, // 0 = new\r\n    due: 0, // New cards have no due date\r\n    ivl: 0, // No interval yet\r\n    factor: 2500, // Default ease factor (250%)\r\n    reps: 0, // No repetitions yet\r\n    lapses: 0, // No lapses yet\r\n    left: 0, // No learning time left\r\n    \r\n    // Learning state defaults\r\n    learningStep: 0,\r\n    graduationInterval: 1, // Default 1 day\r\n    easyInterval: 4, // Default 4 days\r\n    \r\n    // Timing and performance defaults\r\n    totalStudyTime: 0,\r\n    averageAnswerTime: 0,\r\n    \r\n    // Metadata defaults\r\n    flags: 0,\r\n    originalDue: 0,\r\n    originalDeck: '', // Will be set when card is created\r\n    \r\n    // Gamification defaults\r\n    xpAwarded: 0,\r\n    difficultyRating: 3 // Default medium difficulty\r\n  }\r\n}\r\n\r\n/**\r\n * Create a complete card object for SVG map cards\r\n */\r\nexport function createSvgMapCard(\r\n  id: string,\r\n  deckId: string,\r\n  frontContent: string,\r\n  backContent: string,\r\n  cardType: CardType,\r\n  mediaRefs: MediaReference[] = []\r\n): Card {\r\n  const baseCard = createNewCard(frontContent, backContent, cardType, mediaRefs)\r\n  \r\n  return {\r\n    ...baseCard,\r\n    id,\r\n    deckId,\r\n    createdAt: new Date().toISOString(),\r\n    \r\n    // Legacy fields for backward compatibility\r\n    easeFactor: 2.5,\r\n    intervalDays: 0,\r\n    nextReview: new Date().toISOString(),\r\n    reviewCount: 0,\r\n    lapseCount: 0,\r\n    \r\n    // Set original deck\r\n    originalDeck: deckId\r\n  }\r\n}","import { create } from 'zustand'\nimport { persist } from 'zustand/middleware'\nimport { Deck, Card, DeckSettings } from '../../../shared/types'\nimport { createNewCard } from '../utils/cardDefaults'\n\ninterface StudySession {\n  deckId: string\n  currentCardIndex: number\n  studyCards: Card[] // For in-memory access during a session\n  studyCardIds: string[] // For persistence\n  sessionStats: {\n    total: number\n    correct: number\n    incorrect: number\n  }\n  startedAt: string\n}\n\ninterface DeckStore {\n  decks: Deck[]\n  cards: Record<string, Card[]> // deckId -> cards\n  currentStudySession: StudySession | null\n  isLoading: boolean\n  error: string | null\n  importProgress: number // 0-100\n  importStatus: string | null\n  \n  // Deck operations\n  createDeck: (deck: Omit<Deck, 'id' | 'createdAt' | 'updatedAt'>) => Promise<Deck>\n  updateDeck: (id: string, updates: Partial<Deck>) => Promise<void>\n  deleteDeck: (id: string) => Promise<void>\n  getDeck: (id: string) => Deck | undefined\n  \n  // Card operations\n  addCard: (deckId: string, card: Omit<Card, 'id' | 'deckId' | 'createdAt' | 'easeFactor' | 'intervalDays' | 'nextReview' | 'reviewCount' | 'lapseCount'>) => Promise<Card>\n  addCardBulk: (deckId: string, card: Omit<Card, 'id' | 'deckId' | 'createdAt' | 'easeFactor' | 'intervalDays' | 'nextReview' | 'reviewCount' | 'lapseCount'>) => Promise<Card>\n  addCardsBatch: (deckId: string, cards: Array<Omit<Card, 'id' | 'deckId' | 'createdAt' | 'easeFactor' | 'intervalDays' | 'nextReview' | 'reviewCount' | 'lapseCount'>>) => Promise<Card[]>\n  createDeckBulk: (deck: Omit<Deck, 'id' | 'createdAt' | 'updatedAt'>) => Promise<Deck>\n  updateCard: (cardId: string, updates: Partial<Card>) => Promise<void>\n  deleteCard: (cardId: string) => Promise<void>\n  getCards: (deckId: string) => Card[]\n  \n  // Import operations\n  importAnkiDeck: (file: File) => Promise<Deck>\n  importFromText: (deckName: string, text: string, separator?: string) => Promise<Deck>\n  \n  // Example data\n  loadExampleDecks: () => Promise<void>\n  \n  // Utility\n  clearError: () => void\n  setLoading: (loading: boolean) => void\n  setImportProgress: (progress: number, status?: string) => void\n  resetImportProgress: () => void\n  removeDuplicateCards: (deckId: string) => Promise<number>\n  \n  // Study session functions\n  startStudySession: (deckId: string, studyCards: Card[]) => void\n  updateStudySession: (currentCardIndex: number, sessionStats: StudySession['sessionStats']) => void\n  clearStudySession: () => void\n  getStudySession: (deckId: string) => StudySession | null\n  resetAllStudyData: () => void\n}\n\nconst defaultDeckSettings: DeckSettings = {\n  newCardsPerDay: 20,\n  maxReviewsPerDay: 100,\n  easyBonus: 1.3,\n  intervalModifier: 1.0,\n  maximumInterval: 36500, // 100 years\n  minimumInterval: 1\n}\n\n// Helper function to clean field content\nconst cleanFieldContent = (content: string): string => {\n  return content\n    .replace(/<[^>]*>/g, '') // Remove HTML tags\n    .replace(/&nbsp;/g, ' ')\n    .replace(/&lt;/g, '<')\n    .replace(/&gt;/g, '>')\n    .replace(/&amp;/g, '&')\n    .replace(/\\[sound:[^\\]]*\\]/g, '') // Remove sound references\n    .trim()\n}\n\n// Helper function to detect the best field combination for front/back\nconst detectBestFieldCombination = (sampleFields: string[][]): { frontIndex: number; backIndex: number } => {\n  if (sampleFields.length === 0) {\n    return { frontIndex: 0, backIndex: 1 }\n  }\n  \n  const fieldCount = sampleFields[0].length\n  const combinations: Array<{ frontIndex: number; backIndex: number; score: number }> = []\n  \n  // Try different field combinations\n  for (let front = 0; front < fieldCount; front++) {\n    for (let back = front + 1; back < fieldCount; back++) {\n      let score = 0\n      let validPairs = 0\n      \n      for (const fields of sampleFields) {\n        const frontContent = cleanFieldContent(fields[front] || '')\n        const backContent = cleanFieldContent(fields[back] || '')\n        \n        // Score based on content quality\n        if (frontContent && backContent) {\n          validPairs++\n          \n          // Prefer combinations where both fields have substantial content\n          if (frontContent.length > 2 && backContent.length > 2) {\n            score += 10\n          }\n          \n          // Prefer combinations where fields are different\n          if (frontContent !== backContent) {\n            score += 5\n          }\n          \n          // Avoid fields that look like audio references or numbers only\n          if (!frontContent.match(/^\\[sound:/) && !backContent.match(/^\\[sound:/)) {\n            score += 3\n          }\n          \n          if (!frontContent.match(/^\\d+$/) && !backContent.match(/^\\d+$/)) {\n            score += 2\n          }\n        }\n      }\n      \n      // Normalize score by number of valid pairs\n      const normalizedScore = validPairs > 0 ? score / validPairs : 0\n      combinations.push({ frontIndex: front, backIndex: back, score: normalizedScore })\n    }\n  }\n  \n  // Sort by score and return the best combination\n  combinations.sort((a, b) => b.score - a.score)\n  \n  if (combinations.length > 0 && combinations[0].score > 0) {\n    console.log(`Best field combination: ${combinations[0].frontIndex} -> ${combinations[0].backIndex} (score: ${combinations[0].score})`)\n    return { frontIndex: combinations[0].frontIndex, backIndex: combinations[0].backIndex }\n  }\n  \n  // Fallback to 0->1 or 0->2 if available\n  if (fieldCount >= 3) {\n    return { frontIndex: 0, backIndex: 2 }\n  }\n  return { frontIndex: 0, backIndex: 1 }\n}\n\n// Helper function to parse .apkg files (with dynamic imports for bundle optimization)\nconst parseApkgFile = async (file: File): Promise<{ name: string; cards: Array<{ front: string; back: string }> }> => {\n  try {\n    // Dynamic imports to reduce initial bundle size\n    const [{ default: JSZip }, { default: initSqlJs }] = await Promise.all([\n      import('jszip'),\n      import('sql.js')\n    ])\n\n    // Initialize SQL.js\n    const SQL = await initSqlJs({\n      locateFile: (file) => {\n        if (file.endsWith('.wasm')) {\n          return '/sql-wasm.wasm'\n        }\n        return `/${file}`\n      }\n    })\n\n    // Read the .apkg file as array buffer\n    const arrayBuffer = await file.arrayBuffer()\n    \n    // Extract the ZIP file\n    const zip = new JSZip()\n    const zipContent = await zip.loadAsync(arrayBuffer)\n    \n    // Get the collection.anki2 file (SQLite database)\n    const dbFile = zipContent.file('collection.anki2')\n    if (!dbFile) {\n      throw new Error('Invalid .apkg file: collection.anki2 not found')\n    }\n    \n    // Read the database file\n    const dbArrayBuffer = await dbFile.async('arraybuffer')\n    const db = new SQL.Database(new Uint8Array(dbArrayBuffer))\n    \n    // Query to get deck name from the col table\n    const deckQuery = db.exec(\"SELECT decks FROM col LIMIT 1\")\n    let deckName = file.name.replace(/\\.apkg$/, '')\n    if (deckQuery.length > 0 && deckQuery[0].values.length > 0) {\n      try {\n        const decksJson = deckQuery[0].values[0][0] as string\n        const decks = JSON.parse(decksJson)\n        // Find the first non-default deck (id != 1)\n        const deckIds = Object.keys(decks).filter(id => id !== '1')\n        if (deckIds.length > 0) {\n          deckName = decks[deckIds[0]].name || deckName\n        }\n      } catch (e) {\n        console.warn('Could not parse deck names from .apkg file, using filename')\n      }\n    }\n    \n    // Query to get notes and cards\n    const notesQuery = db.exec(`\n      SELECT n.flds, n.tags, c.type\n      FROM notes n\n      JOIN cards c ON n.id = c.nid\n      WHERE c.type >= 0\n      ORDER BY n.id\n    `)\n    \n    const cards: Array<{ front: string; back: string }> = []\n    \n    if (notesQuery.length > 0) {\n      // First, analyze a sample of fields to determine the best field combination\n      const sampleSize = Math.min(10, notesQuery[0].values.length)\n      const sampleFields: string[][] = []\n      \n      for (let i = 0; i < sampleSize; i++) {\n        const fields = (notesQuery[0].values[i][0] as string).split('\\x1f')\n        sampleFields.push(fields)\n      }\n      \n      // Detect the best field combination\n      const { frontIndex, backIndex } = detectBestFieldCombination(sampleFields)\n      console.log(`Using field combination: ${frontIndex} (front) -> ${backIndex} (back)`)\n      \n      // Process all cards using the detected field combination\n      for (const row of notesQuery[0].values) {\n        const fields = (row[0] as string).split('\\x1f') // Anki uses \\x1f as field separator\n        \n        if (fields.length > Math.max(frontIndex, backIndex)) {\n          const front = cleanFieldContent(fields[frontIndex] || '')\n          const back = cleanFieldContent(fields[backIndex] || '')\n          \n          if (front && back && front !== back) {\n            cards.push({ front, back })\n          }\n        }\n      }\n    }\n    \n    db.close()\n    \n    if (cards.length === 0) {\n      throw new Error('No valid cards found in the .apkg file')\n    }\n    \n    console.log(`Successfully parsed ${cards.length} cards from .apkg file`)\n    return { name: deckName, cards }\n  } catch (error) {\n    console.error('Error parsing .apkg file:', error)\n    throw new Error(`Failed to parse .apkg file: ${error instanceof Error ? error.message : 'Unknown error'}`)\n  }\n}\n\nexport const useDeckStore = create<DeckStore>()(\n  persist(\n    (set, get) => ({\n      decks: [],\n      cards: {},\n      currentStudySession: null,\n      isLoading: false,\n      error: null,\n      importProgress: 0,\n      importStatus: null,\n\n      createDeck: async (deckData) => {\n        set({ isLoading: true, error: null })\n        try {\n          const deck: Deck = {\n            ...deckData,\n            id: crypto.randomUUID(),\n            createdAt: new Date().toISOString(),\n            updatedAt: new Date().toISOString(),\n            settings: { ...defaultDeckSettings, ...deckData.settings }\n          }\n          \n          set(state => ({\n            decks: [...state.decks, deck],\n            cards: { ...state.cards, [deck.id]: [] },\n            isLoading: false\n          }))\n          \n          return deck\n        } catch (error) {\n          set({ error: 'Failed to create deck', isLoading: false })\n          throw error\n        }\n      },\n\n      updateDeck: async (id, updates) => {\n        set({ isLoading: true, error: null })\n        try {\n          set(state => ({\n            decks: state.decks.map(deck => \n              deck.id === id \n                ? { ...deck, ...updates, updatedAt: new Date().toISOString() }\n                : deck\n            ),\n            isLoading: false\n          }))\n        } catch (error) {\n          set({ error: 'Failed to update deck', isLoading: false })\n          throw error\n        }\n      },\n\n      deleteDeck: async (id) => {\n        set({ isLoading: true, error: null })\n        try {\n          set(state => {\n            // eslint-disable-next-line @typescript-eslint/no-unused-vars\n            const { [id]: _deletedCards, ...remainingCards } = state.cards\n            return {\n              decks: state.decks.filter(deck => deck.id !== id),\n              cards: remainingCards,\n              isLoading: false\n            }\n          })\n        } catch (error) {\n          set({ error: 'Failed to delete deck', isLoading: false })\n          throw error\n        }\n      },\n\n      getDeck: (id) => {\n        return get().decks.find(deck => deck.id === id)\n      },\n\n      addCard: async (deckId, cardData) => {\n        set({ isLoading: true, error: null })\n        try {\n          const card: Card = {\n            ...cardData,\n            id: crypto.randomUUID(),\n            deckId,\n            createdAt: new Date().toISOString(),\n            easeFactor: 2.5,\n            intervalDays: 0,\n            nextReview: new Date().toISOString(),\n            reviewCount: 0,\n            lapseCount: 0\n          }\n          \n          set(state => {\n            const deckCards = state.cards[deckId] || []\n            const updatedCards = [...deckCards, card]\n            \n            return {\n              cards: { ...state.cards, [deckId]: updatedCards },\n              decks: state.decks.map(deck => \n                deck.id === deckId \n                  ? { ...deck, cardCount: updatedCards.length, updatedAt: new Date().toISOString() }\n                  : deck\n              ),\n              isLoading: false\n            }\n          })\n          \n          return card\n        } catch (error) {\n          set({ error: 'Failed to add card', isLoading: false })\n          throw error\n        }\n      },\n\n      addCardBulk: async (deckId, cardData) => {\n        try {\n          const state = get()\n          const existingCards = state.cards[deckId] || []\n          \n          // Check if this card already exists\n          const cardKey = `${cardData.frontContent.trim().toLowerCase()}|${cardData.backContent.trim().toLowerCase()}`\n          const isDuplicate = existingCards.some(card =>\n            `${card.frontContent.trim().toLowerCase()}|${card.backContent.trim().toLowerCase()}` === cardKey\n          )\n          \n          if (isDuplicate) {\n            console.log('Skipping duplicate card:', cardData.frontContent)\n            // Return a dummy card to maintain the interface, but don't add it\n            return {\n              ...cardData,\n              id: 'duplicate-skipped',\n              deckId,\n              createdAt: new Date().toISOString(),\n              easeFactor: 2.5,\n              intervalDays: 0,\n              nextReview: new Date().toISOString(),\n              reviewCount: 0,\n              lapseCount: 0\n            }\n          }\n          \n          const card: Card = {\n            ...cardData,\n            id: crypto.randomUUID(),\n            deckId,\n            createdAt: new Date().toISOString(),\n            easeFactor: 2.5,\n            intervalDays: 0,\n            nextReview: new Date().toISOString(),\n            reviewCount: 0,\n            lapseCount: 0\n          }\n          \n          set(state => {\n            const deckCards = state.cards[deckId] || []\n            const updatedCards = [...deckCards, card]\n            \n            return {\n              cards: { ...state.cards, [deckId]: updatedCards },\n              decks: state.decks.map(deck =>\n                deck.id === deckId\n                  ? { ...deck, cardCount: updatedCards.length, updatedAt: new Date().toISOString() }\n                  : deck\n              )\n            }\n          })\n          \n          return card\n        } catch (error) {\n          console.error('Failed to add card during bulk import:', error)\n          throw error\n        }\n      },\n\n      createDeckBulk: async (deckData) => {\n        try {\n          const deck: Deck = {\n            ...deckData,\n            id: crypto.randomUUID(),\n            createdAt: new Date().toISOString(),\n            updatedAt: new Date().toISOString(),\n            settings: { ...defaultDeckSettings, ...deckData.settings }\n          }\n          \n          set(state => ({\n            decks: [...state.decks, deck],\n            cards: { ...state.cards, [deck.id]: [] }\n          }))\n          \n          return deck\n        } catch (error) {\n          console.error('Failed to create deck during bulk import:', error)\n          throw error\n        }\n      },\n\n      addCardsBatch: async (deckId, cardsData) => {\n        try {\n          const state = get()\n          const existingCards = state.cards[deckId] || []\n          \n          // Create a Set of existing card content for fast lookup\n          const existingCardSet = new Set(\n            existingCards.map(card => `${card.frontContent.trim().toLowerCase()}|${card.backContent.trim().toLowerCase()}`)\n          )\n          \n          // Filter out duplicates and create new cards\n          const uniqueCardsData = cardsData.filter(cardData => {\n            const cardKey = `${cardData.frontContent.trim().toLowerCase()}|${cardData.backContent.trim().toLowerCase()}`\n            return !existingCardSet.has(cardKey)\n          })\n          \n          console.log(`Batch processing: ${cardsData.length} cards submitted, ${uniqueCardsData.length} unique cards to add`)\n          \n          if (uniqueCardsData.length === 0) {\n            console.log('No new unique cards to add in this batch')\n            return []\n          }\n          \n          const cards: Card[] = uniqueCardsData.map(cardData => ({\n            ...cardData,\n            id: crypto.randomUUID(),\n            deckId,\n            createdAt: new Date().toISOString(),\n            easeFactor: 2.5,\n            intervalDays: 0,\n            nextReview: new Date().toISOString(),\n            reviewCount: 0,\n            lapseCount: 0\n          }))\n          \n          set(state => {\n            const deckCards = state.cards[deckId] || []\n            const updatedCards = [...deckCards, ...cards]\n            \n            return {\n              cards: { ...state.cards, [deckId]: updatedCards },\n              decks: state.decks.map(deck =>\n                deck.id === deckId\n                  ? { ...deck, cardCount: updatedCards.length, updatedAt: new Date().toISOString() }\n                  : deck\n              )\n            }\n          })\n          \n          return cards\n        } catch (error) {\n          console.error('Failed to add cards during batch import:', error)\n          throw error\n        }\n      },\n\n      updateCard: async (cardId, updates) => {\n        set({ isLoading: true, error: null })\n        try {\n          set(state => {\n            const newCards = { ...state.cards }\n            for (const deckId in newCards) {\n              newCards[deckId] = newCards[deckId].map(card =>\n                card.id === cardId ? { ...card, ...updates } : card\n              )\n            }\n            return { cards: newCards, isLoading: false }\n          })\n        } catch (error) {\n          set({ error: 'Failed to update card', isLoading: false })\n          throw error\n        }\n      },\n\n      deleteCard: async (cardId) => {\n        set({ isLoading: true, error: null })\n        try {\n          set(state => {\n            const newCards = { ...state.cards }\n            let targetDeckId = ''\n            \n            for (const deckId in newCards) {\n              const cardIndex = newCards[deckId].findIndex(card => card.id === cardId)\n              if (cardIndex !== -1) {\n                newCards[deckId] = newCards[deckId].filter(card => card.id !== cardId)\n                targetDeckId = deckId\n                break\n              }\n            }\n            \n            return {\n              cards: newCards,\n              decks: state.decks.map(deck => \n                deck.id === targetDeckId \n                  ? { ...deck, cardCount: newCards[targetDeckId].length, updatedAt: new Date().toISOString() }\n                  : deck\n              ),\n              isLoading: false\n            }\n          })\n        } catch (error) {\n          set({ error: 'Failed to delete card', isLoading: false })\n          throw error\n        }\n      },\n\n      getCards: (deckId) => {\n        return get().cards[deckId] || []\n      },\n\n      importAnkiDeck: async (file) => {\n        const { setImportProgress, resetImportProgress } = get()\n        set({ isLoading: true, error: null })\n        resetImportProgress()\n        \n        try {\n          const fileName = file.name.toLowerCase()\n          \n          // Handle different file types\n          if (fileName.endsWith('.apkg')) {\n            setImportProgress(10, 'Reading file...')\n            \n            // Parse .apkg file using the new parser\n            const { name, cards } = await parseApkgFile(file)\n\n            // Check if deck with the same name already exists\n            const existingDeck = get().decks.find(d => d.title === name);\n            if (existingDeck) {\n              throw new Error(`A deck named \"${name}\" already exists. Please rename the deck or the file before importing.`);\n            }\n            \n            setImportProgress(30, 'Creating deck...')\n            \n            // Create deck\n            const deck = await get().createDeckBulk({\n              userId: 'current-user',\n              title: name,\n              description: `Imported Anki deck with ${cards.length} cards`,\n              cardCount: 0,\n              isPublic: false,\n              settings: defaultDeckSettings,\n              category: 'imported'\n            })\n            \n            setImportProgress(40, `Importing ${cards.length} cards...`)\n            \n            // Remove duplicates from cards before batch processing\n            const uniqueCards: typeof cards = []\n            const seenCards = new Set<string>()\n            \n            for (const card of cards) {\n              const cardKey = `${card.front.trim().toLowerCase()}|${card.back.trim().toLowerCase()}`\n              if (!seenCards.has(cardKey)) {\n                seenCards.add(cardKey)\n                uniqueCards.push(card)\n              }\n            }\n            \n            console.log(`Removed ${cards.length - uniqueCards.length} duplicates from Anki cards. Processing ${uniqueCards.length} unique cards.`)\n            \n            // Process unique cards in smaller batches for better performance and reliability\n            const batchSize = 100\n            let successfulImports = 0\n            const totalCards = uniqueCards.length\n            \n            console.log(`Starting batch import of ${totalCards} unique cards`)\n            \n            for (let i = 0; i < totalCards; i += batchSize) {\n              const batch = uniqueCards.slice(i, i + batchSize)\n              const batchCards = batch.map(cardData => createNewCard(\n                cardData.front,\n                cardData.back,\n                { type: 'basic' as const },\n                []\n              ))\n              \n              try {\n                console.log(`Processing batch ${Math.floor(i / batchSize) + 1}/${Math.ceil(totalCards / batchSize)} (${batch.length} cards)`)\n                await get().addCardsBatch(deck.id, batchCards)\n                successfulImports += batch.length\n                \n                // Update progress (40% to 90% for card import)\n                const cardProgress = 40 + (50 * Math.min(i + batchSize, totalCards) / totalCards)\n                setImportProgress(cardProgress, `Imported ${successfulImports}/${totalCards} cards...`)\n                \n                console.log(`Batch completed. Progress: ${cardProgress.toFixed(1)}%`)\n                \n                // Add small delay to allow UI updates\n                await new Promise(resolve => setTimeout(resolve, 50))\n              } catch (cardError) {\n                console.error('Failed to import batch:', cardError)\n                // Try individual cards in this batch as fallback\n                for (const originalCard of batch) {\n                  try {\n                    await get().addCardBulk(deck.id, createNewCard(\n                      originalCard.front,\n                      originalCard.back,\n                      { type: 'basic' as const },\n                      []\n                    ))\n                    successfulImports++\n                  } catch (individualError) {\n                    console.warn('Failed to import individual card:', originalCard, individualError)\n                  }\n                }\n                \n                // Update progress even after fallback\n                const cardProgress = 40 + (50 * Math.min(i + batchSize, totalCards) / totalCards)\n                setImportProgress(cardProgress, `Imported ${successfulImports}/${totalCards} cards...`)\n              }\n            }\n            \n            console.log(`Batch import completed. Total successful: ${successfulImports}`)\n            \n            setImportProgress(95, 'Finalizing import...')\n            \n            // Update deck description with final count\n            await get().updateDeck(deck.id, {\n              description: `Imported Anki deck with ${successfulImports} cards`\n            })\n            \n            setImportProgress(100, 'Import completed!')\n            \n            // Clear progress after a short delay\n            setTimeout(() => {\n              resetImportProgress()\n            }, 1000)\n            \n            set({ isLoading: false })\n            return deck\n          } else if (fileName.endsWith('.txt') || fileName.endsWith('.tsv') || fileName.endsWith('.csv')) {\n            setImportProgress(10, 'Reading text file...')\n            \n            // Handle text-based imports\n            const text = await file.text()\n            \n            // Detect separator\n            let separator = '\\t' // Corrected: \t is a tab character\n            if (fileName.endsWith('.csv')) {\n              separator = ','\n            }\n            \n            setImportProgress(20, 'Processing text content...')\n            \n            // Clean the text and handle encoding issues\n            const cleanText = text\n              .replace(/\\r\\n/g, '\\n')  // Normalize line endings\n              .replace(/\\r/g, '\\n')    // Handle old Mac line endings\n              .trim()\n            \n            const deck = await get().importFromText(\n              file.name.replace(/\\.[^/.]+$/, \"\"),\n              cleanText,\n              separator\n            )\n            set({ isLoading: false })\n            return deck\n          } else {\n            setImportProgress(10, 'Reading file as text...')\n            \n            // Try to parse as text anyway\n            const text = await file.text()\n            \n            setImportProgress(20, 'Processing content...')\n            \n            const cleanText = text\n              .replace(/\\r\\n/g, '\\n')\n              .replace(/\\r/g, '\\n')\n              .trim()\n            \n            const deck = await get().importFromText(\n              file.name.replace(/\\.[^/.]+$/, \"\"),\n              cleanText,\n              '\\t'\n            )\n            set({ isLoading: false })\n            return deck\n          }\n        } catch (error) {\n          const errorMessage = error instanceof Error ? error.message : 'Failed to import Anki deck'\n          set({ error: errorMessage, isLoading: false })\n          resetImportProgress()\n          throw error\n        }\n      },\n\n      importFromText: async (deckName, text, separator = '\\t') => {\n        const { setImportProgress, resetImportProgress } = get()\n        set({ isLoading: true, error: null })\n        \n        try {\n          setImportProgress(30, 'Processing text content...')\n          \n          // Clean and normalize the text\n          const cleanText = text\n            .replace(/\\r\\n/g, '\\n')  // Normalize Windows line endings\n            .replace(/\\r/g, '\\n')    // Handle old Mac line endings\n            .replace(/\\\\u0000/g, '')  // Remove null characters\n            .replace(/[\\\\u0001-\\\\u0008\\\\u000B\\\\u000C\\\\u000E-\\\\u001F\\\\u007F]/g, '') // Remove control characters\n            .trim()\n          \n          const lines = cleanText\n            .split('\\n')\n            .map(line => line.trim())\n            .filter(line => line.length > 0)\n          \n          if (lines.length === 0) {\n            throw new Error('No valid content found in the file')\n          }\n          \n          setImportProgress(40, 'Creating deck...')\n          \n          const deck = await get().createDeckBulk({\n            userId: 'current-user', // This would come from auth store\n            title: deckName,\n            description: `Imported deck with ${lines.length} cards`,\n            cardCount: 0,\n            isPublic: false,\n            settings: defaultDeckSettings,\n            category: 'imported'\n          })\n          \n          setImportProgress(50, `Importing ${lines.length} cards...`)\n          \n          // Process lines and prepare cards for batch import\n          const validCards: Array<Omit<Card, 'id' | 'createdAt' | 'deckId' | 'easeFactor' | 'intervalDays' | 'nextReview' | 'reviewCount' | 'lapseCount'>> = []\n          let skippedLines = 0\n          \n          // First pass: parse and validate all lines\n          for (let i = 0; i < lines.length; i++) {\n            const line = lines[i]\n            try {\n              // Handle quoted fields (CSV style)\n              let parts: string[]\n              if (separator === ',' && line.includes('\"')) {\n                // Simple CSV parsing for quoted fields\n                parts = line.split(',').map(part =>\n                  part.replace(/^\"(.*)\"$/, '$1').trim()\n                )\n              } else {\n                parts = line.split(separator)\n              }\n              \n              if (parts.length >= 2) {\n                const front = parts[0].trim()\n                const back = parts[1].trim()\n                \n                // Skip empty cards\n                if (front && back) {\n                  validCards.push(createNewCard(\n                    front,\n                    back,\n                    { type: 'basic' as const },\n                    []\n                  ))\n                } else {\n                  skippedLines++\n                }\n              } else {\n                skippedLines++\n              }\n            } catch (cardError) {\n              console.warn('Failed to parse line:', line, cardError)\n              skippedLines++\n            }\n          }\n          \n          // Remove duplicates from validCards before batch processing\n          const uniqueValidCards: typeof validCards = []\n          const seenCards = new Set<string>()\n          \n          for (const card of validCards) {\n            const cardKey = `${card.frontContent.trim().toLowerCase()}|${card.backContent.trim().toLowerCase()}`\n            if (!seenCards.has(cardKey)) {\n              seenCards.add(cardKey)\n              uniqueValidCards.push(card)\n            }\n          }\n          \n          console.log(`Removed ${validCards.length - uniqueValidCards.length} duplicates from parsed cards. Processing ${uniqueValidCards.length} unique cards.`)\n          \n          // Second pass: batch import unique cards\n          const batchSize = 100\n          let successfulImports = 0\n          \n          console.log(`Starting text import batch processing of ${uniqueValidCards.length} unique cards`)\n          \n          for (let i = 0; i < uniqueValidCards.length; i += batchSize) {\n            const batch = uniqueValidCards.slice(i, i + batchSize)\n            \n            try {\n              console.log(`Processing text batch ${Math.floor(i / batchSize) + 1}/${Math.ceil(uniqueValidCards.length / batchSize)} (${batch.length} cards)`)\n              const addedCards = await get().addCardsBatch(deck.id, batch)\n              successfulImports += addedCards.length\n              \n              // Update progress (50% to 90% for card import)\n              const cardProgress = 50 + (40 * Math.min(i + batchSize, uniqueValidCards.length) / uniqueValidCards.length)\n              setImportProgress(cardProgress, `Imported ${successfulImports}/${uniqueValidCards.length} cards...`)\n              \n              console.log(`Text batch completed. Progress: ${cardProgress.toFixed(1)}%, Added: ${addedCards.length} cards`)\n              \n              // Add small delay to allow UI updates\n              await new Promise(resolve => setTimeout(resolve, 50))\n            } catch (cardError) {\n              console.error('Failed to import text batch:', cardError)\n              // Try individual cards in this batch as fallback\n              for (const cardData of batch) {\n                try {\n                  const addedCard = await get().addCardBulk(deck.id, cardData)\n                  if (addedCard.id !== 'duplicate-skipped') {\n                    successfulImports++\n                  }\n                } catch (individualError) {\n                  console.warn('Failed to import individual text card:', cardData, individualError)\n                }\n              }\n              \n              // Update progress even after fallback\n              const cardProgress = 50 + (40 * Math.min(i + batchSize, uniqueValidCards.length) / uniqueValidCards.length)\n              setImportProgress(cardProgress, `Imported ${successfulImports}/${uniqueValidCards.length} cards...`)\n            }\n          }\n          \n          console.log(`Text import batch processing completed. Total successful: ${successfulImports}`)\n          \n          setImportProgress(95, 'Finalizing import...')\n          \n          // Update deck description with import results\n          await get().updateDeck(deck.id, {\n            description: `Imported deck with ${successfulImports} cards${skippedLines > 0 ? ` (${skippedLines} lines skipped)` : ''}`\n          })\n          \n          if (successfulImports === 0) {\n            throw new Error('No valid cards could be imported. Please check the file format.')\n          }\n          \n          setImportProgress(100, 'Import completed!')\n          \n          // Clear progress after a short delay\n          setTimeout(() => {\n            resetImportProgress()\n          }, 1000)\n          \n          set({ isLoading: false })\n          return deck\n        } catch (error) {\n          set({ error: 'Failed to import from text', isLoading: false })\n          resetImportProgress()\n          throw error\n        }\n      },\n\n      loadExampleDecks: async () => {\n        set({ isLoading: true, error: null })\n        try {\n          const state = get()\n          \n          // Check if example decks already exist to prevent duplicates\n          const existingTitles = new Set(state.decks.map(deck => deck.title))\n          const exampleTitles = ['Spanish Vocabulary', 'JavaScript Concepts', 'World Capitals']\n          \n          // If any example deck already exists, don't load any\n          if (exampleTitles.some(title => existingTitles.has(title))) {\n            console.log('Example decks already exist, skipping load')\n            set({ isLoading: false })\n            return\n          }\n\n          const exampleDecks = [\n            {\n              title: 'Spanish Vocabulary',\n              description: 'Essential Spanish words for beginners',\n              category: 'language',\n              cards: [\n                { front: 'Hello', back: 'Hola' },\n                { front: 'Goodbye', back: 'Adis' },\n                { front: 'Thank you', back: 'Gracias' },\n                { front: 'Please', back: 'Por favor' },\n                { front: 'Yes', back: 'S' },\n                { front: 'No', back: 'No' },\n                { front: 'Water', back: 'Agua' },\n                { front: 'Food', back: 'Comida' },\n                { front: 'House', back: 'Casa' },\n                { front: 'Car', back: 'Coche' }\n              ]\n            },\n            {\n              title: 'JavaScript Concepts',\n              description: 'Important JavaScript programming concepts',\n              category: 'programming',\n              cards: [\n                { front: 'What is a closure?', back: 'A closure is a function that has access to variables in its outer (enclosing) scope even after the outer function has returned.' },\n                { front: 'What is hoisting?', back: 'Hoisting is JavaScript\\'s default behavior of moving declarations to the top of their scope.' },\n                { front: 'What is the difference between let and var?', back: 'let has block scope and cannot be redeclared, while var has function scope and can be redeclared.' },\n                { front: 'What is a Promise?', back: 'A Promise is an object representing the eventual completion or failure of an asynchronous operation.' },\n                { front: 'What is async/await?', back: 'async/await is syntactic sugar for working with Promises, making asynchronous code look more like synchronous code.' }\n              ]\n            },\n            {\n              title: 'World Capitals',\n              description: 'Capital cities of countries around the world',\n              category: 'geography',\n              cards: [\n                { front: 'France', back: 'Paris' },\n                { front: 'Germany', back: 'Berlin' },\n                { front: 'Italy', back: 'Rome' },\n                { front: 'Spain', back: 'Madrid' },\n                { front: 'United Kingdom', back: 'London' },\n                { front: 'Japan', back: 'Tokyo' },\n                { front: 'China', back: 'Beijing' },\n                { front: 'Australia', back: 'Canberra' },\n                { front: 'Brazil', back: 'Braslia' },\n                { front: 'Canada', back: 'Ottawa' }\n              ]\n            }\n          ]\n\n          console.log('Loading example decks...')\n          for (const deckData of exampleDecks) {\n            const deck = await get().createDeck({\n              userId: 'current-user',\n              title: deckData.title,\n              description: deckData.description,\n              cardCount: 0,\n              isPublic: false,\n              settings: defaultDeckSettings,\n              category: deckData.category,\n              tags: [deckData.category]\n            })\n\n            for (const cardData of deckData.cards) {\n              await get().addCard(deck.id, createNewCard(\n                cardData.front,\n                cardData.back,\n                { type: 'basic' },\n                []\n              ))\n            }\n          }\n\n          console.log('Example decks loaded successfully')\n          set({ isLoading: false })\n        } catch (error) {\n          set({ error: 'Failed to load example decks', isLoading: false })\n          throw error\n        }\n      },\n\n      clearError: () => set({ error: null }),\n      setLoading: (loading) => set({ isLoading: loading }),\n      removeDuplicateCards: async (deckId) => {\n        try {\n          const state = get()\n          const deckCards = state.cards[deckId] || []\n          \n          if (deckCards.length === 0) {\n            return 0\n          }\n          \n          // Create a Map to track unique cards (first occurrence wins)\n          const uniqueCardsMap = new Map<string, Card>()\n          let duplicatesRemoved = 0\n          \n          for (const card of deckCards) {\n            const cardKey = `${card.frontContent.trim().toLowerCase()}|${card.backContent.trim().toLowerCase()}`\n            \n            if (!uniqueCardsMap.has(cardKey)) {\n              uniqueCardsMap.set(cardKey, card)\n            } else {\n              duplicatesRemoved++\n              console.log(`Removing duplicate card: ${card.frontContent}`)\n            }\n          }\n          \n          const uniqueCards = Array.from(uniqueCardsMap.values())\n          \n          if (duplicatesRemoved > 0) {\n            set(state => ({\n              cards: { ...state.cards, [deckId]: uniqueCards },\n              decks: state.decks.map(deck =>\n                deck.id === deckId\n                  ? { ...deck, cardCount: uniqueCards.length, updatedAt: new Date().toISOString() }\n                  : deck\n              )\n            }))\n            \n            console.log(`Removed ${duplicatesRemoved} duplicate cards from deck. ${uniqueCards.length} unique cards remaining.`)\n          }\n          \n          return duplicatesRemoved\n        } catch (error) {\n          console.error('Failed to remove duplicate cards:', error)\n          throw error\n        }\n      },\n\n      setImportProgress: (progress, status) => set({ importProgress: progress, importStatus: status }),\n      resetImportProgress: () => set({ importProgress: 0, importStatus: null }),\n\n      // Study session functions\n            startStudySession: (deckId, studyCards) => {\n        const studyCardIds = studyCards.map(c => c.id);\n        set({\n          currentStudySession: {\n            deckId,\n            currentCardIndex: 0,\n            studyCards, // Keep full cards for in-memory access\n            studyCardIds, // Add the IDs for persistence\n            sessionStats: {\n              total: studyCards.length,\n              correct: 0,\n              incorrect: 0\n            },\n            startedAt: new Date().toISOString()\n          }\n        })\n      },\n\n      updateStudySession: (currentCardIndex, sessionStats) => {\n        set(state => ({\n          currentStudySession: state.currentStudySession ? {\n            ...state.currentStudySession,\n            currentCardIndex,\n            sessionStats\n          } : null\n        }))\n      },\n\n      clearStudySession: () => {\n        set({ currentStudySession: null })\n      },\n\n      getStudySession: (deckId) => {\n        const state = get()\n        return state.currentStudySession?.deckId === deckId ? state.currentStudySession : null\n      },\n\n      resetAllStudyData: () => {\n        // Reset all study-related data but keep decks and cards\n        set(state => {\n          // Reset all card progress data\n          const resetCards: Record<string, Card[]> = {}\n          \n          for (const [deckId, cards] of Object.entries(state.cards)) {\n            resetCards[deckId] = cards.map(card => ({\n              ...card,\n              easeFactor: 2.5,\n              intervalDays: 0,\n              nextReview: new Date().toISOString(),\n              reviewCount: 0,\n              lapseCount: 0\n            }))\n          }\n          \n          return {\n            cards: resetCards,\n            currentStudySession: null\n          }\n        })\n      }\n    }),\n    {\n      name: 'deck-storage',\n      // This function selects which parts of the state to save\n      partialize: (state) => {\n        // 1. Exclude the top-level 'cards' object entirely.\n        // 2. From the 'currentStudySession', exclude the 'studyCards' array of full objects.\n        const { cards, currentStudySession, ...restOfState } = state;\n\n        const sessionToPersist = currentStudySession\n          ? {\n              deckId: currentStudySession.deckId,\n              currentCardIndex: currentStudySession.currentCardIndex,\n              studyCardIds: currentStudySession.studyCardIds, // Only persist the IDs\n              sessionStats: currentStudySession.sessionStats,\n              startedAt: currentStudySession.startedAt,\n            }\n          : null;\n\n        // Return a new object containing only the data we want to persist.\n        // Note: `decks` are preserved via `restOfState`.\n        return { ...restOfState, currentStudySession: sessionToPersist };\n      },\n    }\n  )\n)\n\nexport const useCurrentCard = (): Card | null => {\n  const store = useDeckStore();\n  const session = store.currentStudySession;\n\n  if (!session || !session.studyCardIds || session.studyCardIds.length === 0) {\n    return null;\n  }\n\n  const currentCardId = session.studyCardIds[session.currentCardIndex];\n  if (!currentCardId) {\n    return null;\n  }\n\n  // The full, non-persisted `cards` object holds all cards for the current deck.\n  const deckCards = store.cards[session.deckId] || [];\n  return deckCards.find(card => card.id === currentCardId) || null;\n};"],"file":"assets/stores-Chljb6Mx.js"}