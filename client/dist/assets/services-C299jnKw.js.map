{"version":3,"file":"services-C299jnKw.js","sources":["../../src/services/errorTrackingService.tsx","../../src/data/db.ts","../../src/services/userDataService.ts","../../src/services/realTimeDataService.ts","../../src/services/uamsApiService.ts","../../src/services/unifiedQueueManager.ts","../../src/services/environmental/environmentalContextService.ts","../../src/services/storage/StorageManager.ts"],"sourcesContent":["// Basic error tracking service for StudyMaster PWA\r\n\r\nimport React from 'react'\r\n\r\nexport interface ErrorReport {\r\n  id: string\r\n  timestamp: string\r\n  level: 'error' | 'warning' | 'info'\r\n  message: string\r\n  stack?: string\r\n  userAgent?: string\r\n  url?: string\r\n  userId?: string\r\n  sessionId?: string\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  context?: Record<string, any>\r\n}\r\n\r\nexport interface ErrorTrackingConfig {\r\n  maxStoredErrors: number\r\n  enableConsoleLogging: boolean\r\n  enableLocalStorage: boolean\r\n  apiEndpoint?: string\r\n  apiKey?: string\r\n  environment: 'development' | 'production' | 'staging'\r\n}\r\n\r\nclass ErrorTrackingService {\r\n  private config: ErrorTrackingConfig\r\n  private errors: ErrorReport[] = []\r\n  private sessionId: string\r\n  private initialized = false\r\n\r\n  constructor(config: Partial<ErrorTrackingConfig> = {}) {\r\n    this.config = {\r\n      maxStoredErrors: 100,\r\n      enableConsoleLogging: true,\r\n      enableLocalStorage: true,\r\n      environment: import.meta.env.MODE === 'production' ? 'production' : 'development',\r\n      ...config\r\n    }\r\n    \r\n    this.sessionId = this.generateSessionId()\r\n    this.loadStoredErrors()\r\n    this.setupGlobalErrorHandlers()\r\n    this.initialized = true\r\n    \r\n    this.logInfo('Error tracking initialized', { sessionId: this.sessionId })\r\n  }\r\n\r\n  /**\r\n   * Log an error\r\n   */\r\n  logError(error: Error | string, context?: Record<string, unknown>): void {\r\n    const errorReport = this.createErrorReport('error', error, context)\r\n    this.recordError(errorReport)\r\n  }\r\n\r\n  /**\r\n   * Log a warning\r\n   */\r\n  logWarning(message: string, context?: Record<string, unknown>): void {\r\n    const errorReport = this.createErrorReport('warning', message, context)\r\n    this.recordError(errorReport)\r\n  }\r\n\r\n  /**\r\n   * Log an info message\r\n   */\r\n  logInfo(message: string, context?: Record<string, unknown>): void {\r\n    const errorReport = this.createErrorReport('info', message, context)\r\n    this.recordError(errorReport)\r\n  }\r\n\r\n  /**\r\n   * Get all stored errors\r\n   */\r\n  getErrors(): ErrorReport[] {\r\n    return [...this.errors]\r\n  }\r\n\r\n  /**\r\n   * Clear all stored errors\r\n   */\r\n  clearErrors(): void {\r\n    this.errors = []\r\n    if (this.config.enableLocalStorage) {\r\n      localStorage.removeItem('studymaster_errors')\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get error statistics\r\n   */\r\n  getErrorStats(): {\r\n    total: number\r\n    byLevel: Record<string, number>\r\n    recent: number // Errors in last hour\r\n  } {\r\n    const now = Date.now()\r\n    const oneHourAgo = now - (60 * 60 * 1000)\r\n    \r\n    const stats = {\r\n      total: this.errors.length,\r\n      byLevel: { error: 0, warning: 0, info: 0 },\r\n      recent: 0\r\n    }\r\n\r\n    this.errors.forEach(error => {\r\n      stats.byLevel[error.level]++\r\n      if (new Date(error.timestamp).getTime() > oneHourAgo) {\r\n        stats.recent++\r\n      }\r\n    })\r\n\r\n    return stats\r\n  }\r\n\r\n  /**\r\n   * Export errors for debugging\r\n   */\r\n  exportErrors(): string {\r\n    return JSON.stringify(this.errors, null, 2)\r\n  }\r\n\r\n  private createErrorReport(\r\n    level: ErrorReport['level'],\r\n    error: Error | string,\r\n    context?: Record<string, unknown>\r\n  ): ErrorReport {\r\n    const message = error instanceof Error ? error.message : error\r\n    const stack = error instanceof Error ? error.stack : undefined\r\n    \r\n    return {\r\n      id: this.generateErrorId(),\r\n      timestamp: new Date().toISOString(),\r\n      level,\r\n      message,\r\n      stack,\r\n      userAgent: navigator.userAgent,\r\n      url: window.location.href,\r\n      sessionId: this.sessionId,\r\n      context: context || {}\r\n    }\r\n  }\r\n\r\n  private recordError(error: ErrorReport): void {\r\n    // Add to in-memory storage\r\n    this.errors.unshift(error)\r\n    \r\n    // Limit stored errors\r\n    if (this.errors.length > this.config.maxStoredErrors) {\r\n      this.errors = this.errors.slice(0, this.config.maxStoredErrors)\r\n    }\r\n\r\n    // Console logging\r\n    if (this.config.enableConsoleLogging) {\r\n      const logMethod = error.level === 'error' ? console.error : \r\n                       error.level === 'warning' ? console.warn : console.log\r\n      logMethod(`[ErrorTracker] ${error.message}`, error)\r\n    }\r\n\r\n    // Local storage persistence\r\n    if (this.config.enableLocalStorage) {\r\n      try {\r\n        localStorage.setItem('studymaster_errors', JSON.stringify(this.errors.slice(0, 50)))\r\n      } catch (e) {\r\n        // Storage quota exceeded, clear old errors\r\n        this.errors = this.errors.slice(0, 25)\r\n        try {\r\n          localStorage.setItem('studymaster_errors', JSON.stringify(this.errors))\r\n        } catch (e) {\r\n          // If still failing, disable local storage\r\n          console.warn('Error tracking: Local storage disabled due to quota issues')\r\n        }\r\n      }\r\n    }\r\n\r\n    // Send to remote endpoint if configured\r\n    if (this.config.apiEndpoint && this.config.environment === 'production') {\r\n      this.sendToRemote(error).catch(e => {\r\n        console.warn('Failed to send error to remote endpoint:', e)\r\n      })\r\n    }\r\n  }\r\n\r\n  private loadStoredErrors(): void {\r\n    if (!this.config.enableLocalStorage) return\r\n\r\n    try {\r\n      const stored = localStorage.getItem('studymaster_errors')\r\n      if (stored) {\r\n        const parsedErrors = JSON.parse(stored)\r\n        if (Array.isArray(parsedErrors)) {\r\n          this.errors = parsedErrors\r\n        }\r\n      }\r\n    } catch (e) {\r\n      console.warn('Failed to load stored errors:', e)\r\n    }\r\n  }\r\n\r\n  private setupGlobalErrorHandlers(): void {\r\n    // Unhandled JavaScript errors\r\n    window.addEventListener('error', (event) => {\r\n      this.logError(event.error || new Error(event.message), {\r\n        filename: event.filename,\r\n        lineno: event.lineno,\r\n        colno: event.colno,\r\n        type: 'unhandled_error'\r\n      })\r\n    })\r\n\r\n    // Unhandled promise rejections\r\n    window.addEventListener('unhandledrejection', (event) => {\r\n      this.logError(new Error(`Unhandled promise rejection: ${event.reason}`), {\r\n        type: 'unhandled_promise_rejection',\r\n        reason: event.reason\r\n      })\r\n    })\r\n\r\n    // React error boundary integration\r\n    if (window.React) {\r\n      const originalErrorHandler = window.console.error\r\n      window.console.error = (...args) => {\r\n        const message = args[0]\r\n        if (typeof message === 'string' && message.includes('React')) {\r\n          this.logError(new Error(message), {\r\n            type: 'react_error',\r\n            args: args\r\n          })\r\n        }\r\n        originalErrorHandler.apply(console, args)\r\n      }\r\n    }\r\n  }\r\n\r\n  private async sendToRemote(error: ErrorReport): Promise<void> {\r\n    if (!this.config.apiEndpoint) return\r\n\r\n    try {\r\n      await fetch(this.config.apiEndpoint, {\r\n        method: 'POST',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n          ...(this.config.apiKey ? { 'Authorization': `Bearer ${this.config.apiKey}` } : {})\r\n        },\r\n        body: JSON.stringify({\r\n          ...error,\r\n          environment: this.config.environment,\r\n          userAgent: navigator.userAgent,\r\n          timestamp: new Date().toISOString()\r\n        })\r\n      })\r\n    } catch (e) {\r\n      // Silently fail for remote logging\r\n      console.warn('Failed to send error to remote endpoint:', e)\r\n    }\r\n  }\r\n\r\n  private generateSessionId(): string {\r\n    return `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`\r\n  }\r\n\r\n  private generateErrorId(): string {\r\n    return `error_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`\r\n  }\r\n}\r\n\r\n// Singleton instance\r\nexport const errorTracker = new ErrorTrackingService({\r\n  environment: import.meta.env.MODE === 'production' ? 'production' : 'development',\r\n  maxStoredErrors: 100,\r\n  enableConsoleLogging: import.meta.env.DEV,\r\n  enableLocalStorage: true\r\n})\r\n\r\n// Convenience functions\r\nexport const logError = (error: Error | string, context?: Record<string, unknown>) => \r\n  errorTracker.logError(error, context)\r\n\r\nexport const logWarning = (message: string, context?: Record<string, unknown>) => \r\n  errorTracker.logWarning(message, context)\r\n\r\nexport const logInfo = (message: string, context?: Record<string, unknown>) => \r\n  errorTracker.logInfo(message, context)\r\n\r\n// React Error Boundary component\r\nexport class ErrorBoundary extends React.Component<\r\n  { children: React.ReactNode; fallback?: React.ComponentType<{ error: Error }> },\r\n  { hasError: boolean; error?: Error }\r\n> {\r\n  constructor(props: any) {\r\n    super(props)\r\n    this.state = { hasError: false }\r\n  }\r\n\r\n  static getDerivedStateFromError(error: Error) {\r\n    return { hasError: true, error }\r\n  }\r\n\r\n  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {\r\n    logError(error, {\r\n      type: 'react_error_boundary',\r\n      componentStack: errorInfo.componentStack,\r\n      errorBoundary: true\r\n    })\r\n  }\r\n\r\n  render() {\r\n    if (this.state.hasError) {\r\n      const FallbackComponent = this.props.fallback || DefaultErrorFallback\r\n      return <FallbackComponent error={this.state.error!} />\r\n    }\r\n\r\n    return this.props.children\r\n  }\r\n}\r\n\r\n// Default error fallback component\r\nexport const DefaultErrorFallback: React.FC<{ error: Error }> = ({ error }) => (\r\n  <div className=\"min-h-screen flex items-center justify-center bg-gray-50 dark:bg-gray-900\">\r\n    <div className=\"max-w-md mx-auto text-center p-6\">\r\n      <div className=\"mb-4\">\r\n        <svg className=\"mx-auto h-12 w-12 text-red-500\" fill=\"none\" viewBox=\"0 0 24 24\" stroke=\"currentColor\">\r\n          <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.732-.833-2.502 0L4.732 15.5c-.77.833.192 2.5 1.732 2.5z\" />\r\n        </svg>\r\n      </div>\r\n      <h1 className=\"text-xl font-semibold text-gray-900 dark:text-white mb-2\">\r\n        Something went wrong\r\n      </h1>\r\n      <p className=\"text-gray-600 dark:text-gray-400 mb-4\">\r\n        {error.message || 'An unexpected error occurred'}\r\n      </p>\r\n      <button\r\n        onClick={() => window.location.reload()}\r\n        className=\"inline-flex items-center px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors\"\r\n      >\r\n        Reload Page\r\n      </button>\r\n    </div>\r\n  </div>\r\n)\r\n\r\nexport default ErrorTrackingService","/**\r\n * StudyMaster Offline-first Database (Dexie + IndexedDB)\r\n *\r\n * Source of truth for all local data and media.\r\n * - Versioned schema with typed tables\r\n * - Safe singleton access helpers\r\n * - Basic lifecycle logging (ready/blocked/versionchange)\r\n *\r\n * NOTE:\r\n * - Repositories should import { ensureDBOpen } before performing operations\r\n * - This file intentionally focuses on schema + DB lifecycle; business logic belongs in repositories\r\n */\r\n\r\nimport Dexie, { Table } from 'dexie';\r\nimport { logError, logWarning, logInfo } from '../services/errorTrackingService';\r\n\r\n/* =========================\r\n * Row Types (initial schema)\r\n * ========================= */\r\n\r\nexport interface SettingRow {\r\n  id: 'settings';\r\n  theme?: 'light' | 'dark' | 'system';\r\n  shortcuts?: Record<string, string>;\r\n  featureFlags?: Record<string, boolean>;\r\n  encryptionEnabled?: boolean;\r\n  createdAt?: number;\r\n  updatedAt?: number;\r\n}\r\n\r\nexport interface UserRow {\r\n  deviceUserId: string; // local, anonymous by default\r\n  displayName?: string;\r\n  avatarUrl?: string;\r\n  anonymizedId?: string; // for optional leaderboard\r\n  publicKeyJwk?: JsonWebKey; // reserved for future encrypted sync\r\n  createdAt: number;\r\n  updatedAt: number;\r\n}\r\n\r\nexport interface DeckRow {\r\n  deckId: string;\r\n  name: string;\r\n  description?: string;\r\n  cardCount?: number;\r\n  mediaCount?: number;\r\n  updatedAt: number;\r\n  createdAt: number;\r\n  // Additional metadata (tags, language, etc.)\r\n  meta?: Record<string, unknown>;\r\n}\r\n\r\nexport interface CardRow {\r\n  cardId: string;\r\n  deckId: string;\r\n  fields: {\r\n    front: string;\r\n    back: string;\r\n    // Any additional fields from imports\r\n    [k: string]: unknown;\r\n  };\r\n  mediaRefs?: string[]; // array of mediaHash keys\r\n  // Scheduling-related fields (FSRS/Anki)\r\n  dueAt?: number | null;\r\n  interval?: number;\r\n  ease?: number;\r\n  lapses?: number;\r\n  state?: 'new' | 'learning' | 'review' | 'relearning';\r\n  updatedAt: number;\r\n  createdAt: number;\r\n}\r\n\r\nexport interface ReviewRow {\r\n  reviewId: string;\r\n  cardId: string;\r\n  rating: 1 | 2 | 3 | 4; // again/hard/good/easy\r\n  interval: number; // next interval in days\r\n  ease: number;\r\n  lapses: number;\r\n  elapsedSeconds?: number;\r\n  reviewedAt: number; // timestamp\r\n}\r\n\r\nexport interface MediaRow {\r\n  mediaHash: string; // SHA-256 or similar content hash\r\n  blob?: Blob; // Stored when not using OPFS\r\n  opfsPointer?: string; // Path or handle reference (stringified), when using OPFS\r\n  mimeType: string;\r\n  byteLength: number;\r\n  validationMeta?: Record<string, unknown>;\r\n  securityFlags?: {\r\n    sanitized: boolean;\r\n    blockedElements?: string[];\r\n  };\r\n  createdAt: number;\r\n  updatedAt: number;\r\n}\r\n\r\nexport interface AchievementRow {\r\n  achievementId: string;\r\n  userId: string; // deviceUserId\r\n  unlockedAt?: number;\r\n  progress?: number; // 0..1 for partial progress if applicable\r\n  meta?: Record<string, unknown>;\r\n}\r\n\r\nexport interface ChallengeRow {\r\n  challengeId: string;\r\n  config?: Record<string, unknown>;\r\n  progress?: Record<string, unknown>;\r\n  createdAt: number;\r\n  updatedAt: number;\r\n}\r\n\r\nexport interface LeaderboardCacheRow {\r\n  scope: string; // e.g., \"monthly:global\" or \"weekly:friends\"\r\n  entries: Array<{\r\n    rank: number;\r\n    name: string;\r\n    anonymizedId: string;\r\n    score: number;\r\n  }>;\r\n  fetchedAt: number;\r\n  ttlMs: number;\r\n}\r\n\r\nexport interface SyncQueueRow {\r\n  queueId: string;\r\n  opType: 'leaderboard:submit' | 'backup:upload' | 'backup:download' | string;\r\n  payload: unknown;\r\n  createdAt: number;\r\n  attemptCount: number;\r\n  lastError?: string;\r\n}\r\n\r\n/* =========================\r\n * Dexie Database Definition\r\n * ========================= */\r\n\r\nexport class StudyMasterDB extends Dexie {\r\n  // Tables (typed)\r\n  settings!: Table<SettingRow, SettingRow['id']>;\r\n  users!: Table<UserRow, UserRow['deviceUserId']>;\r\n  decks!: Table<DeckRow, DeckRow['deckId']>;\r\n  cards!: Table<CardRow, CardRow['cardId']>;\r\n  reviews!: Table<ReviewRow, ReviewRow['reviewId']>;\r\n  media!: Table<MediaRow, MediaRow['mediaHash']>;\r\n  achievements!: Table<AchievementRow, AchievementRow['achievementId']>;\r\n  challenges!: Table<ChallengeRow, ChallengeRow['challengeId']>;\r\n  leaderboardCache!: Table<LeaderboardCacheRow, LeaderboardCacheRow['scope']>;\r\n  syncQueue!: Table<SyncQueueRow, SyncQueueRow['queueId']>;\r\n\r\n  constructor() {\r\n    super('studymaster');\r\n\r\n    // Version 1 schema\r\n    this.version(1).stores({\r\n      // Primary keys and indexes\r\n      settings: 'id',\r\n      users: 'deviceUserId',\r\n      decks: 'deckId, updatedAt',\r\n      cards: 'cardId, deckId, dueAt, updatedAt',\r\n      reviews: 'reviewId, cardId, reviewedAt',\r\n      media: 'mediaHash',\r\n      achievements: 'achievementId, userId',\r\n      challenges: 'challengeId',\r\n      leaderboardCache: 'scope, fetchedAt',\r\n      syncQueue: 'queueId, createdAt',\r\n    });\r\n\r\n    // Table bindings (in Dexie v3 this is automatic; explicit assignment keeps TS happy in some setups)\r\n    this.settings = this.table('settings');\r\n    this.users = this.table('users');\r\n    this.decks = this.table('decks');\r\n    this.cards = this.table('cards');\r\n    this.reviews = this.table('reviews');\r\n    this.media = this.table('media');\r\n    this.achievements = this.table('achievements');\r\n    this.challenges = this.table('challenges');\r\n    this.leaderboardCache = this.table('leaderboardCache');\r\n    this.syncQueue = this.table('syncQueue');\r\n\r\n    // Lifecycle hooks for visibility and troubleshooting\r\n    this.on('populate', async () => {\r\n      // Initial bootstrap: ensure a settings row exists\r\n      try {\r\n        const now = Date.now();\r\n        const existing = await this.settings.get('settings');\r\n        if (!existing) {\r\n          await this.settings.add({\r\n            id: 'settings',\r\n            theme: 'system',\r\n            shortcuts: {},\r\n            featureFlags: {},\r\n            encryptionEnabled: false,\r\n            createdAt: now,\r\n            updatedAt: now,\r\n          });\r\n        }\r\n      } catch (err) {\r\n        logError(err instanceof Error ? err : new Error(String(err)), { scope: 'db.populate' });\r\n      }\r\n    });\r\n\r\n    this.on('ready', () => {\r\n      // Database is ready for use\r\n      // Avoid heavy work here; use repos/services for business logic\r\n      logInfo('DB ready', { scope: 'db.ready' });\r\n    });\r\n\r\n    this.on('blocked', (e) => {\r\n      logWarning('DB blocked - close other tabs or reload to proceed', { event: e, scope: 'db.blocked' });\r\n    });\r\n\r\n    this.on('versionchange', () => {\r\n      logInfo('DB versionchange - closing to allow upgrade', { scope: 'db.versionchange' });\r\n      this.close();\r\n    });\r\n  }\r\n}\r\n\r\n/* =========================\r\n * Singleton + Helpers\r\n * ========================= */\r\n\r\nlet _dbInstance: StudyMasterDB | null = null;\r\n\r\n/**\r\n * Returns the singleton DB instance (not necessarily open).\r\n */\r\nexport function getDB(): StudyMasterDB {\r\n  if (!_dbInstance) {\r\n    _dbInstance = new StudyMasterDB();\r\n  }\r\n  return _dbInstance;\r\n}\r\n\r\n/**\r\n * Ensures the DB is open before use.\r\n * Repositories should call this before any transaction/operation.\r\n */\r\nexport async function ensureDBOpen(): Promise<StudyMasterDB> {\r\n  const db = getDB();\r\n  if (!db.isOpen()) {\r\n    try {\r\n      await db.open();\r\n    } catch (err) {\r\n      console.error('[DB] open error:', err);\r\n      throw err;\r\n    }\r\n  }\r\n  return db;\r\n}\r\n\r\n/**\r\n * Utility to reset the DB during tests.\r\n * WARNING: Do not use in production code paths.\r\n */\r\nexport async function resetDBForTests(): Promise<void> {\r\n  const db = getDB();\r\n  db.close();\r\n  await Dexie.delete(db.name);\r\n  _dbInstance = new StudyMasterDB();\r\n}\r\n\r\n/**\r\n * Health check utility: validates that all expected tables exist.\r\n */\r\nexport async function validateSchema(): Promise<{ ok: boolean; missing: string[] }> {\r\n  const db = await ensureDBOpen();\r\n  const expected = [\r\n    'settings',\r\n    'users',\r\n    'decks',\r\n    'cards',\r\n    'reviews',\r\n    'media',\r\n    'achievements',\r\n    'challenges',\r\n    'leaderboardCache',\r\n    'syncQueue',\r\n  ];\r\n  const actual = db.tables.map((t) => t.name);\r\n  const missing = expected.filter((name) => !actual.includes(name));\r\n  return { ok: missing.length === 0, missing };\r\n}\r\n\r\n/**\r\n * Default export: Proxy to always forward to the current singleton instance.\r\n * This avoids stale references after resetDBForTests() creates a new instance.\r\n */\r\nconst db = new Proxy({} as StudyMasterDB, {\r\n  get(_target, prop, receiver) {\r\n    const inst = getDB() as any;\r\n    const value = Reflect.get(inst, prop, receiver);\r\n    return typeof value === 'function' ? value.bind(inst) : value;\r\n  }\r\n}) as unknown as StudyMasterDB;\r\n\r\nexport default db;","import type {\r\n  User\r\n} from '@shared/types';\r\nimport { pb } from '../lib/pocketbase';\r\nimport { debugLogger } from '../utils/debugLogger';\r\n\r\n// Extended User interface for authentication context\r\nexport interface AuthenticatedUser extends User {\r\n  token?: string;\r\n  tokenType?: 'demo' | 'mock' | 'real';\r\n}\r\n\r\n// Types for user data and statistics\r\nexport interface UserStats {\r\n  totalXP: number;\r\n  level: number;\r\n  currentLevelXP: number;\r\n  nextLevelXP: number;\r\n  cardsStudied: number;\r\n  studyTime: number; // in minutes\r\n  accuracy: number; // percentage\r\n  currentStreak: number;\r\n  longestStreak: number;\r\n  coins: number;\r\n  gems: number;\r\n  lastStudyDate: string;\r\n  joinDate: string;\r\n}\r\n\r\nexport interface UserActivity {\r\n  date: string;\r\n  cardsStudied: number;\r\n  studyTime: number;\r\n  accuracy: number;\r\n  xpGained: number;\r\n}\r\n\r\nexport interface UserAchievement {\r\n  id: string;\r\n  name: string;\r\n  description: string;\r\n  icon: string;\r\n  unlockedAt: string;\r\n  category: 'study' | 'streak' | 'accuracy' | 'time' | 'social';\r\n}\r\n\r\nexport interface UserChallenge {\r\n  id: string;\r\n  name: string;\r\n  description: string;\r\n  type: 'daily' | 'weekly' | 'monthly';\r\n  target: number;\r\n  current: number;\r\n  reward: {\r\n    xp: number;\r\n    coins: number;\r\n    gems?: number;\r\n  };\r\n  expiresAt: string;\r\n  completedAt?: string;\r\n}\r\n\r\nexport interface UserPerformanceMetrics {\r\n  weeklyProgress: {\r\n    cardsStudied: number;\r\n    studyTime: number;\r\n    accuracy: number;\r\n    goal: number;\r\n  };\r\n  monthlyProgress: {\r\n    cardsStudied: number;\r\n    studyTime: number;\r\n    decksCompleted: number;\r\n  };\r\n  studyPattern: {\r\n    preferredTime: string;\r\n    averageSessionLength: number;\r\n    studyFrequency: number;\r\n  };\r\n}\r\n\r\nexport interface LeaderboardEntry {\r\n  userId: string;\r\n  username: string;\r\n  avatar?: string;\r\n  score: number;\r\n  rank: number;\r\n  change: number; // position change from last period\r\n}\r\n\r\nexport interface LeaderboardData {\r\n  global: LeaderboardEntry[];\r\n  friends: LeaderboardEntry[];\r\n  weekly: LeaderboardEntry[];\r\n  monthly: LeaderboardEntry[];\r\n}\r\n\r\n// Demo data for demo users\r\nconst DEMO_USER_STATS: UserStats = {\r\n  totalXP: 2500,\r\n  level: 5,\r\n  currentLevelXP: 100,\r\n  nextLevelXP: 500,\r\n  cardsStudied: 1250,\r\n  studyTime: 2400, // 40 hours\r\n  accuracy: 87.5,\r\n  currentStreak: 15,\r\n  longestStreak: 28,\r\n  coins: 150,\r\n  gems: 10,\r\n  lastStudyDate: new Date().toISOString(),\r\n  joinDate: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString()\r\n};\r\n\r\nconst DEMO_ACHIEVEMENTS: UserAchievement[] = [\r\n  {\r\n    id: 'first_study',\r\n    name: 'First Steps',\r\n    description: 'Complete your first study session',\r\n    icon: 'ðŸŽ¯',\r\n    unlockedAt: new Date(Date.now() - 25 * 24 * 60 * 60 * 1000).toISOString(),\r\n    category: 'study'\r\n  },\r\n  {\r\n    id: 'week_streak',\r\n    name: 'Week Warrior',\r\n    description: 'Study for 7 days in a row',\r\n    icon: 'ðŸ”¥',\r\n    unlockedAt: new Date(Date.now() - 10 * 24 * 60 * 60 * 1000).toISOString(),\r\n    category: 'streak'\r\n  }\r\n];\r\n\r\n// Enhanced Monthly Challenges\r\nconst ENHANCED_MONTHLY_CHALLENGES: UserChallenge[] = [\r\n  {\r\n    id: 'monthly_mastery',\r\n    name: 'Monthly Mastery Challenge',\r\n    description: 'Complete an intensive month-long study challenge with progressive difficulty',\r\n    type: 'monthly',\r\n    target: 1000,\r\n    current: 245,\r\n    reward: { xp: 1500, coins: 500, gems: 50 },\r\n    expiresAt: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString()\r\n  },\r\n  {\r\n    id: 'knowledge_seeker',\r\n    name: 'Knowledge Seeker',\r\n    description: 'Explore diverse subjects and maintain high accuracy throughout the month',\r\n    type: 'monthly',\r\n    target: 800,\r\n    current: 156,\r\n    reward: { xp: 1200, coins: 400, gems: 30 },\r\n    expiresAt: new Date(Date.now() + 25 * 24 * 60 * 60 * 1000).toISOString()\r\n  }\r\n];\r\n\r\nconst DEMO_CHALLENGES: UserChallenge[] = [\r\n  {\r\n    id: 'daily_grind',\r\n    name: 'Daily Grind',\r\n    description: 'Study 25 cards today',\r\n    type: 'daily',\r\n    target: 25,\r\n    current: 18,\r\n    reward: { xp: 50, coins: 10 },\r\n    expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString()\r\n  },\r\n  {\r\n    id: 'weekly_warrior',\r\n    name: 'Weekly Warrior',\r\n    description: 'Study 200 cards this week',\r\n    type: 'weekly',\r\n    target: 200,\r\n    current: 145,\r\n    reward: { xp: 200, coins: 50, gems: 5 },\r\n    expiresAt: new Date(Date.now() + 3 * 24 * 60 * 60 * 1000).toISOString()\r\n  },\r\n  ...ENHANCED_MONTHLY_CHALLENGES\r\n];\r\n\r\nconst DEMO_LEADERBOARD: LeaderboardData = {\r\n  global: [\r\n    { userId: 'demo1', username: 'StudyMaster', score: 5420, rank: 1, change: 0 },\r\n    { userId: 'demo2', username: 'FlashcardPro', score: 4890, rank: 2, change: 1 },\r\n    { userId: 'demo3', username: 'MemoryWiz', score: 4650, rank: 3, change: -1 },\r\n    { userId: 'demo4', username: 'QuizKing', score: 4200, rank: 4, change: 2 },\r\n    { userId: 'demo_user', username: 'Demo User', score: 2500, rank: 15, change: 3 }\r\n  ],\r\n  friends: [\r\n    { userId: 'friend1', username: 'StudyBuddy', score: 3200, rank: 1, change: 0 },\r\n    { userId: 'demo_user', username: 'Demo User', score: 2500, rank: 2, change: 1 },\r\n    { userId: 'friend2', username: 'LearningPal', score: 2100, rank: 3, change: -1 }\r\n  ],\r\n  weekly: [\r\n    { userId: 'demo1', username: 'StudyMaster', score: 890, rank: 1, change: 2 },\r\n    { userId: 'demo_user', username: 'Demo User', score: 420, rank: 8, change: 5 }\r\n  ],\r\n  monthly: [\r\n    { userId: 'demo1', username: 'StudyMaster', score: 3200, rank: 1, change: 0 },\r\n    { userId: 'demo_user', username: 'Demo User', score: 1800, rank: 12, change: -2 }\r\n  ]\r\n};\r\n\r\n// API service class\r\nexport class UserDataService {\r\n  private baseUrl = '/api';\r\n\r\n  // Check if user is demo user\r\n  private isDemoUser(user: AuthenticatedUser): boolean {\r\n    return user.tokenType === 'demo' || user.email === 'demo@studymaster.app';\r\n  }\r\n\r\n  // Get user statistics\r\n  async getUserStats(user: AuthenticatedUser): Promise<UserStats> {\r\n    debugLogger.log('[USER_DATA_SERVICE]', 'START - getUserStats', {\r\n      userId: user.id,\r\n      isDemoUser: this.isDemoUser(user)\r\n    });\r\n\r\n    if (this.isDemoUser(user)) {\r\n      debugLogger.log('[USER_DATA_SERVICE]', 'Returning demo user stats');\r\n      return DEMO_USER_STATS;\r\n    }\r\n\r\n    // Primary: Try PocketBase\r\n    try {\r\n      debugLogger.log('[USER_DATA_SERVICE]', 'Attempting to fetch user stats from PocketBase');\r\n      \r\n      const userRecord = await pb.collection('users').getOne(user.id, {\r\n        fields: 'level,total_xp,coins,gems,last_active,created,preferences'\r\n      });\r\n\r\n      debugLogger.log('[USER_DATA_SERVICE]', 'PocketBase user stats fetched successfully');\r\n\r\n      // Convert PocketBase record to UserStats format\r\n      const stats: UserStats = {\r\n        totalXP: userRecord.total_xp || 0,\r\n        level: userRecord.level || 1,\r\n        currentLevelXP: (userRecord.total_xp || 0) % 200, // Assuming 200 XP per level\r\n        nextLevelXP: 200,\r\n        cardsStudied: 0, // Will need to calculate from study sessions\r\n        studyTime: 0, // Will need to calculate from study sessions\r\n        accuracy: 85, // Default value, calculate from actual data later\r\n        currentStreak: 0, // Calculate from study sessions\r\n        longestStreak: 0, // Calculate from study sessions\r\n        coins: userRecord.coins || 100,\r\n        gems: userRecord.gems || 10,\r\n        lastStudyDate: userRecord.last_active || new Date().toISOString(),\r\n        joinDate: userRecord.created || new Date().toISOString()\r\n      };\r\n\r\n      return stats;\r\n    } catch (pocketbaseError) {\r\n      debugLogger.warn('[USER_DATA_SERVICE]', 'PocketBase fetch failed, trying REST API fallback', {\r\n        error: pocketbaseError\r\n      });\r\n\r\n      // Fallback: Try REST API\r\n      try {\r\n        const response = await fetch(`${this.baseUrl}/users/${user.id}/stats`, {\r\n          headers: {\r\n            'Authorization': `Bearer ${user.token}`,\r\n            'Content-Type': 'application/json'\r\n          }\r\n        });\r\n\r\n        if (!response.ok) {\r\n          throw new Error('Failed to fetch user stats from REST API');\r\n        }\r\n\r\n        const data = await response.json();\r\n        debugLogger.log('[USER_DATA_SERVICE]', 'REST API user stats fetched successfully');\r\n        return data;\r\n      } catch (apiError) {\r\n        debugLogger.warn('[USER_DATA_SERVICE]', 'Both PocketBase and REST API failed, using mock data', {\r\n          pocketbaseError,\r\n          apiError\r\n        });\r\n        \r\n        // Final fallback: Return personalized mock data\r\n        return this.generatePersonalizedMockStats(user);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Get user activity history\r\n  async getUserActivity(user: AuthenticatedUser, days: number = 30): Promise<UserActivity[]> {\r\n    if (this.isDemoUser(user)) {\r\n      return this.generateDemoActivity(days);\r\n    }\r\n\r\n    try {\r\n      const response = await fetch(`${this.baseUrl}/users/${user.id}/activity?days=${days}`, {\r\n        headers: {\r\n          'Authorization': `Bearer ${user.token}`,\r\n          'Content-Type': 'application/json'\r\n        }\r\n      });\r\n\r\n      if (!response.ok) {\r\n        throw new Error('Failed to fetch user activity');\r\n      }\r\n\r\n      return await response.json();\r\n    } catch (error) {\r\n      console.warn('Failed to fetch real user activity, using mock data:', error);\r\n      return this.generatePersonalizedActivity(user, days);\r\n    }\r\n  }\r\n\r\n  // Get user achievements\r\n  async getUserAchievements(user: AuthenticatedUser): Promise<UserAchievement[]> {\r\n    if (this.isDemoUser(user)) {\r\n      return DEMO_ACHIEVEMENTS;\r\n    }\r\n\r\n    try {\r\n      const response = await fetch(`${this.baseUrl}/users/${user.id}/achievements`, {\r\n        headers: {\r\n          'Authorization': `Bearer ${user.token}`,\r\n          'Content-Type': 'application/json'\r\n        }\r\n      });\r\n\r\n      if (!response.ok) {\r\n        throw new Error('Failed to fetch user achievements');\r\n      }\r\n\r\n      return await response.json();\r\n    } catch (error) {\r\n      console.warn('Failed to fetch real user achievements, using mock data:', error);\r\n      return this.generatePersonalizedAchievements(user);\r\n    }\r\n  }\r\n\r\n  // Get user challenges\r\n  async getUserChallenges(user: AuthenticatedUser): Promise<UserChallenge[]> {\r\n    if (this.isDemoUser(user)) {\r\n      return DEMO_CHALLENGES;\r\n    }\r\n\r\n    try {\r\n      const response = await fetch(`${this.baseUrl}/users/${user.id}/challenges`, {\r\n        headers: {\r\n          'Authorization': `Bearer ${user.token}`,\r\n          'Content-Type': 'application/json'\r\n        }\r\n      });\r\n\r\n      if (!response.ok) {\r\n        throw new Error('Failed to fetch user challenges');\r\n      }\r\n\r\n      return await response.json();\r\n    } catch (error) {\r\n      console.warn('Failed to fetch real user challenges, using mock data:', error);\r\n      return this.generatePersonalizedChallenges(user);\r\n    }\r\n  }\r\n\r\n  // Get leaderboard data\r\n  async getLeaderboardData(user: AuthenticatedUser): Promise<LeaderboardData> {\r\n    if (this.isDemoUser(user)) {\r\n      return DEMO_LEADERBOARD;\r\n    }\r\n\r\n    try {\r\n      const response = await fetch(`${this.baseUrl}/leaderboard`, {\r\n        headers: {\r\n          'Authorization': `Bearer ${user.token}`,\r\n          'Content-Type': 'application/json'\r\n        }\r\n      });\r\n\r\n      if (!response.ok) {\r\n        throw new Error('Failed to fetch leaderboard data');\r\n      }\r\n\r\n      return await response.json();\r\n    } catch (error) {\r\n      console.warn('Failed to fetch real leaderboard data, using mock data:', error);\r\n      return this.generatePersonalizedLeaderboard(user);\r\n    }\r\n  }\r\n\r\n  // Get performance metrics\r\n  async getPerformanceMetrics(user: AuthenticatedUser): Promise<UserPerformanceMetrics> {\r\n    if (this.isDemoUser(user)) {\r\n      return this.generateDemoPerformanceMetrics();\r\n    }\r\n\r\n    try {\r\n      const response = await fetch(`${this.baseUrl}/users/${user.id}/performance`, {\r\n        headers: {\r\n          'Authorization': `Bearer ${user.token}`,\r\n          'Content-Type': 'application/json'\r\n        }\r\n      });\r\n\r\n      if (!response.ok) {\r\n        throw new Error('Failed to fetch performance metrics');\r\n      }\r\n\r\n      return await response.json();\r\n    } catch (error) {\r\n      console.warn('Failed to fetch real performance metrics, using mock data:', error);\r\n      return this.generatePersonalizedPerformanceMetrics(user);\r\n    }\r\n  }\r\n\r\n  // Get comprehensive user profile data\r\n  async getCompleteUserProfile(user: AuthenticatedUser): Promise<{\r\n    stats: UserStats;\r\n    activity: UserActivity[];\r\n    achievements: UserAchievement[];\r\n    challenges: UserChallenge[];\r\n    performance: UserPerformanceMetrics;\r\n  }> {\r\n    const [stats, activity, achievements, challenges, performance] = await Promise.all([\r\n      this.getUserStats(user),\r\n      this.getUserActivity(user, 30),\r\n      this.getUserAchievements(user),\r\n      this.getUserChallenges(user),\r\n      this.getPerformanceMetrics(user)\r\n    ]);\r\n\r\n    return {\r\n      stats,\r\n      activity,\r\n      achievements,\r\n      challenges,\r\n      performance\r\n    };\r\n  }\r\n\r\n  // Reset all user data\r\n  async resetAllUserData(user: AuthenticatedUser): Promise<void> {\r\n    if (this.isDemoUser(user)) {\r\n      // For demo users, we don't need to do anything as data is static\r\n      return;\r\n    }\r\n\r\n    try {\r\n      const response = await fetch(`${this.baseUrl}/users/${user.id}/reset`, {\r\n        method: 'POST',\r\n        headers: {\r\n          'Authorization': `Bearer ${user.token}`,\r\n          'Content-Type': 'application/json'\r\n        }\r\n      });\r\n\r\n      if (!response.ok) {\r\n        throw new Error('Failed to reset user data');\r\n      }\r\n    } catch (error) {\r\n      console.warn('Failed to reset real user data via API:', error);\r\n      // For mock users, we don't need to do anything as the stores will handle the reset\r\n      // The error is expected when API is not available\r\n    }\r\n  }\r\n\r\n  // Generate personalized mock data for authenticated users\r\n  private generatePersonalizedMockStats(user: AuthenticatedUser): UserStats {\r\n    const userHash = this.hashString(user.email);\r\n    const daysSinceJoin = Math.floor(userHash % 60) + 1; // 1-60 days\r\n    \r\n    return {\r\n      totalXP: Math.floor(userHash % 1000) + 100,\r\n      level: Math.floor((userHash % 1000) / 200) + 1,\r\n      currentLevelXP: userHash % 200,\r\n      nextLevelXP: 200,\r\n      cardsStudied: Math.floor(userHash % 500) + 50,\r\n      studyTime: Math.floor(userHash % 1200) + 60, // 1-20 hours\r\n      accuracy: 75 + (userHash % 20), // 75-95%\r\n      currentStreak: Math.floor(userHash % 15) + 1,\r\n      longestStreak: Math.floor(userHash % 30) + 5,\r\n      coins: Math.floor(userHash % 200) + 50,\r\n      gems: Math.floor(userHash % 20) + 5,\r\n      lastStudyDate: new Date().toISOString(),\r\n      joinDate: new Date(Date.now() - daysSinceJoin * 24 * 60 * 60 * 1000).toISOString()\r\n    };\r\n  }\r\n\r\n  private generatePersonalizedActivity(user: AuthenticatedUser, days: number): UserActivity[] {\r\n    const activities: UserActivity[] = [];\r\n    \r\n    for (let i = 0; i < days; i++) {\r\n      const date = new Date(Date.now() - i * 24 * 60 * 60 * 1000);\r\n      const dayHash = this.hashString(user.email + date.toDateString());\r\n      \r\n      // Some days have no activity\r\n      if (dayHash % 4 === 0) continue;\r\n      \r\n      activities.push({\r\n        date: date.toISOString().split('T')[0],\r\n        cardsStudied: Math.floor(dayHash % 50) + 5,\r\n        studyTime: Math.floor(dayHash % 120) + 10,\r\n        accuracy: 70 + (dayHash % 25),\r\n        xpGained: Math.floor(dayHash % 100) + 20\r\n      });\r\n    }\r\n    \r\n    return activities.reverse();\r\n  }\r\n\r\n  private generatePersonalizedAchievements(user: AuthenticatedUser): UserAchievement[] {\r\n    const userHash = this.hashString(user.email);\r\n    const baseAchievements = [...DEMO_ACHIEVEMENTS];\r\n    \r\n    // Add user-specific achievements based on their hash\r\n    if (userHash % 3 === 0) {\r\n      baseAchievements.push({\r\n        id: 'accuracy_master',\r\n        name: 'Accuracy Master',\r\n        description: 'Achieve 90% accuracy in a session',\r\n        icon: 'ðŸŽ¯',\r\n        unlockedAt: new Date(Date.now() - 5 * 24 * 60 * 60 * 1000).toISOString(),\r\n        category: 'accuracy'\r\n      });\r\n    }\r\n    \r\n    return baseAchievements;\r\n  }\r\n\r\n  private generatePersonalizedChallenges(user: AuthenticatedUser): UserChallenge[] {\r\n    // Generate personalized data based on user email\r\n    const challenges = [...DEMO_CHALLENGES];\r\n    \r\n    // Personalize challenge progress based on user\r\n    challenges.forEach(challenge => {\r\n      const progressHash = this.hashString(user.email + challenge.id);\r\n      challenge.current = Math.floor((progressHash % 80) / 100 * challenge.target);\r\n    });\r\n    \r\n    return challenges;\r\n  }\r\n\r\n  private generatePersonalizedLeaderboard(user: AuthenticatedUser): LeaderboardData {\r\n    const userHash = this.hashString(user.email);\r\n    const userScore = Math.floor(userHash % 1000) + 100;\r\n    const userRank = Math.floor(userHash % 50) + 5;\r\n    \r\n    const leaderboard = { ...DEMO_LEADERBOARD };\r\n    \r\n    // Insert user into leaderboards\r\n    leaderboard.global.push({\r\n      userId: user.id,\r\n      username: user.username,\r\n      score: userScore,\r\n      rank: userRank,\r\n      change: Math.floor(userHash % 10) - 5\r\n    });\r\n    \r\n    return leaderboard;\r\n  }\r\n\r\n  private generateDemoActivity(days: number): UserActivity[] {\r\n    const activities: UserActivity[] = [];\r\n    \r\n    for (let i = 0; i < days; i++) {\r\n      const date = new Date(Date.now() - i * 24 * 60 * 60 * 1000);\r\n      \r\n      // Skip some days to make it realistic\r\n      if (i % 3 === 0) continue;\r\n      \r\n      activities.push({\r\n        date: date.toISOString().split('T')[0],\r\n        cardsStudied: Math.floor(Math.random() * 40) + 10,\r\n        studyTime: Math.floor(Math.random() * 90) + 15,\r\n        accuracy: 80 + Math.floor(Math.random() * 15),\r\n        xpGained: Math.floor(Math.random() * 80) + 30\r\n      });\r\n    }\r\n    \r\n    return activities.reverse();\r\n  }\r\n\r\n  private generateDemoPerformanceMetrics(): UserPerformanceMetrics {\r\n    return {\r\n      weeklyProgress: {\r\n        cardsStudied: 180,\r\n        studyTime: 240, // 4 hours\r\n        accuracy: 87.5,\r\n        goal: 350\r\n      },\r\n      monthlyProgress: {\r\n        cardsStudied: 720,\r\n        studyTime: 1200, // 20 hours\r\n        decksCompleted: 8\r\n      },\r\n      studyPattern: {\r\n        preferredTime: 'evening',\r\n        averageSessionLength: 25,\r\n        studyFrequency: 5.2\r\n      }\r\n    };\r\n  }\r\n\r\n  private generatePersonalizedPerformanceMetrics(user: AuthenticatedUser): UserPerformanceMetrics {\r\n    const userHash = this.hashString(user.email);\r\n    \r\n    return {\r\n      weeklyProgress: {\r\n        cardsStudied: Math.floor(userHash % 200) + 50,\r\n        studyTime: Math.floor(userHash % 300) + 60,\r\n        accuracy: 75 + (userHash % 20),\r\n        goal: 300\r\n      },\r\n      monthlyProgress: {\r\n        cardsStudied: Math.floor(userHash % 800) + 200,\r\n        studyTime: Math.floor(userHash % 1500) + 300,\r\n        decksCompleted: Math.floor(userHash % 15) + 3\r\n      },\r\n      studyPattern: {\r\n        preferredTime: ['morning', 'afternoon', 'evening'][userHash % 3],\r\n        averageSessionLength: Math.floor(userHash % 30) + 15,\r\n        studyFrequency: 3 + (userHash % 4)\r\n      }\r\n    };\r\n  }\r\n\r\n  // Simple hash function for consistent personalization\r\n  private hashString(str: string): number {\r\n    let hash = 0;\r\n    for (let i = 0; i < str.length; i++) {\r\n      const char = str.charCodeAt(i);\r\n      hash = ((hash << 5) - hash) + char;\r\n      hash = hash & hash; // Convert to 32-bit integer\r\n    }\r\n    return Math.abs(hash);\r\n  }\r\n}\r\n\r\n// Export singleton instance\r\nexport const userDataService = new UserDataService();","// Removed unused imports: useDeckStore and useGamificationStore\r\n\r\n// Types for real-time data\r\nexport interface GlobalLearningStats {\r\n  totalLearners: number\r\n  cardsStudiedToday: number\r\n  activeStudySessions: number\r\n  languagesBeingLearned: number\r\n  topSubjects: Array<{ name: string; learners: number }>\r\n  studyTimeToday: number // in minutes\r\n  lastUpdated: string\r\n}\r\n\r\nexport interface EducationalTrends {\r\n  popularSubjects: Array<{ subject: string; growth: number; learners: number }>\r\n  learningMethods: Array<{ method: string; effectiveness: number; usage: number }>\r\n  studyPatterns: {\r\n    peakHours: Array<{ hour: number; activity: number }>\r\n    weeklyTrends: Array<{ day: string; sessions: number }>\r\n  }\r\n  lastUpdated: string\r\n}\r\n\r\nexport interface LiveUserMetrics {\r\n  onlineUsers: number\r\n  studyingSessions: number\r\n  completedToday: number\r\n  averageAccuracy: number\r\n  topPerformers: Array<{ username: string; score: number; country: string }>\r\n  lastUpdated: string\r\n}\r\n\r\nexport interface MarketInsights {\r\n  skillDemand: Array<{ skill: string; demand: number; growth: number }>\r\n  industryTrends: Array<{ industry: string; skills: string[]; growth: number }>\r\n  certificationValue: Array<{ cert: string; value: number; popularity: number }>\r\n  lastUpdated: string\r\n}\r\n\r\n// Real-time data service class\r\nexport class RealTimeDataService {\r\n  private updateInterval: number = 30000 // 30 seconds\r\n  private subscribers: Map<string, ((data: unknown) => void)[]> = new Map()\r\n  private intervalId: NodeJS.Timeout | null = null\r\n  private activeInstances: number = 0 // Reference counter for active instances\r\n\r\n  // Subscribe to real-time updates\r\n  subscribe<T = unknown>(dataType: string, callback: (data: T) => void): () => void {\r\n    if (!this.subscribers.has(dataType)) {\r\n      this.subscribers.set(dataType, [])\r\n    }\r\n    this.subscribers.get(dataType)!.push(callback as (data: unknown) => void)\r\n\r\n    // Return unsubscribe function\r\n    return () => {\r\n      const callbacks = this.subscribers.get(dataType)\r\n      if (callbacks) {\r\n        const index = callbacks.indexOf(callback as (data: unknown) => void)\r\n        if (index > -1) {\r\n          callbacks.splice(index, 1)\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // Notify subscribers\r\n  private notify(dataType: string, data: unknown): void {\r\n    const callbacks = this.subscribers.get(dataType)\r\n    if (callbacks) {\r\n      callbacks.forEach(callback => callback(data))\r\n    }\r\n  }\r\n\r\n  // Fetch global learning statistics from multiple sources\r\n  async getGlobalLearningStats(): Promise<GlobalLearningStats> {\r\n    try {\r\n      // Try to fetch from real educational APIs\r\n      const stats = await this.fetchFromMultipleSources([\r\n        () => this.fetchFromDuolingoAPI(),\r\n        () => this.fetchFromKhanAcademyAPI(),\r\n        () => this.fetchFromCourseraAPI(),\r\n        () => this.fetchFromEducationalDataAPI()\r\n      ])\r\n\r\n      if (stats) {\r\n        this.notify('globalStats', stats)\r\n        return stats as GlobalLearningStats\r\n      }\r\n    } catch (error) {\r\n      console.warn('Failed to fetch real global stats, using enhanced mock data:', error)\r\n    }\r\n\r\n    // Enhanced realistic mock data with time-based variations\r\n    return this.generateEnhancedGlobalStats()\r\n  }\r\n\r\n  // Fetch educational trends from research APIs\r\n  async getEducationalTrends(): Promise<EducationalTrends> {\r\n    try {\r\n      // Try to fetch from educational research APIs\r\n      const trends = await this.fetchEducationalTrendsFromAPIs()\r\n      if (trends) {\r\n        this.notify('educationalTrends', trends)\r\n        return trends\r\n      }\r\n    } catch (error) {\r\n      console.warn('Failed to fetch real educational trends, using enhanced mock data:', error)\r\n    }\r\n\r\n    return this.generateEnhancedEducationalTrends()\r\n  }\r\n\r\n  // Fetch live user metrics\r\n  async getLiveUserMetrics(): Promise<LiveUserMetrics> {\r\n    try {\r\n      // Try to fetch from real-time analytics APIs\r\n      const metrics = await this.fetchLiveMetricsFromAPIs()\r\n      if (metrics) {\r\n        this.notify('liveMetrics', metrics)\r\n        return metrics\r\n      }\r\n    } catch (error) {\r\n      console.warn('Failed to fetch real live metrics, using enhanced mock data:', error)\r\n    }\r\n\r\n    return this.generateEnhancedLiveMetrics()\r\n  }\r\n\r\n  // Fetch market insights from job/skill APIs\r\n  async getMarketInsights(): Promise<MarketInsights> {\r\n    try {\r\n      // Try to fetch from job market APIs\r\n      const insights = await this.fetchMarketInsightsFromAPIs()\r\n      if (insights) {\r\n        this.notify('marketInsights', insights)\r\n        return insights\r\n      }\r\n    } catch (error) {\r\n      console.warn('Failed to fetch real market insights, using enhanced mock data:', error)\r\n    }\r\n\r\n    return this.generateEnhancedMarketInsights()\r\n  }\r\n\r\n  // Attempt to fetch from Duolingo's public API\r\n  private async fetchFromDuolingoAPI(): Promise<Partial<GlobalLearningStats> | null> {\r\n    try {\r\n      // Note: Duolingo doesn't have a public API for global stats\r\n      // This is a placeholder for when such APIs become available\r\n      const response = await fetch('https://www.duolingo.com/api/1/users/show?username=duolingo', {\r\n        method: 'GET',\r\n        headers: { 'Accept': 'application/json' }\r\n      })\r\n      \r\n      if (response.ok) {\r\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n        const _data = await response.json()\r\n        // Extract relevant statistics if available\r\n        return null // Placeholder\r\n      }\r\n    } catch (error) {\r\n      console.log('Duolingo API not accessible:', error)\r\n    }\r\n    return null\r\n  }\r\n\r\n  // Attempt to fetch from Khan Academy's API\r\n  private async fetchFromKhanAcademyAPI(): Promise<Partial<GlobalLearningStats> | null> {\r\n    try {\r\n      // Khan Academy has limited public APIs\r\n      // This is a placeholder for educational statistics\r\n      return null\r\n    } catch (error) {\r\n      console.log('Khan Academy API not accessible:', error)\r\n    }\r\n    return null\r\n  }\r\n\r\n  // Attempt to fetch from Coursera's API\r\n  private async fetchFromCourseraAPI(): Promise<Partial<GlobalLearningStats> | null> {\r\n    try {\r\n      // Coursera doesn't have public global statistics API\r\n      // This is a placeholder\r\n      return null\r\n    } catch (error) {\r\n      console.log('Coursera API not accessible:', error)\r\n    }\r\n    return null\r\n  }\r\n\r\n  // Attempt to fetch from educational data APIs\r\n  private async fetchFromEducationalDataAPI(): Promise<Partial<GlobalLearningStats> | null> {\r\n    try {\r\n      // Try to fetch from open educational data sources\r\n      // This could include UNESCO, World Bank education data, etc.\r\n      return null\r\n    } catch (error) {\r\n      console.log('Educational data API not accessible:', error)\r\n    }\r\n    return null\r\n  }\r\n\r\n  // Fetch from multiple sources and combine results\r\n  private async fetchFromMultipleSources(fetchers: Array<() => Promise<unknown>>): Promise<unknown> {\r\n    const results = await Promise.allSettled(fetchers.map(fetcher => fetcher()))\r\n    \r\n    // Combine successful results\r\n    const successfulResults = results\r\n      .filter(result => result.status === 'fulfilled' && result.value)\r\n      .map(result => (result as PromiseFulfilledResult<unknown>).value)\r\n\r\n    if (successfulResults.length > 0) {\r\n      // Merge results from multiple sources\r\n      return this.mergeDataSources(successfulResults)\r\n    }\r\n\r\n    return null\r\n  }\r\n\r\n  // Merge data from multiple sources\r\n  private mergeDataSources(sources: unknown[]): unknown {\r\n    // Implement logic to combine data from multiple sources\r\n    // For now, return the first successful source\r\n    return sources[0]\r\n  }\r\n\r\n  // Generate enhanced realistic global statistics\r\n  private generateEnhancedGlobalStats(): GlobalLearningStats {\r\n    const now = new Date()\r\n    const hour = now.getHours()\r\n    const dayOfWeek = now.getDay()\r\n    \r\n    // Time-based activity simulation\r\n    const timeMultiplier = this.getTimeBasedMultiplier(hour, dayOfWeek)\r\n    \r\n    // Base numbers that feel realistic for a global learning platform\r\n    const baseLearners = 2847392\r\n    const baseCardsToday = 15847293\r\n    const baseActiveSessions = 23847\r\n    \r\n    return {\r\n      totalLearners: Math.floor(baseLearners + (Math.random() * 1000 - 500)),\r\n      cardsStudiedToday: Math.floor(baseCardsToday * timeMultiplier + (Math.random() * 10000 - 5000)),\r\n      activeStudySessions: Math.floor(baseActiveSessions * timeMultiplier + (Math.random() * 1000 - 500)),\r\n      languagesBeingLearned: 127 + Math.floor(Math.random() * 5),\r\n      topSubjects: [\r\n        { name: 'Spanish', learners: Math.floor(847392 * timeMultiplier) },\r\n        { name: 'JavaScript', learners: Math.floor(623847 * timeMultiplier) },\r\n        { name: 'French', learners: Math.floor(534829 * timeMultiplier) },\r\n        { name: 'Python', learners: Math.floor(487293 * timeMultiplier) },\r\n        { name: 'German', learners: Math.floor(392847 * timeMultiplier) }\r\n      ],\r\n      studyTimeToday: Math.floor(1847293 * timeMultiplier), // in minutes\r\n      lastUpdated: now.toISOString()\r\n    }\r\n  }\r\n\r\n  // Generate enhanced educational trends\r\n  private generateEnhancedEducationalTrends(): EducationalTrends {\r\n    const now = new Date()\r\n    \r\n    return {\r\n      popularSubjects: [\r\n        { subject: 'Artificial Intelligence', growth: 156.7, learners: 892847 },\r\n        { subject: 'Data Science', growth: 134.2, learners: 734829 },\r\n        { subject: 'Cybersecurity', growth: 128.9, learners: 623847 },\r\n        { subject: 'Cloud Computing', growth: 119.4, learners: 587293 },\r\n        { subject: 'Machine Learning', growth: 112.8, learners: 534829 },\r\n        { subject: 'Spanish Language', growth: 89.3, learners: 1247392 },\r\n        { subject: 'Digital Marketing', growth: 87.6, learners: 423847 },\r\n        { subject: 'UX/UI Design', growth: 82.4, learners: 392847 }\r\n      ],\r\n      learningMethods: [\r\n        { method: 'Spaced Repetition', effectiveness: 94.7, usage: 78.3 },\r\n        { method: 'Active Recall', effectiveness: 91.2, usage: 65.8 },\r\n        { method: 'Microlearning', effectiveness: 87.9, usage: 82.1 },\r\n        { method: 'Gamification', effectiveness: 84.6, usage: 71.4 },\r\n        { method: 'Peer Learning', effectiveness: 81.3, usage: 56.7 }\r\n      ],\r\n      studyPatterns: {\r\n        peakHours: this.generatePeakHours(),\r\n        weeklyTrends: this.generateWeeklyTrends()\r\n      },\r\n      lastUpdated: now.toISOString()\r\n    }\r\n  }\r\n\r\n  // Generate enhanced live user metrics\r\n  private generateEnhancedLiveMetrics(): LiveUserMetrics {\r\n    const now = new Date()\r\n    const hour = now.getHours()\r\n    const timeMultiplier = this.getTimeBasedMultiplier(hour, now.getDay())\r\n    \r\n    return {\r\n      onlineUsers: Math.floor(47392 * timeMultiplier + (Math.random() * 1000 - 500)),\r\n      studyingSessions: Math.floor(23847 * timeMultiplier + (Math.random() * 500 - 250)),\r\n      completedToday: Math.floor(184729 + (Math.random() * 1000 - 500)),\r\n      averageAccuracy: 87.3 + (Math.random() * 4 - 2),\r\n      topPerformers: [\r\n        { username: 'StudyMaster_Pro', score: 15847, country: 'Singapore' },\r\n        { username: 'LearningNinja', score: 14923, country: 'South Korea' },\r\n        { username: 'FlashcardWiz', score: 14756, country: 'Finland' },\r\n        { username: 'MemoryChamp', score: 14234, country: 'Japan' },\r\n        { username: 'QuizMaster', score: 13892, country: 'Canada' }\r\n      ],\r\n      lastUpdated: now.toISOString()\r\n    }\r\n  }\r\n\r\n  // Generate enhanced market insights\r\n  private generateEnhancedMarketInsights(): MarketInsights {\r\n    const now = new Date()\r\n    \r\n    return {\r\n      skillDemand: [\r\n        { skill: 'AI/Machine Learning', demand: 94.7, growth: 156.3 },\r\n        { skill: 'Cloud Architecture', demand: 91.2, growth: 134.7 },\r\n        { skill: 'Cybersecurity', demand: 89.8, growth: 128.9 },\r\n        { skill: 'Data Analysis', demand: 87.4, growth: 119.2 },\r\n        { skill: 'DevOps', demand: 84.9, growth: 112.6 },\r\n        { skill: 'Full-Stack Development', demand: 82.3, growth: 98.4 },\r\n        { skill: 'Digital Marketing', demand: 78.7, growth: 87.9 },\r\n        { skill: 'UX Design', demand: 76.2, growth: 82.1 }\r\n      ],\r\n      industryTrends: [\r\n        { \r\n          industry: 'Technology', \r\n          skills: ['AI/ML', 'Cloud Computing', 'Cybersecurity'], \r\n          growth: 145.7 \r\n        },\r\n        { \r\n          industry: 'Healthcare', \r\n          skills: ['Data Analysis', 'Digital Health', 'Telemedicine'], \r\n          growth: 123.4 \r\n        },\r\n        { \r\n          industry: 'Finance', \r\n          skills: ['Blockchain', 'FinTech', 'Risk Analysis'], \r\n          growth: 118.9 \r\n        },\r\n        { \r\n          industry: 'Education', \r\n          skills: ['EdTech', 'Online Learning', 'Digital Pedagogy'], \r\n          growth: 134.2 \r\n        }\r\n      ],\r\n      certificationValue: [\r\n        { cert: 'AWS Certified Solutions Architect', value: 98.7, popularity: 87.3 },\r\n        { cert: 'Google Cloud Professional', value: 96.2, popularity: 82.1 },\r\n        { cert: 'Certified Ethical Hacker', value: 94.8, popularity: 76.4 },\r\n        { cert: 'PMP Certification', value: 91.3, popularity: 89.7 },\r\n        { cert: 'Cisco CCNA', value: 88.9, popularity: 78.2 }\r\n      ],\r\n      lastUpdated: now.toISOString()\r\n    }\r\n  }\r\n\r\n  // Get time-based activity multiplier\r\n  private getTimeBasedMultiplier(hour: number, dayOfWeek: number): number {\r\n    // Peak hours: 9-11 AM, 2-4 PM, 7-9 PM\r\n    let hourMultiplier = 0.7 // Base activity\r\n    \r\n    if ((hour >= 9 && hour <= 11) || (hour >= 14 && hour <= 16) || (hour >= 19 && hour <= 21)) {\r\n      hourMultiplier = 1.2 // Peak hours\r\n    } else if (hour >= 6 && hour <= 23) {\r\n      hourMultiplier = 1.0 // Normal hours\r\n    }\r\n    \r\n    // Weekend vs weekday\r\n    const dayMultiplier = (dayOfWeek === 0 || dayOfWeek === 6) ? 0.8 : 1.0\r\n    \r\n    return hourMultiplier * dayMultiplier\r\n  }\r\n\r\n  // Generate realistic peak hours data\r\n  private generatePeakHours(): Array<{ hour: number; activity: number }> {\r\n    const peakHours = []\r\n    for (let hour = 0; hour < 24; hour++) {\r\n      let activity = 30 // Base activity\r\n      \r\n      // Morning peak (9-11 AM)\r\n      if (hour >= 9 && hour <= 11) activity = 85 + Math.random() * 10\r\n      // Afternoon peak (2-4 PM)\r\n      else if (hour >= 14 && hour <= 16) activity = 90 + Math.random() * 10\r\n      // Evening peak (7-9 PM)\r\n      else if (hour >= 19 && hour <= 21) activity = 95 + Math.random() * 10\r\n      // Normal hours\r\n      else if (hour >= 6 && hour <= 23) activity = 60 + Math.random() * 20\r\n      // Night hours\r\n      else activity = 20 + Math.random() * 15\r\n      \r\n      peakHours.push({ hour, activity: Math.floor(activity) })\r\n    }\r\n    return peakHours\r\n  }\r\n\r\n  // Generate weekly trends\r\n  private generateWeeklyTrends(): Array<{ day: string; sessions: number }> {\r\n    const days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']\r\n    const baseSessions = [8500, 9200, 9800, 9500, 8900, 7200, 6800] // Realistic weekly pattern\r\n    \r\n    return days.map((day, index) => ({\r\n      day,\r\n      sessions: Math.floor(baseSessions[index] + (Math.random() * 1000 - 500))\r\n    }))\r\n  }\r\n\r\n  // Placeholder methods for real API calls\r\n  private async fetchEducationalTrendsFromAPIs(): Promise<EducationalTrends | null> {\r\n    // Implement real API calls to educational research databases\r\n    return null\r\n  }\r\n\r\n  private async fetchLiveMetricsFromAPIs(): Promise<LiveUserMetrics | null> {\r\n    // Implement real API calls to analytics services\r\n    return null\r\n  }\r\n\r\n  private async fetchMarketInsightsFromAPIs(): Promise<MarketInsights | null> {\r\n    // Implement real API calls to job market APIs (LinkedIn, Indeed, etc.)\r\n    return null\r\n  }\r\n\r\n  // Start real-time updates with reference counting\r\n  startRealTimeUpdates(): () => void {\r\n    this.activeInstances++\r\n    \r\n    // Only start interval if this is the first instance\r\n    if (this.activeInstances === 1 && !this.intervalId) {\r\n      this.intervalId = setInterval(async () => {\r\n        try {\r\n          const [globalStats, trends, liveMetrics, marketInsights] = await Promise.all([\r\n            this.getGlobalLearningStats(),\r\n            this.getEducationalTrends(),\r\n            this.getLiveUserMetrics(),\r\n            this.getMarketInsights()\r\n          ])\r\n\r\n          // Notify all subscribers with fresh data\r\n          this.notify('globalStats', globalStats)\r\n          this.notify('educationalTrends', trends)\r\n          this.notify('liveMetrics', liveMetrics)\r\n          this.notify('marketInsights', marketInsights)\r\n        } catch (error) {\r\n          console.error('Error updating real-time data:', error)\r\n        }\r\n      }, this.updateInterval)\r\n    }\r\n\r\n    // Return cleanup function\r\n    return () => {\r\n      this.stopRealTimeUpdates()\r\n    }\r\n  }\r\n\r\n  // Stop real-time updates with reference counting\r\n  stopRealTimeUpdates(): void {\r\n    this.activeInstances = Math.max(0, this.activeInstances - 1)\r\n    \r\n    // Only stop interval when no more active instances\r\n    if (this.activeInstances === 0 && this.intervalId) {\r\n      clearInterval(this.intervalId)\r\n      this.intervalId = null\r\n    }\r\n  }\r\n\r\n  // Force stop all real-time updates (for cleanup)\r\n  forceStopRealTimeUpdates(): void {\r\n    this.activeInstances = 0\r\n    if (this.intervalId) {\r\n      clearInterval(this.intervalId)\r\n      this.intervalId = null\r\n    }\r\n    // Clear all subscriptions\r\n    this.subscribers.clear()\r\n  }\r\n}\r\n\r\n// Export singleton instance\r\nexport const realTimeDataService = new RealTimeDataService()","import axios from 'axios';\nimport { UnifiedSessionState, CardSelectionResult, EnhancedResponseLog } from '../../../shared/types/enhanced-types';\n\nconst apiClient = axios.create({\n  baseURL: import.meta.env.VITE_API_URL || 'http://localhost:3001/api',\n  withCredentials: true,\n});\n\nexport const uamsApiService = {\n  async initializeSession(userId: string, deckId: string): Promise<UnifiedSessionState> {\n    const response = await apiClient.post('/uams/session/initialize', { userId, deckId });\n    return response.data;\n  },\n\n  async getNextCard(sessionState: UnifiedSessionState): Promise<CardSelectionResult> {\n    const response = await apiClient.post('/uams/session/next-card', { sessionState });\n    return response.data;\n  },\n\n  async processCardResponse(sessionState: UnifiedSessionState, cardId: string, response: EnhancedResponseLog): Promise<UnifiedSessionState> {\n    const apiResponse = await apiClient.post('/uams/session/response', { sessionState, cardId, response });\n    return apiResponse.data;\n  },\n};\n","import { UnifiedSessionState, UnifiedCard, CardSelectionResult, EnhancedResponseLog, SessionContext, UserProfile } from '../../../shared/types/enhanced-types';\nimport { uamsApiService } from './uamsApiService';\n\nexport interface QueueManagerConfig {\n  lookaheadBufferSize: number;\n  emergencyBufferSize: number;\n  challengeReserveSize: number;\n  refreshThreshold: number;\n  maxSessionDurationMinutes: number;\n  adaptiveRefreshInterval: number;\n}\n\nexport interface BufferMetrics {\n  lookaheadUtilization: number;\n  emergencyBufferHealth: number;\n  challengeReserveReadiness: number;\n  overallQueueHealth: number;\n}\n\nexport class UnifiedQueueManager {\n  private config: QueueManagerConfig;\n\n  constructor(config: Partial<QueueManagerConfig> = {}) {\n    this.config = {\n      lookaheadBufferSize: 10,\n      emergencyBufferSize: 5,\n      challengeReserveSize: 5,\n      refreshThreshold: 3,\n      maxSessionDurationMinutes: 120,\n      adaptiveRefreshInterval: 5000,\n      ...config\n    };\n  }\n\n  /**\n   * Initialize a new study session\n   */\n  async initializeSession(userId: string, deckId: string): Promise<UnifiedSessionState> {\n    return uamsApiService.initializeSession(userId, deckId);\n  }\n\n  /**\n   * Get the next card for review\n   */\n  async getNextCard(sessionState: UnifiedSessionState): Promise<CardSelectionResult> {\n    return uamsApiService.getNextCard(sessionState);\n  }\n\n  /**\n   * Process user response and update session state\n   */\n  async processCardResponse(\n    sessionState: UnifiedSessionState,\n    cardId: string,\n    response: EnhancedResponseLog\n  ): Promise<UnifiedSessionState> {\n    return uamsApiService.processCardResponse(sessionState, cardId, response);\n  }\n}","import { EnvironmentalContext, SessionContext } from '../../../../shared/types/enhanced-types';\r\n\r\nexport interface DetectedContext extends EnvironmentalContext {\r\n  confidence: number; // 0-1 confidence in detection accuracy\r\n  detectionMethod: string; // How the context was detected\r\n  timestamp: string;\r\n}\r\n\r\nexport interface ContextualInsights {\r\n  optimalStudyConditions: EnvironmentalContext;\r\n  currentConditionScore: number; // 0-1 how optimal current conditions are\r\n  improvementSuggestions: string[];\r\n  historicalPerformance: PerformanceByContext[];\r\n}\r\n\r\nexport interface PerformanceByContext {\r\n  context: Partial<EnvironmentalContext>;\r\n  averageAccuracy: number;\r\n  averageResponseTime: number;\r\n  sessionCount: number;\r\n  confidenceInterval: [number, number];\r\n}\r\n\r\nexport interface EnvironmentalAdaptation {\r\n  difficultyAdjustment: number; // Adjustment based on environment (-3 to +3)\r\n  recommendedBreakFrequency: number; // Minutes between suggested breaks\r\n  visualOptimizations: {\r\n    contrastAdjustment: number; // -1 to +1\r\n    fontSizeAdjustment: number; // -1 to +1 (relative)\r\n    colorScheme: 'light' | 'dark' | 'auto';\r\n  };\r\n  audioOptimizations: {\r\n    enableSoundEffects: boolean;\r\n    volumeAdjustment: number; // 0-1\r\n  };\r\n}\r\n\r\nexport class EnvironmentalContextService {\r\n  private contextHistory: DetectedContext[] = [];\r\n  private performanceCache: Map<string, PerformanceByContext> = new Map();\r\n\r\n  /**\r\n   * Get comprehensive current environmental context\r\n   */\r\n  async getCurrentContext(): Promise<DetectedContext> {\r\n    const context: EnvironmentalContext = {\r\n      device: this.detectDevice(),\r\n      networkQuality: await this.assessNetworkQuality(),\r\n    };\r\n    \r\n    let confidence = 0.9; // Base confidence\r\n\r\n    // Enhanced mobile detection with additional context\r\n    if (context.device === 'mobile') {\r\n      try {\r\n        context.batteryLevel = await this.getBatteryLevel();\r\n        if (context.batteryLevel !== undefined) confidence += 0.05;\r\n      } catch (error) {\r\n        console.warn('Battery level detection failed:', error);\r\n      }\r\n    }\r\n\r\n    // Ambient conditions detection\r\n    try {\r\n      context.ambientNoise = await this.detectAmbientNoise();\r\n      context.lighting = await this.detectLightingConditions();\r\n      confidence += 0.05;\r\n    } catch (error) {\r\n      console.warn('Ambient conditions detection failed:', error);\r\n      confidence -= 0.1;\r\n    }\r\n\r\n    const detectedContext: DetectedContext = {\r\n      ...context,\r\n      confidence: Math.max(0.5, confidence),\r\n      detectionMethod: 'multi-sensor-fusion',\r\n      timestamp: new Date().toISOString()\r\n    };\r\n\r\n    // Store in history\r\n    this.contextHistory.push(detectedContext);\r\n    if (this.contextHistory.length > 100) {\r\n      this.contextHistory.shift(); // Keep only last 100 entries\r\n    }\r\n\r\n    return detectedContext;\r\n  }\r\n\r\n  /**\r\n   * Detect device type with enhanced accuracy\r\n   */\r\n  private detectDevice(): 'mobile' | 'desktop' | 'tablet' {\r\n    const userAgent = navigator.userAgent.toLowerCase();\r\n    const platform = navigator.platform?.toLowerCase() || '';\r\n    \r\n    // Check for mobile indicators\r\n    const mobileKeywords = ['mobile', 'android', 'iphone', 'ipod', 'blackberry', 'windows phone'];\r\n    const isMobile = mobileKeywords.some(keyword => userAgent.includes(keyword));\r\n    \r\n    // Check for tablet indicators\r\n    const tabletKeywords = ['ipad', 'tablet', 'kindle', 'playbook', 'silk'];\r\n    const isTablet = tabletKeywords.some(keyword => userAgent.includes(keyword));\r\n    \r\n    // Enhanced detection using screen size and touch capabilities\r\n    const screenWidth = window.screen.width;\r\n    const screenHeight = window.screen.height;\r\n    const maxDimension = Math.max(screenWidth, screenHeight);\r\n    const minDimension = Math.min(screenWidth, screenHeight);\r\n    \r\n    const hasTouchScreen = 'ontouchstart' in window || navigator.maxTouchPoints > 0;\r\n    \r\n    if (isTablet || (hasTouchScreen && minDimension >= 768 && maxDimension >= 1024)) {\r\n      return 'tablet';\r\n    }\r\n    \r\n    if (isMobile || (hasTouchScreen && maxDimension <= 736)) {\r\n      return 'mobile';\r\n    }\r\n    \r\n    // Additional checks for desktop\r\n    const isDesktop = platform.includes('win') || platform.includes('mac') || platform.includes('linux');\r\n    \r\n    return isDesktop || !hasTouchScreen ? 'desktop' : 'mobile';\r\n  }\r\n\r\n  /**\r\n   * Assess network quality with multiple metrics\r\n   */\r\n  private async assessNetworkQuality(): Promise<'excellent' | 'good' | 'poor' | 'offline'> {\r\n    if (!navigator.onLine) return 'offline';\r\n    \r\n    try {\r\n      // Use Connection API if available (Chrome/Edge)\r\n      const connection = (navigator as any).connection || (navigator as any).mozConnection || (navigator as any).webkitConnection;\r\n      \r\n      if (connection) {\r\n        const effectiveType = connection.effectiveType;\r\n        const downlink = connection.downlink;\r\n        const rtt = connection.rtt;\r\n        \r\n        // Advanced classification based on multiple metrics\r\n        if (effectiveType === '4g' && downlink > 10 && rtt < 100) {\r\n          return 'excellent';\r\n        } else if ((effectiveType === '4g' || effectiveType === '3g') && downlink > 2 && rtt < 300) {\r\n          return 'good';\r\n        } else if (downlink > 0.5 && rtt < 1000) {\r\n          return 'good';\r\n        } else {\r\n          return 'poor';\r\n        }\r\n      }\r\n      \r\n      // Fallback: Performance-based detection\r\n      return await this.performLatencyTest();\r\n    } catch (error) {\r\n      console.warn('Network quality assessment failed:', error);\r\n      return 'good'; // Default assumption\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Perform latency test for network quality\r\n   */\r\n  private async performLatencyTest(): Promise<'excellent' | 'good' | 'poor'> {\r\n    try {\r\n      const startTime = performance.now();\r\n      \r\n      // Test with a small request to avoid affecting user experience\r\n      const response = await fetch('/api/ping', { \r\n        method: 'HEAD',\r\n        cache: 'no-cache' \r\n      });\r\n      \r\n      const endTime = performance.now();\r\n      const latency = endTime - startTime;\r\n      \r\n      if (!response.ok) {\r\n        return 'poor';\r\n      }\r\n      \r\n      if (latency < 100) {\r\n        return 'excellent';\r\n      } else if (latency < 300) {\r\n        return 'good';\r\n      } else {\r\n        return 'poor';\r\n      }\r\n    } catch (error) {\r\n      console.warn('Latency test failed:', error);\r\n      return 'poor';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get battery level for mobile devices\r\n   */\r\n  private async getBatteryLevel(): Promise<number | undefined> {\r\n    try {\r\n      // Modern Battery API\r\n      const battery = await (navigator as any).getBattery?.();\r\n      if (battery && typeof battery.level === 'number') {\r\n        return battery.level;\r\n      }\r\n      \r\n      // Fallback methods for older devices\r\n      const batteryManager = (navigator as any).battery || (navigator as any).mozBattery || (navigator as any).webkitBattery;\r\n      if (batteryManager && typeof batteryManager.level === 'number') {\r\n        return batteryManager.level;\r\n      }\r\n      \r\n      return undefined;\r\n    } catch (error) {\r\n      console.warn('Battery level detection failed:', error);\r\n      return undefined;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Detect ambient noise level using audio API\r\n   */\r\n  private async detectAmbientNoise(): Promise<'quiet' | 'moderate' | 'noisy' | undefined> {\r\n    try {\r\n      // Request microphone access for noise detection\r\n      const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });\r\n      \r\n      return new Promise<'quiet' | 'moderate' | 'noisy' | undefined>((resolve) => {\r\n        const audioContext = new (window.AudioContext || (window as any).webkitAudioContext)();\r\n        const analyser = audioContext.createAnalyser();\r\n        const microphone = audioContext.createMediaStreamSource(stream);\r\n        \r\n        microphone.connect(analyser);\r\n        analyser.fftSize = 256;\r\n        \r\n        const bufferLength = analyser.frequencyBinCount;\r\n        const dataArray = new Uint8Array(bufferLength);\r\n        \r\n        let samples = 0;\r\n        let totalVolume = 0;\r\n        const maxSamples = 30; // Sample for 1 second at ~30fps\r\n        \r\n        const checkVolume = () => {\r\n          analyser.getByteFrequencyData(dataArray);\r\n          \r\n          const volume = dataArray.reduce((sum, value) => sum + value, 0) / bufferLength;\r\n          totalVolume += volume;\r\n          samples++;\r\n          \r\n          if (samples < maxSamples) {\r\n            setTimeout(checkVolume, 33); // ~30fps sampling\r\n          } else {\r\n            // Clean up\r\n            stream.getTracks().forEach(track => track.stop());\r\n            audioContext.close();\r\n            \r\n            const averageVolume = totalVolume / samples;\r\n            \r\n            // Classify noise level\r\n            if (averageVolume < 20) {\r\n              resolve('quiet');\r\n            } else if (averageVolume < 60) {\r\n              resolve('moderate');\r\n            } else {\r\n              resolve('noisy');\r\n            }\r\n          }\r\n        };\r\n        \r\n        checkVolume();\r\n      });\r\n    } catch (error) {\r\n      // Microphone access denied or not available\r\n      console.warn('Ambient noise detection failed:', error);\r\n      return undefined;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Detect lighting conditions using camera or screen brightness\r\n   */\r\n  private async detectLightingConditions(): Promise<'optimal' | 'dim' | 'bright' | undefined> {\r\n    try {\r\n      // Method 1: Screen brightness detection (if supported)\r\n      if ('screen' in navigator && 'brightness' in (navigator.screen as any)) {\r\n        const brightness = (navigator.screen as any).brightness;\r\n        if (brightness < 0.3) return 'dim';\r\n        if (brightness > 0.8) return 'bright';\r\n        return 'optimal';\r\n      }\r\n      \r\n      // Method 2: Camera-based ambient light detection\r\n      return await this.detectLightingViaCamera();\r\n    } catch (error) {\r\n      console.warn('Lighting detection failed:', error);\r\n      return undefined;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Detect lighting via camera sensor\r\n   */\r\n  private async detectLightingViaCamera(): Promise<'optimal' | 'dim' | 'bright' | undefined> {\r\n    try {\r\n      const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } });\r\n      \r\n      return new Promise<'optimal' | 'dim' | 'bright' | undefined>((resolve) => {\r\n        const video = document.createElement('video');\r\n        const canvas = document.createElement('canvas');\r\n        const ctx = canvas.getContext('2d');\r\n        \r\n        video.srcObject = stream;\r\n        video.play();\r\n        \r\n        video.addEventListener('loadedmetadata', () => {\r\n          canvas.width = video.videoWidth;\r\n          canvas.height = video.videoHeight;\r\n          \r\n          // Capture a frame after a short delay\r\n          setTimeout(() => {\r\n            if (ctx) {\r\n              ctx.drawImage(video, 0, 0);\r\n              const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\r\n              \r\n              // Calculate average brightness\r\n              let totalBrightness = 0;\r\n              const pixels = imageData.data;\r\n              \r\n              for (let i = 0; i < pixels.length; i += 4) {\r\n                const r = pixels[i];\r\n                const g = pixels[i + 1];\r\n                const b = pixels[i + 2];\r\n                \r\n                // Calculate luminance\r\n                const luminance = 0.299 * r + 0.587 * g + 0.114 * b;\r\n                totalBrightness += luminance;\r\n              }\r\n              \r\n              const averageBrightness = totalBrightness / (pixels.length / 4);\r\n              \r\n              // Clean up\r\n              stream.getTracks().forEach(track => track.stop());\r\n              \r\n              // Classify lighting\r\n              if (averageBrightness < 50) {\r\n                resolve('dim');\r\n              } else if (averageBrightness > 200) {\r\n                resolve('bright');\r\n              } else {\r\n                resolve('optimal');\r\n              }\r\n            }\r\n          }, 500);\r\n        });\r\n      });\r\n    } catch (error) {\r\n      console.warn('Camera-based lighting detection failed:', error);\r\n      return undefined;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Analyze contextual insights from historical data\r\n   */\r\n  analyzeContextualInsights(performanceHistory: any[]): ContextualInsights {\r\n    // Group performance by environmental factors\r\n    const contextGroups = this.groupPerformanceByContext(performanceHistory);\r\n    \r\n    // Find optimal conditions\r\n    const optimalConditions = this.findOptimalConditions(contextGroups);\r\n    \r\n    // Score current conditions\r\n    const currentContext = this.contextHistory[this.contextHistory.length - 1];\r\n    const currentScore = this.scoreCurrentConditions(currentContext, optimalConditions);\r\n    \r\n    // Generate improvement suggestions\r\n    const suggestions = this.generateImprovementSuggestions(currentContext, optimalConditions);\r\n    \r\n    return {\r\n      optimalStudyConditions: optimalConditions,\r\n      currentConditionScore: currentScore,\r\n      improvementSuggestions: suggestions,\r\n      historicalPerformance: Array.from(contextGroups.values())\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get environmental adaptation recommendations\r\n   */\r\n  getEnvironmentalAdaptations(context: EnvironmentalContext): EnvironmentalAdaptation {\r\n    let difficultyAdjustment = 0;\r\n    let breakFrequency = 25; // Default pomodoro technique\r\n    \r\n    const visualOpts = {\r\n      contrastAdjustment: 0,\r\n      fontSizeAdjustment: 0,\r\n      colorScheme: 'auto' as const\r\n    };\r\n    \r\n    const audioOpts = {\r\n      enableSoundEffects: true,\r\n      volumeAdjustment: 0.7\r\n    };\r\n\r\n    // Device-based adaptations\r\n    switch (context.device) {\r\n      case 'mobile':\r\n        difficultyAdjustment -= 0.5; // Slightly easier on mobile\r\n        breakFrequency = 20; // More frequent breaks\r\n        visualOpts.fontSizeAdjustment = 0.2; // Larger text\r\n        break;\r\n        \r\n      case 'tablet':\r\n        breakFrequency = 30;\r\n        visualOpts.fontSizeAdjustment = 0.1;\r\n        break;\r\n        \r\n      case 'desktop':\r\n        breakFrequency = 45; // Longer sessions on desktop\r\n        break;\r\n    }\r\n\r\n    // Network quality adaptations\r\n    switch (context.networkQuality) {\r\n      case 'poor':\r\n      case 'offline':\r\n        difficultyAdjustment -= 1.0; // Significantly easier for poor connection\r\n        audioOpts.enableSoundEffects = false; // Disable to reduce data usage\r\n        break;\r\n        \r\n      case 'good':\r\n        difficultyAdjustment -= 0.2;\r\n        break;\r\n    }\r\n\r\n    // Battery level adaptations (mobile)\r\n    if (context.batteryLevel !== undefined && context.batteryLevel < 0.3) {\r\n      difficultyAdjustment -= 0.5; // Easier when battery is low\r\n      breakFrequency = 15; // More frequent breaks to reduce usage\r\n      visualOpts.colorScheme = 'dark'; // Dark mode saves battery\r\n    }\r\n\r\n    // Ambient noise adaptations\r\n    switch (context.ambientNoise) {\r\n      case 'noisy':\r\n        difficultyAdjustment -= 0.3; // Harder to concentrate in noise\r\n        audioOpts.enableSoundEffects = false; // Disable competing audio\r\n        break;\r\n        \r\n      case 'quiet':\r\n        audioOpts.volumeAdjustment = 0.5; // Lower volume in quiet environments\r\n        break;\r\n    }\r\n\r\n    // Lighting adaptations\r\n    switch (context.lighting) {\r\n      case 'dim':\r\n        visualOpts.contrastAdjustment = 0.3; // Higher contrast\r\n        visualOpts.colorScheme = 'dark'; // Better for dim environments\r\n        difficultyAdjustment -= 0.2; // Slightly easier in poor lighting\r\n        break;\r\n        \r\n      case 'bright':\r\n        visualOpts.contrastAdjustment = -0.2; // Lower contrast\r\n        visualOpts.colorScheme = 'light'; // Better for bright environments\r\n        break;\r\n        \r\n      case 'optimal':\r\n        // No adjustments needed\r\n        break;\r\n    }\r\n\r\n    return {\r\n      difficultyAdjustment: Math.max(-3, Math.min(3, difficultyAdjustment)),\r\n      recommendedBreakFrequency: breakFrequency,\r\n      visualOptimizations: visualOpts,\r\n      audioOptimizations: audioOpts\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Track context changes and notify of significant changes\r\n   */\r\n  async trackContextChanges(): Promise<void> {\r\n    const previousContext = this.contextHistory[this.contextHistory.length - 1];\r\n    const currentContext = await this.getCurrentContext();\r\n    \r\n    if (previousContext && this.hasSignificantContextChange(previousContext, currentContext)) {\r\n      // Emit context change event\r\n      this.onContextChange?.(currentContext, previousContext);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check for significant context changes\r\n   */\r\n  private hasSignificantContextChange(previous: DetectedContext, current: DetectedContext): boolean {\r\n    // Device change (rare but significant)\r\n    if (previous.device !== current.device) return true;\r\n    \r\n    // Network quality change\r\n    if (previous.networkQuality !== current.networkQuality) return true;\r\n    \r\n    // Battery level change > 20%\r\n    if (previous.batteryLevel && current.batteryLevel) {\r\n      if (Math.abs(previous.batteryLevel - current.batteryLevel) > 0.2) return true;\r\n    }\r\n    \r\n    // Ambient conditions change\r\n    if (previous.ambientNoise !== current.ambientNoise) return true;\r\n    if (previous.lighting !== current.lighting) return true;\r\n    \r\n    return false;\r\n  }\r\n\r\n  // Helper methods for contextual analysis\r\n\r\n  private groupPerformanceByContext(performanceHistory: any[]): Map<string, PerformanceByContext> {\r\n    const groups = new Map<string, PerformanceByContext>();\r\n    \r\n    // This would group performance data by environmental context\r\n    // Implementation would depend on your performance data structure\r\n    \r\n    return groups;\r\n  }\r\n\r\n  private findOptimalConditions(contextGroups: Map<string, PerformanceByContext>): EnvironmentalContext {\r\n    // Analyze performance groups to find optimal conditions\r\n    // This is a simplified version - real implementation would be more sophisticated\r\n    \r\n    return {\r\n      device: 'desktop', // Generally best performance\r\n      networkQuality: 'excellent',\r\n      batteryLevel: undefined, // Not applicable for optimal\r\n      ambientNoise: 'quiet',\r\n      lighting: 'optimal'\r\n    };\r\n  }\r\n\r\n  private scoreCurrentConditions(current: DetectedContext | undefined, optimal: EnvironmentalContext): number {\r\n    if (!current) return 0.5;\r\n    \r\n    let score = 1.0;\r\n    \r\n    // Score each factor\r\n    if (current.device !== optimal.device) score -= 0.1;\r\n    if (current.networkQuality !== optimal.networkQuality) {\r\n      score -= current.networkQuality === 'poor' ? 0.3 : 0.1;\r\n    }\r\n    if (current.ambientNoise !== optimal.ambientNoise) score -= 0.15;\r\n    if (current.lighting !== optimal.lighting) score -= 0.1;\r\n    \r\n    // Battery penalty for mobile\r\n    if (current.device === 'mobile' && current.batteryLevel && current.batteryLevel < 0.3) {\r\n      score -= 0.2;\r\n    }\r\n    \r\n    return Math.max(0, score);\r\n  }\r\n\r\n  private generateImprovementSuggestions(current: DetectedContext | undefined, optimal: EnvironmentalContext): string[] {\r\n    const suggestions: string[] = [];\r\n    \r\n    if (!current) return suggestions;\r\n    \r\n    if (current.networkQuality === 'poor') {\r\n      suggestions.push('Consider switching to a better network connection for optimal performance');\r\n    }\r\n    \r\n    if (current.ambientNoise === 'noisy') {\r\n      suggestions.push('Find a quieter environment or use noise-canceling headphones');\r\n    }\r\n    \r\n    if (current.lighting === 'dim') {\r\n      suggestions.push('Improve lighting conditions for better visual clarity');\r\n    } else if (current.lighting === 'bright') {\r\n      suggestions.push('Reduce screen glare or move to a less bright environment');\r\n    }\r\n    \r\n    if (current.device === 'mobile' && current.batteryLevel && current.batteryLevel < 0.3) {\r\n      suggestions.push('Charge your device or switch to a desktop for longer study sessions');\r\n    }\r\n    \r\n    return suggestions;\r\n  }\r\n\r\n  // Event handler for context changes (can be overridden)\r\n  public onContextChange?: (current: DetectedContext, previous: DetectedContext) => void;\r\n}","/**\r\n * StorageManager\r\n * - Client-side storage utilities for usage metrics and maintenance\r\n * - Works over Dexie tables (IndexedDB) and navigator.storage.estimate()\r\n *\r\n * Responsibilities:\r\n * - Compute storage usage (media table bytes/count + DB row counts)\r\n * - Purge unreferenced media (based on CardRow.mediaRefs)\r\n * - Purge all media (dangerous, UI must confirm)\r\n */\r\n\r\nimport db, { ensureDBOpen, type MediaRow, type CardRow } from '../../data/db';\r\n\r\nexport type BrowserStorageEstimate = {\r\n  quota?: number;         // Browser-estimated total quota (bytes)\r\n  usage?: number;         // Browser-estimated used bytes (bytes)\r\n  usageDetails?: Record<string, number>;\r\n};\r\n\r\nexport type StorageUsage = {\r\n  // Media\r\n  mediaBytes: number;\r\n  mediaCount: number;\r\n\r\n  // DB counts (best-effort, not bytes)\r\n  decksCount: number;\r\n  cardsCount: number;\r\n  reviewsCount: number;\r\n  achievementsCount: number;\r\n  challengesCount: number;\r\n\r\n  // Browser estimate (if available)\r\n  estimate?: BrowserStorageEstimate;\r\n  // Timestamp\r\n  measuredAt: number;\r\n};\r\n\r\nexport type PurgeReport = {\r\n  removedCount: number;\r\n  removedBytes: number;\r\n  keptCount: number;\r\n};\r\n\r\n/**\r\n * Helper: sums byteLength safely\r\n */\r\nfunction safeByteLength(m?: MediaRow | null): number {\r\n  if (!m) return 0;\r\n  if (typeof m.byteLength === 'number') return m.byteLength;\r\n  try {\r\n    return m.blob ? m.blob.size : 0;\r\n  } catch {\r\n    return 0;\r\n  }\r\n}\r\n\r\nexport class StorageManager {\r\n  /**\r\n   * Compute overall usage snapshot.\r\n   * - mediaBytes/mediaCount from media table\r\n   * - Row counts from other tables (for visibility)\r\n   * - navigator.storage.estimate() if available\r\n   */\r\n  async getUsage(): Promise<StorageUsage> {\r\n    await ensureDBOpen();\r\n\r\n    const [mediaRows, decksCount, cardsCount, reviewsCount, achievementsCount, challengesCount] =\r\n      await Promise.all([\r\n        db.media.toArray(),\r\n        db.decks.count(),\r\n        db.cards.count(),\r\n        db.reviews.count(),\r\n        db.achievements.count(),\r\n        db.challenges.count(),\r\n      ]);\r\n\r\n    const mediaBytes = mediaRows.reduce((sum, row) => sum + safeByteLength(row), 0);\r\n    const mediaCount = mediaRows.length;\r\n\r\n    let estimate: BrowserStorageEstimate | undefined;\r\n    try {\r\n      if (navigator?.storage?.estimate) {\r\n        const est = await navigator.storage.estimate();\r\n        const details = (est as any).usageDetails as Record<string, number> | undefined;\r\n        const browserEstimate: BrowserStorageEstimate = {\r\n          quota: est.quota,\r\n          usage: est.usage,\r\n          ...(details ? { usageDetails: Object.fromEntries(Object.entries(details)) } : {}),\r\n        };\r\n        estimate = browserEstimate;\r\n      }\r\n    } catch {\r\n      // ignore if not supported\r\n    }\r\n\r\n    return {\r\n      mediaBytes,\r\n      mediaCount,\r\n      decksCount,\r\n      cardsCount,\r\n      reviewsCount,\r\n      achievementsCount,\r\n      challengesCount,\r\n      estimate,\r\n      measuredAt: Date.now(),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Purge any media rows that are not referenced by any card's mediaRefs.\r\n   * Returns a summary report with removed/kept counts and bytes freed.\r\n   */\r\n  async purgeUnusedMedia(): Promise<PurgeReport> {\r\n    await ensureDBOpen();\r\n\r\n    const [cards, mediaRows] = await Promise.all([db.cards.toArray(), db.media.toArray()]);\r\n\r\n    const referenced = this.collectReferencedMedia(cards);\r\n    let removedCount = 0;\r\n    let removedBytes = 0;\r\n\r\n    // Iterate and remove unreferenced\r\n    for (const m of mediaRows) {\r\n      if (!referenced.has(m.mediaHash)) {\r\n        removedBytes += safeByteLength(m);\r\n        await db.media.delete(m.mediaHash);\r\n        removedCount++;\r\n      }\r\n    }\r\n\r\n    return {\r\n      removedCount,\r\n      removedBytes,\r\n      keptCount: mediaRows.length - removedCount,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Purge all media rows. Dangerous: callers must confirm with user.\r\n   * Returns removed count/bytes.\r\n   */\r\n  async purgeAllMedia(): Promise<PurgeReport> {\r\n    await ensureDBOpen();\r\n\r\n    const mediaRows = await db.media.toArray();\r\n    const removedBytes = mediaRows.reduce((sum, row) => sum + safeByteLength(row), 0);\r\n    const removedCount = mediaRows.length;\r\n\r\n    await db.media.clear();\r\n\r\n    return {\r\n      removedCount,\r\n      removedBytes,\r\n      keptCount: 0,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Collect referenced media hashes from CardRow.mediaRefs (string[])\r\n   */\r\n  private collectReferencedMedia(cards: CardRow[]): Set<string> {\r\n    const set = new Set<string>();\r\n    for (const c of cards) {\r\n      if (Array.isArray(c.mediaRefs)) {\r\n        for (const ref of c.mediaRefs) {\r\n          if (typeof ref === 'string' && ref.length > 0) set.add(ref);\r\n        }\r\n      }\r\n    }\r\n    return set;\r\n  }\r\n}\r\n\r\n// Singleton export\r\nexport const storageManager = new StorageManager();\r\nexport default StorageManager;"],"names":["ErrorTrackingService","config","errors","sessionId","initialized","constructor","this","maxStoredErrors","enableConsoleLogging","enableLocalStorage","environment","generateSessionId","loadStoredErrors","setupGlobalErrorHandlers","logInfo","logError","error","context","errorReport","createErrorReport","recordError","logWarning","message","getErrors","clearErrors","localStorage","removeItem","getErrorStats","oneHourAgo","Date","now","stats","total","length","byLevel","warning","info","recent","forEach","level","timestamp","getTime","exportErrors","JSON","stringify","Error","stack","id","generateErrorId","toISOString","userAgent","navigator","url","window","location","href","unshift","slice","console","warn","log","setItem","e","apiEndpoint","sendToRemote","catch","stored","getItem","parsedErrors","parse","Array","isArray","addEventListener","event","filename","lineno","colno","type","reason","React","originalErrorHandler","args","includes","apply","fetch","method","headers","apiKey","Authorization","body","Math","random","toString","substr","errorTracker","Component","StudyMasterDB","Dexie","settings","users","decks","cards","reviews","media","achievements","challenges","leaderboardCache","syncQueue","super","version","stores","table","on","async","get","add","theme","shortcuts","featureFlags","encryptionEnabled","createdAt","updatedAt","err","String","scope","close","_dbInstance","getDB","ensureDBOpen","db","isOpen","open","Proxy","_target","prop","receiver","inst","value","Reflect","bind","DEMO_USER_STATS","totalXP","currentLevelXP","nextLevelXP","cardsStudied","studyTime","accuracy","currentStreak","longestStreak","coins","gems","lastStudyDate","joinDate","DEMO_ACHIEVEMENTS","name","description","icon","unlockedAt","category","ENHANCED_MONTHLY_CHALLENGES","target","current","reward","xp","expiresAt","DEMO_CHALLENGES","DEMO_LEADERBOARD","global","userId","username","score","rank","change","friends","weekly","monthly","UserDataService","baseUrl","isDemoUser","user","tokenType","email","getUserStats","debugLogger","userRecord","pb","collection","getOne","fields","total_xp","last_active","created","pocketbaseError","response","token","ok","data","json","apiError","generatePersonalizedMockStats","getUserActivity","days","generateDemoActivity","generatePersonalizedActivity","getUserAchievements","generatePersonalizedAchievements","getUserChallenges","generatePersonalizedChallenges","getLeaderboardData","generatePersonalizedLeaderboard","getPerformanceMetrics","generateDemoPerformanceMetrics","generatePersonalizedPerformanceMetrics","getCompleteUserProfile","activity","performance","Promise","all","resetAllUserData","userHash","hashString","daysSinceJoin","floor","activities","i","date","dayHash","toDateString","push","split","xpGained","reverse","baseAchievements","challenge","progressHash","userScore","userRank","leaderboard","weeklyProgress","goal","monthlyProgress","decksCompleted","studyPattern","preferredTime","averageSessionLength","studyFrequency","str","hash","charCodeAt","abs","userDataService","RealTimeDataService","updateInterval","subscribers","Map","intervalId","activeInstances","subscribe","dataType","callback","has","set","callbacks","index","indexOf","splice","notify","getGlobalLearningStats","fetchFromMultipleSources","fetchFromDuolingoAPI","fetchFromKhanAcademyAPI","fetchFromCourseraAPI","fetchFromEducationalDataAPI","generateEnhancedGlobalStats","getEducationalTrends","trends","fetchEducationalTrendsFromAPIs","generateEnhancedEducationalTrends","getLiveUserMetrics","metrics","fetchLiveMetricsFromAPIs","generateEnhancedLiveMetrics","getMarketInsights","insights","fetchMarketInsightsFromAPIs","generateEnhancedMarketInsights","Accept","fetchers","successfulResults","allSettled","map","fetcher","filter","result","status","mergeDataSources","sources","hour","getHours","dayOfWeek","getDay","timeMultiplier","getTimeBasedMultiplier","baseLearners","baseCardsToday","baseActiveSessions","totalLearners","cardsStudiedToday","activeStudySessions","languagesBeingLearned","topSubjects","learners","studyTimeToday","lastUpdated","popularSubjects","subject","growth","learningMethods","effectiveness","usage","studyPatterns","peakHours","generatePeakHours","weeklyTrends","generateWeeklyTrends","onlineUsers","studyingSessions","completedToday","averageAccuracy","topPerformers","country","skillDemand","skill","demand","industryTrends","industry","skills","certificationValue","cert","popularity","hourMultiplier","baseSessions","day","sessions","startRealTimeUpdates","setInterval","globalStats","liveMetrics","marketInsights","stopRealTimeUpdates","max","clearInterval","forceStopRealTimeUpdates","clear","realTimeDataService","apiClient","axios","create","baseURL","withCredentials","uamsApiService","deckId","post","sessionState","cardId","UnifiedQueueManager","lookaheadBufferSize","emergencyBufferSize","challengeReserveSize","refreshThreshold","maxSessionDurationMinutes","adaptiveRefreshInterval","initializeSession","getNextCard","processCardResponse","EnvironmentalContextService","contextHistory","performanceCache","getCurrentContext","device","detectDevice","networkQuality","assessNetworkQuality","confidence","batteryLevel","getBatteryLevel","ambientNoise","detectAmbientNoise","lighting","detectLightingConditions","detectedContext","detectionMethod","shift","toLowerCase","platform","isMobile","some","keyword","isTablet","screenWidth","screen","width","screenHeight","height","maxDimension","minDimension","min","hasTouchScreen","maxTouchPoints","onLine","connection","mozConnection","webkitConnection","effectiveType","downlink","rtt","performLatencyTest","startTime","cache","latency","battery","getBattery","batteryManager","mozBattery","webkitBattery","stream","mediaDevices","getUserMedia","audio","video","resolve","audioContext","AudioContext","webkitAudioContext","analyser","createAnalyser","createMediaStreamSource","connect","fftSize","bufferLength","frequencyBinCount","dataArray","Uint8Array","samples","totalVolume","maxSamples","checkVolume","getByteFrequencyData","volume","reduce","sum","setTimeout","getTracks","track","stop","averageVolume","brightness","detectLightingViaCamera","facingMode","document","createElement","canvas","ctx","getContext","srcObject","play","videoWidth","videoHeight","drawImage","totalBrightness","pixels","getImageData","averageBrightness","analyzeContextualInsights","performanceHistory","contextGroups","groupPerformanceByContext","optimalConditions","findOptimalConditions","currentContext","optimalStudyConditions","currentConditionScore","scoreCurrentConditions","improvementSuggestions","generateImprovementSuggestions","historicalPerformance","from","values","getEnvironmentalAdaptations","difficultyAdjustment","breakFrequency","visualOpts","contrastAdjustment","fontSizeAdjustment","colorScheme","audioOpts","enableSoundEffects","volumeAdjustment","recommendedBreakFrequency","visualOptimizations","audioOptimizations","trackContextChanges","previousContext","hasSignificantContextChange","onContextChange","previous","optimal","suggestions","safeByteLength","m","byteLength","blob","size","StorageManager","getUsage","mediaRows","decksCount","cardsCount","reviewsCount","achievementsCount","challengesCount","toArray","count","mediaBytes","row","mediaCount","estimate","storage","est","details","usageDetails","quota","Object","fromEntries","entries","measuredAt","purgeUnusedMedia","referenced","collectReferencedMedia","removedCount","removedBytes","mediaHash","delete","keptCount","purgeAllMedia","Set","c","mediaRefs","ref","storageManager"],"mappings":"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"}