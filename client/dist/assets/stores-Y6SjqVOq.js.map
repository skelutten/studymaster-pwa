{"version":3,"mappings":"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","names":["validationRules","message","value","min","max","pattern","validateField","rules","errors","rule","validateForm","data","results","field","fieldRules","sanitizeInput","input","validationSchemas","convertPocketbaseUser","pocketbaseUser","debugLogger","convertedUser","error","fallbackUser","validateSignUpInputs","email","password","username","validationResults","validationErrors","_","result","validateSignInInputs","createPocketBaseUserData","handleSignUpError","handleSignInError","isDemoLogin","performPocketBaseAuth","sanitizedEmail","pb","updateUserLastActive","userId","updateError","useAuthStore","create","set","get","userData","newUser","authData","user","timeoutId","errorMessage","newPassword","currentState","updates","updateData","signIn","signUp","signOut","token","record","useThemeStore","persist","theme","systemTheme","newTheme","e","newSystemTheme","state","mockAchievements","mockChallenges","mockLeaderboards","calculateLevel","xp","calculateXPToNextLevel","level","getInitialUserStats","getDemoUserStats","useGamificationStore","stats","newStats","achievementId","userAchievements","ua","streak","challengeId","userChallengeParticipations","p","progress","activeChallenges","challenge","participation","xpGained","_coinsGained","reward","gold","diamonds","userStats","isDemo","milestoneId","completed","weekData","w","week","c","goalId","contribution","cardsStudied","correctAnswers","milestoneBonus","newXP","newLevel","newXPToNextLevel","createNewCard","frontContent","backContent","cardType","mediaRefs","defaultDeckSettings","cleanFieldContent","content","detectBestFieldCombination","sampleFields","fieldCount","combinations","front","back","score","validPairs","fields","normalizedScore","a","b","parseApkgFile","file","JSZip","initSqlJs","__vitePreload","n","SQL","arrayBuffer","dbFile","dbArrayBuffer","db","deckQuery","deckName","decksJson","decks","deckIds","id","notesQuery","cards","sampleSize","i","frontIndex","backIndex","row","useDeckStore","deckData","deck","_deletedCards","remainingCards","deckId","cardData","card","updatedCards","existingCards","cardKey","cardsData","existingCardSet","uniqueCardsData","cardId","newCards","targetDeckId","setImportProgress","resetImportProgress","fileName","name","d","uniqueCards","seenCards","batchSize","successfulImports","totalCards","batch","batchCards","cardProgress","resolve","cardError","originalCard","individualError","text","separator","cleanText","lines","line","validCards","skippedLines","parts","part","uniqueValidCards","addedCards","existingTitles","title","exampleDecks","loading","deckCards","uniqueCardsMap","duplicatesRemoved","status","studyCards","studyCardIds","currentCardIndex","sessionStats","resetCards","currentStudySession","restOfState","sessionToPersist","useCurrentCard","store","session","currentCardId"],"ignoreList":[],"sources":["../../src/utils/validation.ts","../../src/stores/authStore.ts","../../src/stores/themeStore.ts","../../src/stores/gamificationStore.ts","../../src/utils/cardDefaults.ts","../../src/stores/deckStore.ts"],"sourcesContent":["// Input validation utilities\r\n\r\nexport interface ValidationResult {\r\n  isValid: boolean\r\n  errors: string[]\r\n}\r\n\r\nexport interface ValidationRule {\r\n  test: (value: string) => boolean\r\n  message: string\r\n}\r\n\r\n// Common validation rules\r\nexport const validationRules = {\r\n  required: (message = 'This field is required'): ValidationRule => ({\r\n    test: (value: string) => value.trim().length > 0,\r\n    message\r\n  }),\r\n  \r\n  minLength: (min: number, message?: string): ValidationRule => ({\r\n    test: (value: string) => value.length >= min,\r\n    message: message || `Must be at least ${min} characters long`\r\n  }),\r\n  \r\n  maxLength: (max: number, message?: string): ValidationRule => ({\r\n    test: (value: string) => value.length <= max,\r\n    message: message || `Must be no more than ${max} characters long`\r\n  }),\r\n  \r\n  email: (message = 'Please enter a valid email address'): ValidationRule => ({\r\n    test: (value: string) => {\r\n      const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/\r\n      return emailRegex.test(value)\r\n    },\r\n    message\r\n  }),\r\n  \r\n  password: (message = 'Password must be at least 8 characters with uppercase, lowercase, number, and special character'): ValidationRule => ({\r\n    test: (value: string) => {\r\n      // At least 8 characters, one uppercase, one lowercase, one number, one special character\r\n      const passwordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&])[A-Za-z\\d@$!%*?&]{8,}$/\r\n      return passwordRegex.test(value)\r\n    },\r\n    message\r\n  }),\r\n  \r\n  username: (message = 'Username must be 3-50 characters and contain only letters, numbers, and underscores'): ValidationRule => ({\r\n    test: (value: string) => {\r\n      const usernameRegex = /^[a-zA-Z0-9_]{3,50}$/\r\n      return usernameRegex.test(value)\r\n    },\r\n    message\r\n  }),\r\n  \r\n  noXSS: (message = 'Invalid characters detected'): ValidationRule => ({\r\n    test: (value: string) => {\r\n      // Basic XSS prevention - reject common script tags and javascript protocols\r\n      const xssRegex = /<script|javascript:|data:|vbscript:|onload=|onerror=/i\r\n      return !xssRegex.test(value)\r\n    },\r\n    message\r\n  }),\r\n  \r\n  noSQLInjection: (message = 'Invalid characters detected'): ValidationRule => ({\r\n    test: (value: string) => {\r\n      // Basic SQL injection prevention\r\n      const patterns = [\r\n        /'/, // single quotes\r\n        /\\\\'/, // escaped quotes\r\n        /;/, // semicolons\r\n        /--/, // SQL comments\r\n        /\\/\\*/, // block comments start\r\n        /(union|select|insert|delete|update|drop|create|alter|exec|execute)\\s/i // SQL keywords\r\n      ]\r\n      const hasSQLInjection = patterns.some(pattern => pattern.test(value))\r\n      return !hasSQLInjection\r\n    },\r\n    message\r\n  })\r\n}\r\n\r\n// Validate a single field\r\nexport function validateField(value: string, rules: ValidationRule[]): ValidationResult {\r\n  const errors: string[] = []\r\n  \r\n  for (const rule of rules) {\r\n    if (!rule.test(value)) {\r\n      errors.push(rule.message)\r\n    }\r\n  }\r\n  \r\n  return {\r\n    isValid: errors.length === 0,\r\n    errors\r\n  }\r\n}\r\n\r\n// Validate multiple fields\r\nexport function validateForm(data: Record<string, string>, rules: Record<string, ValidationRule[]>): Record<string, ValidationResult> {\r\n  const results: Record<string, ValidationResult> = {}\r\n  \r\n  for (const [field, fieldRules] of Object.entries(rules)) {\r\n    const value = data[field] || ''\r\n    results[field] = validateField(value, fieldRules)\r\n  }\r\n  \r\n  return results\r\n}\r\n\r\n// Check if all validation results are valid\r\nexport function isFormValid(results: Record<string, ValidationResult>): boolean {\r\n  return Object.values(results).every(result => result.isValid)\r\n}\r\n\r\n// Sanitize input to prevent XSS\r\nexport function sanitizeInput(input: string): string {\r\n  return input\r\n    .replace(/</g, '&lt;')\r\n    .replace(/>/g, '&gt;')\r\n    .replace(/\"/g, '&quot;')\r\n    .replace(/'/g, '&#x27;')\r\n    .replace(/\\//g, '&#x2F;')\r\n    .trim()\r\n}\r\n\r\n// Validate and sanitize text content\r\nexport function validateAndSanitizeText(text: string, maxLength = 5000): { isValid: boolean; sanitized: string; errors: string[] } {\r\n  const validation = validateField(text, [\r\n    validationRules.required(),\r\n    validationRules.maxLength(maxLength),\r\n    validationRules.noXSS(),\r\n    validationRules.noSQLInjection()\r\n  ])\r\n  \r\n  return {\r\n    isValid: validation.isValid,\r\n    sanitized: sanitizeInput(text),\r\n    errors: validation.errors\r\n  }\r\n}\r\n\r\n// Pre-defined validation schemas for common forms\r\nexport const validationSchemas = {\r\n  signUp: {\r\n    email: [validationRules.required(), validationRules.email()],\r\n    password: [validationRules.required(), validationRules.password()],\r\n    username: [validationRules.required(), validationRules.username()]\r\n  },\r\n  \r\n  signIn: {\r\n    email: [validationRules.required()],\r\n    password: [validationRules.required(), validationRules.minLength(6)]\r\n  },\r\n  \r\n  profile: {\r\n    username: [validationRules.required(), validationRules.username()],\r\n    email: [validationRules.required(), validationRules.email()]\r\n  },\r\n  \r\n  card: {\r\n    front_content: [validationRules.required(), validationRules.maxLength(5000), validationRules.noXSS()],\r\n    back_content: [validationRules.required(), validationRules.maxLength(5000), validationRules.noXSS()]\r\n  },\r\n  \r\n  deck: {\r\n    title: [validationRules.required(), validationRules.maxLength(200), validationRules.noXSS()],\r\n    description: [validationRules.maxLength(1000), validationRules.noXSS()]\r\n  }\r\n}","import { create } from 'zustand'\r\nimport { pb } from '../lib/pocketbase'\r\nimport type { User } from '../types'\r\nimport { debugLogger } from '../utils/debugLogger'\r\nimport { validateForm, validationSchemas, sanitizeInput } from '../utils/validation'\r\n\r\ninterface AuthState {\r\n  user: User | null\r\n  session: { record: Record<string, unknown>; token: string } | null // PocketBase auth record\r\n  isAuthenticated: boolean\r\n  isLoading: boolean\r\n  error: string | null\r\n  \r\n  // Primary Actions (unified interface for components)\r\n  login: (email: string, password: string) => Promise<void>\r\n  register: (email: string, username: string, password: string) => Promise<void>\r\n  logout: () => void\r\n  updateUser: (updates: Partial<User>) => void\r\n  \r\n  // PocketBase-specific Actions\r\n  signUp: (email: string, password: string, username: string) => Promise<void>\r\n  signIn: (email: string, password: string) => Promise<void>\r\n  signOut: () => Promise<void>\r\n  resetPassword: (email: string) => Promise<void>\r\n  updatePassword: (newPassword: string) => Promise<void>\r\n  updateProfile: (updates: Partial<User>) => Promise<void>\r\n  clearError: () => void\r\n  initializeAuth: () => Promise<void>\r\n}\r\n\r\n// Helper function to convert PocketBase user to our User type\r\nconst convertPocketbaseUser = async (pocketbaseUser: Record<string, unknown>): Promise<User> => {\r\n  debugLogger.log('[POCKETBASE_AUTH_STORE]', 'START - convertPocketbaseUser', {\r\n    userId: pocketbaseUser.id,\r\n    email: pocketbaseUser.email,\r\n    username: pocketbaseUser.username\r\n  });\r\n\r\n  try {\r\n    const convertedUser = {\r\n      id: pocketbaseUser.id,\r\n      email: pocketbaseUser.email,\r\n      username: pocketbaseUser.username || pocketbaseUser.email?.split('@')[0] || 'User',\r\n      level: pocketbaseUser.level || 1,\r\n      totalXp: pocketbaseUser.total_xp || 0,\r\n      coins: pocketbaseUser.coins || 100,\r\n      gems: pocketbaseUser.gems || 10,\r\n      createdAt: pocketbaseUser.created || new Date().toISOString(),\r\n      lastActive: pocketbaseUser.last_active || new Date().toISOString(),\r\n      preferences: pocketbaseUser.preferences || {\r\n        theme: 'system' as const,\r\n        language: 'en',\r\n        notifications: true,\r\n        soundEffects: true,\r\n        dailyGoal: 50,\r\n        timezone: 'UTC'\r\n      }\r\n    };\r\n\r\n    debugLogger.log('[POCKETBASE_AUTH_STORE]', 'END - convertPocketbaseUser', convertedUser);\r\n    return convertedUser;\r\n  } catch (error) {\r\n    debugLogger.error('[POCKETBASE_AUTH_STORE]', 'Error in convertPocketbaseUser', {\r\n      error,\r\n      stack: error instanceof Error ? error.stack : undefined,\r\n      userId: pocketbaseUser.id\r\n    });\r\n    \r\n    // Fallback: create a basic user object\r\n    const fallbackUser = {\r\n      id: pocketbaseUser.id,\r\n      email: pocketbaseUser.email || 'unknown@example.com',\r\n      username: pocketbaseUser.username || pocketbaseUser.email?.split('@')[0] || 'User',\r\n      level: 1,\r\n      totalXp: 0,\r\n      coins: 100,\r\n      gems: 10,\r\n      createdAt: pocketbaseUser.created || new Date().toISOString(),\r\n      lastActive: new Date().toISOString(),\r\n      preferences: {\r\n        theme: 'system' as const,\r\n        language: 'en',\r\n        notifications: true,\r\n        soundEffects: true,\r\n        dailyGoal: 50,\r\n        timezone: 'UTC'\r\n      }\r\n    };\r\n\r\n    debugLogger.log('[POCKETBASE_AUTH_STORE]', 'END - convertPocketbaseUser (fallback)', fallbackUser);\r\n    return fallbackUser;\r\n  }\r\n}\r\n\r\n// Helper functions for authentication operations\r\nconst validateSignUpInputs = (email: string, password: string, username: string) => {\r\n  const validationResults = validateForm(\r\n    { email, password, username },\r\n    validationSchemas.signUp\r\n  )\r\n  \r\n  const validationErrors = Object.entries(validationResults)\r\n    .filter(([_, result]) => !result.isValid)\r\n    .map(([field, result]) => `${field}: ${result.errors.join(', ')}`)\r\n  \r\n  if (validationErrors.length > 0) {\r\n    throw new Error(validationErrors.join('; '))\r\n  }\r\n}\r\n\r\nconst validateSignInInputs = (email: string, password: string) => {\r\n  const validationResults = validateForm(\r\n    { email, password },\r\n    validationSchemas.signIn\r\n  )\r\n  \r\n  const validationErrors = Object.entries(validationResults)\r\n    .filter(([_, result]) => !result.isValid)\r\n    .map(([field, result]) => `${field}: ${result.errors.join(', ')}`)\r\n  \r\n  if (validationErrors.length > 0) {\r\n    throw new Error(validationErrors.join('; '))\r\n  }\r\n}\r\n\r\nconst createPocketBaseUserData = (email: string, username: string, password: string) => ({\r\n  username: sanitizeInput(username),\r\n  email: sanitizeInput(email),\r\n  password,\r\n  passwordConfirm: password,\r\n  level: 1,\r\n  total_xp: 0,\r\n  coins: 100,\r\n  gems: 10,\r\n  last_active: new Date().toISOString(),\r\n  preferences: {\r\n    theme: 'system',\r\n    language: 'en',\r\n    notifications: true,\r\n    soundEffects: true,\r\n    dailyGoal: 50,\r\n    timezone: 'UTC'\r\n  }\r\n})\r\n\r\nconst createDemoUser = (): User => ({\r\n  id: 'demo-user',\r\n  email: 'demo@studymaster.app',\r\n  username: 'DemoUser',\r\n  level: 5,\r\n  totalXp: 2500,\r\n  coins: 150,\r\n  gems: 25,\r\n  createdAt: new Date().toISOString(),\r\n  lastActive: new Date().toISOString(),\r\n  preferences: {\r\n    theme: 'system',\r\n    language: 'en',\r\n    notifications: true,\r\n    soundEffects: true,\r\n    dailyGoal: 50,\r\n    timezone: 'UTC'\r\n  }\r\n})\r\n\r\nconst handleSignUpError = (error: unknown): string => {\r\n  if (!(error instanceof Error)) return 'Registration failed'\r\n  \r\n  if (error.message.includes('username')) {\r\n    return 'Username already exists or is invalid'\r\n  } else if (error.message.includes('email')) {\r\n    return 'Email already exists or is invalid'\r\n  } else {\r\n    return error.message\r\n  }\r\n}\r\n\r\nconst handleSignInError = (error: unknown): string => {\r\n  if (!(error instanceof Error)) return 'Login failed'\r\n  \r\n  if (error.message.includes('Failed to authenticate')) {\r\n    return 'Invalid email/username or password. Please check your credentials and try again.'\r\n  } else if (error.message.includes('Too many requests')) {\r\n    return 'Too many login attempts. Please wait a moment and try again.'\r\n  } else {\r\n    return error.message\r\n  }\r\n}\r\n\r\nconst isDemoLogin = (email: string, password: string): boolean => {\r\n  const isDevelopment = import.meta.env.NODE_ENV === 'development' || import.meta.env.VITE_ENABLE_DEBUG_LOGGING === 'true'\r\n  const demoPassword = import.meta.env.VITE_DEMO_PASSWORD || 'demo123456'\r\n  return isDevelopment && email === 'demo' && password === demoPassword\r\n}\r\n\r\nconst performPocketBaseAuth = async (email: string, password: string) => {\r\n  const sanitizedEmail = sanitizeInput(email)\r\n  \r\n  // Try email first, then username fallback\r\n  try {\r\n    return await pb.collection('users').authWithPassword(sanitizedEmail, password)\r\n  } catch (emailError) {\r\n    debugLogger.log('[POCKETBASE_AUTH_STORE]', 'Email login failed, trying username');\r\n    return await pb.collection('users').authWithPassword(sanitizedEmail, password)\r\n  }\r\n}\r\n\r\nconst updateUserLastActive = async (userId: string) => {\r\n  try {\r\n    await pb.collection('users').update(userId, {\r\n      last_active: new Date().toISOString()\r\n    })\r\n    debugLogger.log('[POCKETBASE_AUTH_STORE]', 'Updated last active time');\r\n  } catch (updateError) {\r\n    debugLogger.warn('[POCKETBASE_AUTH_STORE]', 'Could not update last active time', {\r\n      error: updateError\r\n    });\r\n  }\r\n}\r\n\r\n// Consolidated authentication store - combines PocketBase + local fallback\r\n// This replaces the dual authStore/pocketbaseAuthStore pattern\r\nexport const useAuthStore = create<AuthState>()((set, get) => ({\r\n  user: null,\r\n  session: null,\r\n  isAuthenticated: false,\r\n  isLoading: false,\r\n  error: null,\r\n\r\n  signUp: async (email: string, password: string, username: string) => {\r\n    debugLogger.log('[POCKETBASE_AUTH_STORE]', 'START - signUp', {\r\n      email,\r\n      username,\r\n      passwordLength: password.length\r\n    });\r\n\r\n    set({ isLoading: true, error: null })\r\n    \r\n    try {\r\n      validateSignUpInputs(email, password, username)\r\n      \r\n      const userData = createPocketBaseUserData(email, username, password)\r\n      debugLogger.log('[POCKETBASE_AUTH_STORE]', 'Creating user in PocketBase', {\r\n        email: userData.email,\r\n        username: userData.username\r\n      });\r\n\r\n      const newUser = await pb.collection('users').create(userData)\r\n      debugLogger.log('[POCKETBASE_AUTH_STORE]', 'User created successfully', {\r\n        userId: newUser.id\r\n      });\r\n\r\n      // Authenticate the newly created user\r\n      const authData = await pb.collection('users').authWithPassword(userData.email, password)\r\n      debugLogger.log('[POCKETBASE_AUTH_STORE]', 'SignUp with auth successful', {\r\n        userId: authData.record.id,\r\n        hasToken: !!authData.token\r\n      });\r\n\r\n      const user = await convertPocketbaseUser(authData.record)\r\n      \r\n      set({\r\n        user,\r\n        session: authData,\r\n        isAuthenticated: true,\r\n        isLoading: false,\r\n        error: null\r\n      })\r\n\r\n    } catch (error) {\r\n      debugLogger.error('[POCKETBASE_AUTH_STORE]', 'SignUp error', {\r\n        error,\r\n        stack: error instanceof Error ? error.stack : undefined\r\n      });\r\n\r\n      set({\r\n        error: handleSignUpError(error),\r\n        isLoading: false\r\n      })\r\n    }\r\n\r\n    debugLogger.log('[POCKETBASE_AUTH_STORE]', 'END - signUp');\r\n  },\r\n\r\n  signIn: async (email: string, password: string) => {\r\n    debugLogger.log('[POCKETBASE_AUTH_STORE]', 'START - signIn', {\r\n      email,\r\n      passwordLength: password.length,\r\n      isDemoLogin: email === 'demo'\r\n    });\r\n\r\n    set({ isLoading: true, error: null })\r\n    \r\n    const timeoutId = setTimeout(() => {\r\n      debugLogger.warn('[POCKETBASE_AUTH_STORE]', 'SignIn timeout reached');\r\n      set({ isLoading: false, error: 'Login timed out. Please try again.' })\r\n    }, 10000)\r\n    \r\n    try {\r\n      // Handle demo login in development\r\n      if (isDemoLogin(email, password)) {\r\n        debugLogger.info('[POCKETBASE_AUTH_STORE]', 'Demo login detected (development mode)');\r\n        const demoUser = createDemoUser()\r\n        \r\n        clearTimeout(timeoutId)\r\n        set({\r\n          user: demoUser,\r\n          session: null,\r\n          isAuthenticated: true,\r\n          isLoading: false,\r\n          error: null\r\n        })\r\n        \r\n        debugLogger.log('[POCKETBASE_AUTH_STORE]', 'END - signIn (demo user)');\r\n        return\r\n      }\r\n\r\n      // Validate inputs for regular login\r\n      validateSignInInputs(email, password)\r\n      \r\n      // Perform PocketBase authentication\r\n      debugLogger.log('[POCKETBASE_AUTH_STORE]', 'Attempting PocketBase authentication');\r\n      const authData = await performPocketBaseAuth(email, password)\r\n\r\n      debugLogger.log('[POCKETBASE_AUTH_STORE]', 'SignIn response', {\r\n        hasRecord: !!authData.record,\r\n        hasToken: !!authData.token,\r\n        userId: authData.record?.id\r\n      });\r\n\r\n      if (authData.record && authData.token) {\r\n        debugLogger.log('[POCKETBASE_AUTH_STORE]', 'SignIn successful, converting user profile');\r\n        \r\n        const user = await convertPocketbaseUser(authData.record)\r\n        await updateUserLastActive(authData.record.id)\r\n        \r\n        clearTimeout(timeoutId)\r\n        \r\n        set({\r\n          user,\r\n          session: authData,\r\n          isAuthenticated: true,\r\n          isLoading: false,\r\n          error: null\r\n        })\r\n        \r\n        debugLogger.log('[POCKETBASE_AUTH_STORE]', 'END - signIn (success)');\r\n      } else {\r\n        debugLogger.warn('[POCKETBASE_AUTH_STORE]', 'No user or token in response');\r\n        clearTimeout(timeoutId)\r\n        set({\r\n          error: 'Invalid login response - no user or token',\r\n          isLoading: false\r\n        })\r\n      }\r\n    } catch (error) {\r\n      debugLogger.error('[POCKETBASE_AUTH_STORE]', 'SignIn error', {\r\n        error,\r\n        stack: error instanceof Error ? error.stack : undefined\r\n      });\r\n      \r\n      clearTimeout(timeoutId)\r\n      set({\r\n        error: handleSignInError(error),\r\n        isLoading: false\r\n      })\r\n    }\r\n\r\n    debugLogger.log('[POCKETBASE_AUTH_STORE]', 'END - signIn');\r\n  },\r\n\r\n  signOut: async () => {\r\n    debugLogger.log('[POCKETBASE_AUTH_STORE]', 'START - signOut');\r\n    \r\n    try {\r\n      debugLogger.log('[POCKETBASE_AUTH_STORE]', 'Calling PocketBase authStore.clear');\r\n      pb.authStore.clear()\r\n      \r\n      debugLogger.log('[POCKETBASE_AUTH_STORE]', 'Clearing auth state');\r\n      set({ \r\n        user: null,\r\n        session: null,\r\n        isAuthenticated: false, \r\n        error: null \r\n      })\r\n      \r\n      debugLogger.log('[POCKETBASE_AUTH_STORE]', 'END - signOut (success)');\r\n    } catch (error) {\r\n      debugLogger.error('[POCKETBASE_AUTH_STORE]', 'SignOut error', {\r\n        error,\r\n        stack: error instanceof Error ? error.stack : undefined\r\n      });\r\n      \r\n      set({\r\n        error: error instanceof Error ? error.message : 'Logout failed'\r\n      })\r\n    }\r\n  },\r\n\r\n  resetPassword: async (email: string) => {\r\n    debugLogger.log('[POCKETBASE_AUTH_STORE]', 'START - resetPassword', { email });\r\n    \r\n    set({ isLoading: true, error: null })\r\n    \r\n    try {\r\n      await pb.collection('users').requestPasswordReset(email)\r\n      \r\n      set({\r\n        isLoading: false,\r\n        error: null\r\n      })\r\n      \r\n      debugLogger.log('[POCKETBASE_AUTH_STORE]', 'END - resetPassword (success)');\r\n    } catch (error) {\r\n      debugLogger.error('[POCKETBASE_AUTH_STORE]', 'Reset password error', {\r\n        error,\r\n        stack: error instanceof Error ? error.stack : undefined\r\n      });\r\n      \r\n      let errorMessage = 'Password reset failed'\r\n      if (error instanceof Error) {\r\n        if (error.message.includes('Invalid email')) {\r\n          errorMessage = 'Please enter a valid email address.'\r\n        } else if (error.message.includes('not found')) {\r\n          errorMessage = 'No account found with this email address.'\r\n        } else {\r\n          errorMessage = error.message\r\n        }\r\n      }\r\n      \r\n      set({\r\n        error: errorMessage,\r\n        isLoading: false\r\n      })\r\n    }\r\n  },\r\n\r\n  updatePassword: async (newPassword: string) => {\r\n    debugLogger.log('[POCKETBASE_AUTH_STORE]', 'START - updatePassword', {\r\n      passwordLength: newPassword.length\r\n    });\r\n    \r\n    const currentState = get();\r\n    debugLogger.log('[POCKETBASE_AUTH_STORE]', 'Current auth state', {\r\n      hasUser: !!currentState.user,\r\n      hasSession: !!currentState.session,\r\n      isAuthenticated: currentState.isAuthenticated\r\n    });\r\n    \r\n    set({ isLoading: true, error: null });\r\n    \r\n    try {\r\n      // Validate password\r\n      if (!newPassword || newPassword.length < 6) {\r\n        throw new Error(\"Password must be at least 6 characters long.\");\r\n      }\r\n\r\n      if (!currentState.user?.id) {\r\n        throw new Error('No authenticated user found');\r\n      }\r\n\r\n      debugLogger.log('[POCKETBASE_AUTH_STORE]', 'Calling pb.collection.update');\r\n\r\n      await pb.collection('users').update(currentState.user.id, {\r\n        password: newPassword,\r\n        passwordConfirm: newPassword\r\n      });\r\n\r\n      debugLogger.log('[POCKETBASE_AUTH_STORE]', 'Password update successful');\r\n\r\n      set({ isLoading: false, error: null });\r\n      \r\n      debugLogger.log('[POCKETBASE_AUTH_STORE]', 'END - updatePassword (success)');\r\n    } catch (error) {\r\n      const errorMessage =\r\n        error instanceof Error\r\n          ? error.message\r\n          : \"An unknown error occurred during password update.\";\r\n      \r\n      debugLogger.error('[POCKETBASE_AUTH_STORE]', 'UpdatePassword failed', {\r\n        error: errorMessage,\r\n        errorType: error?.constructor?.name,\r\n        stack: error instanceof Error ? error.stack : undefined\r\n      });\r\n      \r\n      set({ isLoading: false, error: errorMessage });\r\n      \r\n      throw new Error(errorMessage);\r\n    }\r\n  },\r\n\r\n  updateProfile: async (updates: Partial<User>) => {\r\n    const { user } = get()\r\n    \r\n    debugLogger.log('[POCKETBASE_AUTH_STORE]', 'START - updateProfile', {\r\n      userId: user?.id,\r\n      updates: Object.keys(updates)\r\n    });\r\n    \r\n    if (!user) {\r\n      debugLogger.warn('[POCKETBASE_AUTH_STORE]', 'No user found for profile update');\r\n      return\r\n    }\r\n    \r\n    try {\r\n      const updateData = {\r\n        username: updates.username,\r\n        level: updates.level,\r\n        total_xp: updates.totalXp,\r\n        coins: updates.coins,\r\n        gems: updates.gems,\r\n        preferences: updates.preferences,\r\n        last_active: new Date().toISOString()\r\n      };\r\n      \r\n      debugLogger.log('[POCKETBASE_AUTH_STORE]', 'Updating profile in database', updateData);\r\n      \r\n      await pb.collection('users').update(user.id, updateData)\r\n      \r\n      debugLogger.log('[POCKETBASE_AUTH_STORE]', 'Updating local user state');\r\n      set({ user: { ...user, ...updates } })\r\n      \r\n      debugLogger.log('[POCKETBASE_AUTH_STORE]', 'END - updateProfile (success)');\r\n    } catch (error) {\r\n      debugLogger.error('[POCKETBASE_AUTH_STORE]', 'Profile update error', {\r\n        error,\r\n        stack: error instanceof Error ? error.stack : undefined\r\n      });\r\n      \r\n      set({\r\n        error: error instanceof Error ? error.message : 'Profile update failed'\r\n      })\r\n    }\r\n  },\r\n\r\n  clearError: () => {\r\n    debugLogger.log('[POCKETBASE_AUTH_STORE]', 'Clearing error state');\r\n    set({ error: null })\r\n  },\r\n\r\n  initializeAuth: async () => {\r\n    debugLogger.log('[POCKETBASE_AUTH_STORE]', 'START - initializeAuth');\r\n    \r\n    try {\r\n      if (pb.authStore.isValid && pb.authStore.model) {\r\n        debugLogger.log('[POCKETBASE_AUTH_STORE]', 'Valid auth store found, converting user', {\r\n          userId: pb.authStore.model.id,\r\n          email: pb.authStore.model.email\r\n        });\r\n        \r\n        const user = await convertPocketbaseUser(pb.authStore.model)\r\n        \r\n        debugLogger.log('[POCKETBASE_AUTH_STORE]', 'Setting authenticated state from initialization');\r\n        set({\r\n          user,\r\n          session: {\r\n            record: pb.authStore.model,\r\n            token: pb.authStore.token\r\n          },\r\n          isAuthenticated: true\r\n        })\r\n      } else {\r\n        debugLogger.info('[POCKETBASE_AUTH_STORE]', 'No valid auth store found during initialization');\r\n      }\r\n      \r\n      debugLogger.log('[POCKETBASE_AUTH_STORE]', 'END - initializeAuth');\r\n    } catch (error) {\r\n      debugLogger.error('[POCKETBASE_AUTH_STORE]', 'Auth initialization error', {\r\n        error,\r\n        stack: error instanceof Error ? error.stack : undefined\r\n      });\r\n      \r\n      set({ \r\n        user: null,\r\n        session: null,\r\n        isAuthenticated: false \r\n      })\r\n    }\r\n  },\r\n\r\n  // Unified methods for backward compatibility with existing components\r\n  login: async (email: string, password: string) => {\r\n    const { signIn } = get()\r\n    await signIn(email, password)\r\n  },\r\n\r\n  register: async (email: string, username: string, password: string) => {\r\n    const { signUp } = get()\r\n    await signUp(email, password, username)\r\n  },\r\n\r\n  logout: () => {\r\n    const { signOut } = get()\r\n    signOut()\r\n  },\r\n\r\n  updateUser: (updates: Partial<User>) => {\r\n    const { user } = get()\r\n    if (user) {\r\n      set({ user: { ...user, ...updates } })\r\n    }\r\n  }\r\n}))\r\n\r\n// Set up auth state change listener\r\npb.authStore.onChange((token, record) => {\r\n  debugLogger.info('[POCKETBASE_AUTH_STORE]', 'Auth state change detected', {\r\n    hasToken: !!token,\r\n    hasRecord: !!record,\r\n    userId: record?.id,\r\n    timestamp: new Date().toISOString()\r\n  });\r\n  \r\n  if (token && record) {\r\n    debugLogger.log('[POCKETBASE_AUTH_STORE]', 'Processing auth state change - user logged in');\r\n    \r\n    convertPocketbaseUser(record).then(user => {\r\n      debugLogger.log('[POCKETBASE_AUTH_STORE]', 'Updating auth store for logged in user');\r\n      useAuthStore.setState({\r\n        user,\r\n        session: { record, token },\r\n        isAuthenticated: true\r\n      })\r\n    }).catch(error => {\r\n      debugLogger.error('[POCKETBASE_AUTH_STORE]', 'Failed to convert user during auth change', {\r\n        error,\r\n        userId: record.id\r\n      });\r\n    });\r\n  } else {\r\n    debugLogger.log('[POCKETBASE_AUTH_STORE]', 'Processing auth state change - user logged out');\r\n    \r\n    useAuthStore.setState({\r\n      user: null,\r\n      session: null,\r\n      isAuthenticated: false\r\n    })\r\n  }\r\n})","import { create } from 'zustand'\r\nimport { persist } from 'zustand/middleware'\r\n\r\ntype Theme = 'light' | 'dark' | 'system'\r\n\r\ninterface ThemeState {\r\n  theme: Theme\r\n  systemTheme: 'light' | 'dark'\r\n  \r\n  // Actions\r\n  setTheme: (theme: Theme) => void\r\n  toggleTheme: () => void\r\n  initializeTheme: () => void\r\n}\r\n\r\nexport const useThemeStore = create<ThemeState>()(\r\n  persist(\r\n    (set, get) => ({\r\n      theme: 'system',\r\n      systemTheme: 'light',\r\n\r\n      setTheme: (theme: Theme) => {\r\n        set({ theme })\r\n        \r\n        // Apply theme immediately\r\n        const { systemTheme } = get()\r\n        const effectiveTheme = theme === 'system' ? systemTheme : theme\r\n        \r\n        if (effectiveTheme === 'dark') {\r\n          document.documentElement.classList.add('dark')\r\n        } else {\r\n          document.documentElement.classList.remove('dark')\r\n        }\r\n      },\r\n\r\n      toggleTheme: () => {\r\n        const { theme } = get()\r\n        const newTheme = theme === 'light' ? 'dark' : 'light'\r\n        get().setTheme(newTheme)\r\n      },\r\n\r\n      initializeTheme: () => {\r\n        // Detect system theme preference\r\n        const systemTheme = window.matchMedia('(prefers-color-scheme: dark)').matches \r\n          ? 'dark' \r\n          : 'light'\r\n        \r\n        set({ systemTheme })\r\n        \r\n        // Listen for system theme changes\r\n        window.matchMedia('(prefers-color-scheme: dark)')\r\n          .addEventListener('change', (e) => {\r\n            const newSystemTheme = e.matches ? 'dark' : 'light'\r\n            set({ systemTheme: newSystemTheme })\r\n            \r\n            // If using system theme, update the applied theme\r\n            const { theme } = get()\r\n            if (theme === 'system') {\r\n              if (newSystemTheme === 'dark') {\r\n                document.documentElement.classList.add('dark')\r\n              } else {\r\n                document.documentElement.classList.remove('dark')\r\n              }\r\n            }\r\n          })\r\n        \r\n        // Apply initial theme\r\n        const { theme } = get()\r\n        const effectiveTheme = theme === 'system' ? systemTheme : theme\r\n        \r\n        if (effectiveTheme === 'dark') {\r\n          document.documentElement.classList.add('dark')\r\n        } else {\r\n          document.documentElement.classList.remove('dark')\r\n        }\r\n      }\r\n    }),\r\n    {\r\n      name: 'theme-storage',\r\n      partialize: (state) => ({ theme: state.theme })\r\n    }\r\n  )\r\n)","import { create } from 'zustand'\r\nimport { persist } from 'zustand/middleware'\r\nimport type {\r\n  Achievement,\r\n  UserAchievement,\r\n  UserStreak,\r\n  Challenge,\r\n  ChallengeParticipation,\r\n  Leaderboard,\r\n  WeeklyProgress\r\n} from '@shared/types'\r\n\r\ninterface UserStats {\r\n  totalCards: number\r\n  cardsStudiedToday: number\r\n  cardsStudiedThisWeek: number\r\n  cardsStudiedThisMonth: number\r\n  averageAccuracy: number\r\n  totalStudyTime: number // in minutes\r\n  studyTimeToday: number // in minutes\r\n  studyTimeThisWeek: number // in minutes\r\n  decksCreated: number\r\n  decksCompleted: number\r\n  longestStreak: number\r\n  currentStreak: number\r\n  // Currency system\r\n  gold: number\r\n  diamonds: number\r\n  // User level and XP\r\n  level: number\r\n  xp: number\r\n  xpToNextLevel: number\r\n}\r\n\r\ninterface GamificationState {\r\n  // User stats\r\n  userStats: UserStats\r\n  \r\n  // Achievements\r\n  achievements: Achievement[]\r\n  userAchievements: UserAchievement[]\r\n  \r\n  // Streaks\r\n  userStreak: UserStreak | null\r\n  \r\n  // Challenges\r\n  activeChallenges: Challenge[]\r\n  userChallengeParticipations: ChallengeParticipation[]\r\n  \r\n  // Leaderboards\r\n  leaderboards: Record<string, Leaderboard>\r\n  \r\n  // User state tracking\r\n  isFirstTimeUser: boolean\r\n  isInitialized: boolean\r\n  \r\n  // Actions\r\n  updateUserStats: (stats: Partial<UserStats>) => void\r\n  addUserAchievement: (achievementId: string) => void\r\n  updateStreak: (streak: Partial<UserStreak>) => void\r\n  joinChallenge: (challengeId: string) => void\r\n  updateChallengeProgress: (challengeId: string, progress: Record<string, number>) => void\r\n  claimChallengeReward: (challengeId: string) => void\r\n  initializeMockData: () => void\r\n  initializeNewUser: () => void\r\n  initializeUserData: (isDemo?: boolean) => void\r\n  resetAllUserData: () => void\r\n  addCurrency: (gold: number, diamonds: number) => void\r\n  spendCurrency: (gold: number, diamonds: number) => boolean\r\n  awardStudyXP: (cardsStudied: number, correctAnswers: number) => void\r\n  \r\n  // Monthly Challenge Management\r\n  updateMilestoneProgress: (challengeId: string, milestoneId: string, completed: boolean) => void\r\n  updateWeeklyProgress: (challengeId: string, weekData: WeeklyProgress) => void\r\n  updateChallengeStreak: (challengeId: string, streak: number) => void\r\n  unlockStoryChapter: (challengeId: string, week: number) => void\r\n  claimMilestoneReward: (challengeId: string, milestoneId: string) => void\r\n  contributeToCommunityGoal: (goalId: string, contribution: number) => void\r\n}\r\n\r\n// Mock data\r\nconst mockAchievements: Achievement[] = [\r\n  {\r\n    id: '1',\r\n    name: 'First Steps',\r\n    description: 'Complete your first study session',\r\n    icon: '',\r\n    category: 'study_milestones',\r\n    requirements: [{ type: 'sessions_completed', value: 1, operator: 'gte' }],\r\n    xpReward: 50,\r\n    coinReward: 10,\r\n    isSecret: false,\r\n    rarity: 'common'\r\n  },\r\n  {\r\n    id: '2',\r\n    name: 'Streak Master',\r\n    description: 'Maintain a 7-day study streak',\r\n    icon: '',\r\n    category: 'streaks',\r\n    requirements: [{ type: 'current_streak', value: 7, operator: 'gte' }],\r\n    xpReward: 200,\r\n    coinReward: 50,\r\n    isSecret: false,\r\n    rarity: 'rare'\r\n  },\r\n  {\r\n    id: '3',\r\n    name: 'Perfect Score',\r\n    description: 'Get 100% accuracy in a 20+ card session',\r\n    icon: '',\r\n    category: 'accuracy',\r\n    requirements: [\r\n      { type: 'session_accuracy', value: 100, operator: 'eq' },\r\n      { type: 'session_cards', value: 20, operator: 'gte' }\r\n    ],\r\n    xpReward: 150,\r\n    coinReward: 30,\r\n    isSecret: false,\r\n    rarity: 'rare'\r\n  },\r\n  {\r\n    id: '4',\r\n    name: 'Speed Demon',\r\n    description: 'Complete 50 cards in under 10 minutes',\r\n    icon: '',\r\n    category: 'special',\r\n    requirements: [\r\n      { type: 'cards_in_session', value: 50, operator: 'gte' },\r\n      { type: 'session_time', value: 600, operator: 'lte' }\r\n    ],\r\n    xpReward: 300,\r\n    coinReward: 75,\r\n    isSecret: false,\r\n    rarity: 'epic'\r\n  },\r\n  {\r\n    id: '5',\r\n    name: 'Scholar',\r\n    description: 'Study 1000 cards total',\r\n    icon: '',\r\n    category: 'study_milestones',\r\n    requirements: [{ type: 'total_cards', value: 1000, operator: 'gte' }],\r\n    xpReward: 500,\r\n    coinReward: 100,\r\n    isSecret: false,\r\n    rarity: 'epic'\r\n  },\r\n  {\r\n    id: '6',\r\n    name: 'Legend',\r\n    description: 'Reach level 20',\r\n    icon: '',\r\n    category: 'special',\r\n    requirements: [{ type: 'user_level', value: 20, operator: 'gte' }],\r\n    xpReward: 1000,\r\n    coinReward: 500,\r\n    isSecret: false,\r\n    rarity: 'legendary'\r\n  }\r\n]\r\n\r\nconst mockChallenges: Challenge[] = [\r\n  {\r\n    id: '1',\r\n    title: 'Daily Grind',\r\n    description: 'Study 25 cards today',\r\n    type: 'daily',\r\n    requirements: [{ type: 'cards_studied_today', target: 25, description: 'Study 25 cards' }],\r\n    rewards: [\r\n      { type: 'xp', amount: 50 },\r\n      { type: 'coins', amount: 10 }\r\n    ],\r\n    startDate: new Date().toISOString(),\r\n    endDate: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString(),\r\n    isActive: true,\r\n    participantCount: 1247\r\n  },\r\n  {\r\n    id: '2',\r\n    title: 'Weekly Warrior',\r\n    description: 'Complete 200 cards this week',\r\n    type: 'weekly',\r\n    requirements: [{ type: 'cards_studied_week', target: 200, description: 'Study 200 cards this week' }],\r\n    rewards: [\r\n      { type: 'xp', amount: 200 },\r\n      { type: 'coins', amount: 50 },\r\n      { type: 'gems', amount: 5 }\r\n    ],\r\n    startDate: new Date(Date.now() - 3 * 24 * 60 * 60 * 1000).toISOString(),\r\n    endDate: new Date(Date.now() + 4 * 24 * 60 * 60 * 1000).toISOString(),\r\n    isActive: true,\r\n    participantCount: 892\r\n  },\r\n  {\r\n    id: '3',\r\n    title: 'Accuracy Master',\r\n    description: 'Maintain 90%+ accuracy for 5 sessions',\r\n    type: 'weekly',\r\n    requirements: [{ type: 'accuracy_sessions', target: 5, description: 'Complete 5 sessions with 90%+ accuracy' }],\r\n    rewards: [\r\n      { type: 'xp', amount: 300 },\r\n      { type: 'coins', amount: 75 },\r\n      { type: 'badge', itemId: 'accuracy_master' }\r\n    ],\r\n    startDate: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000).toISOString(),\r\n    endDate: new Date(Date.now() + 5 * 24 * 60 * 60 * 1000).toISOString(),\r\n    isActive: true,\r\n    participantCount: 456\r\n  }\r\n]\r\n\r\nconst mockLeaderboards: Record<string, Leaderboard> = {\r\n  'xp_weekly': {\r\n    id: 'xp_weekly',\r\n    type: 'xp',\r\n    period: 'weekly',\r\n    entries: [\r\n      { userId: '1', username: 'DemoUser', score: 2500, rank: 1, change: 0 },\r\n      { userId: '2', username: 'StudyMaster', score: 2350, rank: 2, change: 1 },\r\n      { userId: '3', username: 'FlashcardPro', score: 2200, rank: 3, change: -1 },\r\n      { userId: '4', username: 'LearnFast', score: 2100, rank: 4, change: 2 },\r\n      { userId: '5', username: 'MemoryKing', score: 2050, rank: 5, change: -1 },\r\n      { userId: '6', username: 'QuizWhiz', score: 1980, rank: 6, change: 0 },\r\n      { userId: '7', username: 'CardShark', score: 1920, rank: 7, change: 3 },\r\n      { userId: '8', username: 'BrainBoost', score: 1850, rank: 8, change: -2 },\r\n      { userId: '9', username: 'StudyBuddy', score: 1800, rank: 9, change: 1 },\r\n      { userId: '10', username: 'FlashGenius', score: 1750, rank: 10, change: -1 }\r\n    ],\r\n    updatedAt: new Date().toISOString()\r\n  },\r\n  'streak_all_time': {\r\n    id: 'streak_all_time',\r\n    type: 'streak',\r\n    period: 'all_time',\r\n    entries: [\r\n      { userId: '2', username: 'StudyMaster', score: 45, rank: 1, change: 0 },\r\n      { userId: '3', username: 'FlashcardPro', score: 38, rank: 2, change: 0 },\r\n      { userId: '4', username: 'LearnFast', score: 32, rank: 3, change: 1 },\r\n      { userId: '1', username: 'DemoUser', score: 28, rank: 4, change: -1 },\r\n      { userId: '5', username: 'MemoryKing', score: 25, rank: 5, change: 0 },\r\n      { userId: '6', username: 'QuizWhiz', score: 22, rank: 6, change: 2 },\r\n      { userId: '7', username: 'CardShark', score: 20, rank: 7, change: -1 },\r\n      { userId: '8', username: 'BrainBoost', score: 18, rank: 8, change: -1 },\r\n      { userId: '9', username: 'StudyBuddy', score: 15, rank: 9, change: 0 },\r\n      { userId: '10', username: 'FlashGenius', score: 12, rank: 10, change: 0 }\r\n    ],\r\n    updatedAt: new Date().toISOString()\r\n  }\r\n}\r\n\r\n// Helper function to calculate level from XP\r\nconst calculateLevel = (xp: number): number => {\r\n  return Math.floor(Math.sqrt(xp / 100)) + 1\r\n}\r\n\r\n// Helper function to calculate XP needed for next level\r\nconst calculateXPToNextLevel = (level: number): number => {\r\n  const nextLevelXP = Math.pow(level, 2) * 100\r\n  return nextLevelXP\r\n}\r\n\r\n// Initial clean state for new users\r\nconst getInitialUserStats = (): UserStats => ({\r\n  totalCards: 0,\r\n  cardsStudiedToday: 0,\r\n  cardsStudiedThisWeek: 0,\r\n  cardsStudiedThisMonth: 0,\r\n  averageAccuracy: 0,\r\n  totalStudyTime: 0,\r\n  studyTimeToday: 0,\r\n  studyTimeThisWeek: 0,\r\n  decksCreated: 0,\r\n  decksCompleted: 0,\r\n  longestStreak: 0,\r\n  currentStreak: 0,\r\n  gold: 0,\r\n  diamonds: 0,\r\n  level: 1,\r\n  xp: 0,\r\n  xpToNextLevel: 100\r\n})\r\n\r\n// Demo data for demonstration purposes\r\nconst getDemoUserStats = (): UserStats => ({\r\n  totalCards: 1250,\r\n  cardsStudiedToday: 45,\r\n  cardsStudiedThisWeek: 180,\r\n  cardsStudiedThisMonth: 720,\r\n  averageAccuracy: 87.5,\r\n  totalStudyTime: 2400, // 40 hours\r\n  studyTimeToday: 35,\r\n  studyTimeThisWeek: 240, // 4 hours\r\n  decksCreated: 8,\r\n  decksCompleted: 3,\r\n  longestStreak: 28,\r\n  currentStreak: 12,\r\n  gold: 100,\r\n  diamonds: 10,\r\n  level: 8,\r\n  xp: 6400,\r\n  xpToNextLevel: 8100\r\n})\r\n\r\nexport const useGamificationStore = create<GamificationState>()(\r\n  persist(\r\n    (set, get) => ({\r\n      userStats: getInitialUserStats(),\r\n      isFirstTimeUser: true,\r\n      isInitialized: false,\r\n      \r\n      achievements: mockAchievements,\r\n      userAchievements: [],\r\n      \r\n      userStreak: null,\r\n      \r\n      activeChallenges: mockChallenges,\r\n      userChallengeParticipations: [],\r\n      \r\n      leaderboards: mockLeaderboards,\r\n      \r\n      updateUserStats: (stats) => {\r\n        set((state) => {\r\n          const newStats = { ...state.userStats, ...stats }\r\n          \r\n          // Recalculate level and XP if XP changed\r\n          if (stats.xp !== undefined) {\r\n            newStats.level = calculateLevel(newStats.xp)\r\n            newStats.xpToNextLevel = calculateXPToNextLevel(newStats.level)\r\n          }\r\n          \r\n          return {\r\n            userStats: newStats,\r\n            isFirstTimeUser: false,\r\n            isInitialized: true\r\n          }\r\n        })\r\n      },\r\n      \r\n      addUserAchievement: (achievementId) => {\r\n        const { userAchievements } = get()\r\n        if (!userAchievements.find(ua => ua.achievementId === achievementId)) {\r\n          set((state) => ({\r\n            userAchievements: [\r\n              ...state.userAchievements,\r\n              {\r\n                id: Date.now().toString(),\r\n                userId: '1',\r\n                achievementId,\r\n                earnedAt: new Date().toISOString()\r\n              }\r\n            ]\r\n          }))\r\n        }\r\n      },\r\n      \r\n      updateStreak: (streak) => {\r\n        set((state) => ({\r\n          userStreak: state.userStreak ? { ...state.userStreak, ...streak } : null\r\n        }))\r\n      },\r\n      \r\n      joinChallenge: (challengeId) => {\r\n        const { userChallengeParticipations } = get()\r\n        if (!userChallengeParticipations.find(p => p.challengeId === challengeId)) {\r\n          set((state) => ({\r\n            userChallengeParticipations: [\r\n              ...state.userChallengeParticipations,\r\n              {\r\n                id: Date.now().toString(),\r\n                userId: '1',\r\n                challengeId,\r\n                progress: {},\r\n                completed: false,\r\n                joinedAt: new Date().toISOString(),\r\n                milestoneProgress: {},\r\n                weeklyProgress: [],\r\n                currentStreak: 0,\r\n                bestWeek: 0\r\n              }\r\n            ]\r\n          }))\r\n        }\r\n      },\r\n      \r\n      updateChallengeProgress: (challengeId, progress) => {\r\n        set((state) => ({\r\n          userChallengeParticipations: state.userChallengeParticipations.map(p =>\r\n            p.challengeId === challengeId\r\n              ? { ...p, progress: { ...p.progress, ...progress } }\r\n              : p\r\n          )\r\n        }))\r\n      },\r\n      \r\n      claimChallengeReward: (challengeId) => {\r\n        const { activeChallenges, userChallengeParticipations } = get()\r\n        const challenge = activeChallenges.find(c => c.id === challengeId)\r\n        const participation = userChallengeParticipations.find(p => p.challengeId === challengeId)\r\n        \r\n        if (challenge && participation && participation.completed) {\r\n          // Calculate total XP and coins from rewards\r\n          let xpGained = 0\r\n          // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n          let _coinsGained = 0\r\n          \r\n          challenge.rewards.forEach(reward => {\r\n            if (reward.type === 'xp' && reward.amount) {\r\n              xpGained += reward.amount\r\n            } else if (reward.type === 'coins' && reward.amount) {\r\n              _coinsGained += reward.amount\r\n            }\r\n          })\r\n          \r\n          // Update user stats with rewards\r\n          set((state) => ({\r\n            userStats: {\r\n              ...state.userStats,\r\n              totalCards: state.userStats.totalCards + xpGained / 10 // Rough conversion\r\n            },\r\n            // Remove the participation since reward is claimed\r\n            userChallengeParticipations: state.userChallengeParticipations.filter(\r\n              p => p.challengeId !== challengeId\r\n            )\r\n          }))\r\n        }\r\n      },\r\n      \r\n      initializeMockData: () => {\r\n        // This function can be called to load demo data\r\n        set({\r\n          userStats: getDemoUserStats(),\r\n          achievements: mockAchievements,\r\n          activeChallenges: mockChallenges,\r\n          leaderboards: mockLeaderboards,\r\n          userAchievements: [\r\n            {\r\n              id: '1',\r\n              userId: '1',\r\n              achievementId: '1',\r\n              earnedAt: new Date(Date.now() - 10 * 24 * 60 * 60 * 1000).toISOString()\r\n            },\r\n            {\r\n              id: '2',\r\n              userId: '1',\r\n              achievementId: '2',\r\n              earnedAt: new Date(Date.now() - 5 * 24 * 60 * 60 * 1000).toISOString()\r\n            }\r\n          ],\r\n          userStreak: {\r\n            id: '1',\r\n            userId: '1',\r\n            currentStreak: 12,\r\n            longestStreak: 28,\r\n            lastStudyDate: new Date().toISOString(),\r\n            freezeCount: 2,\r\n            createdAt: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString()\r\n          },\r\n          userChallengeParticipations: [\r\n            {\r\n              id: '1',\r\n              userId: '1',\r\n              challengeId: '1',\r\n              progress: { cards_studied_today: 45 } as Record<string, number>,\r\n              completed: true,\r\n              joinedAt: new Date().toISOString(),\r\n              completedAt: new Date().toISOString(),\r\n              milestoneProgress: { 'milestone_1': true },\r\n              weeklyProgress: [],\r\n              currentStreak: 5,\r\n              bestWeek: 1\r\n            },\r\n            {\r\n              id: '2',\r\n              userId: '1',\r\n              challengeId: '2',\r\n              progress: { cards_studied_week: 180 } as Record<string, number>,\r\n              completed: false,\r\n              joinedAt: new Date(Date.now() - 3 * 24 * 60 * 60 * 1000).toISOString(),\r\n              milestoneProgress: { 'milestone_1': true, 'milestone_2': false },\r\n              weeklyProgress: [\r\n                {\r\n                  week: 1,\r\n                  startDate: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString(),\r\n                  endDate: new Date().toISOString(),\r\n                  progress: { cards_studied_week: 180 },\r\n                  completed: true,\r\n                  completedAt: new Date().toISOString(),\r\n                  storyUnlocked: true\r\n                }\r\n              ],\r\n              currentStreak: 3,\r\n              bestWeek: 1\r\n            }\r\n          ] as ChallengeParticipation[],\r\n          isFirstTimeUser: false,\r\n          isInitialized: true\r\n        })\r\n      },\r\n\r\n      initializeNewUser: () => {\r\n        // Initialize a completely fresh user\r\n        set({\r\n          userStats: getInitialUserStats(),\r\n          userAchievements: [],\r\n          userStreak: null,\r\n          userChallengeParticipations: [],\r\n          isFirstTimeUser: false,\r\n          isInitialized: true\r\n        })\r\n      },\r\n\r\n      resetAllUserData: () => {\r\n        // Reset all user-specific data to initial state\r\n        set({\r\n          userStats: getInitialUserStats(),\r\n          userAchievements: [],\r\n          userStreak: null,\r\n          userChallengeParticipations: [],\r\n          isFirstTimeUser: true,\r\n          isInitialized: true\r\n        })\r\n      },\r\n\r\n      addCurrency: (gold, diamonds) => {\r\n        set((state) => ({\r\n          userStats: {\r\n            ...state.userStats,\r\n            gold: state.userStats.gold + gold,\r\n            diamonds: state.userStats.diamonds + diamonds\r\n          }\r\n        }))\r\n      },\r\n\r\n      spendCurrency: (gold, diamonds) => {\r\n        const { userStats } = get()\r\n        if (userStats.gold >= gold && userStats.diamonds >= diamonds) {\r\n          set((state) => ({\r\n            userStats: {\r\n              ...state.userStats,\r\n              gold: state.userStats.gold - gold,\r\n              diamonds: state.userStats.diamonds - diamonds\r\n            }\r\n          }))\r\n          return true\r\n        }\r\n        return false\r\n      },\r\n\r\n      // Initialize user data based on authentication status\r\n      initializeUserData: (isDemo: boolean = false) => {\r\n        const state = get()\r\n        \r\n        // Only initialize if not already done\r\n        if (!state.isInitialized) {\r\n          if (isDemo) {\r\n            // Load demo data for demo users\r\n            set({\r\n              userStats: getDemoUserStats(),\r\n              achievements: mockAchievements,\r\n              activeChallenges: mockChallenges,\r\n              leaderboards: mockLeaderboards,\r\n              userAchievements: [\r\n                {\r\n                  id: '1',\r\n                  userId: '1',\r\n                  achievementId: '1',\r\n                  earnedAt: new Date(Date.now() - 10 * 24 * 60 * 60 * 1000).toISOString()\r\n                },\r\n                {\r\n                  id: '2',\r\n                  userId: '1',\r\n                  achievementId: '2',\r\n                  earnedAt: new Date(Date.now() - 5 * 24 * 60 * 60 * 1000).toISOString()\r\n                }\r\n              ],\r\n              userStreak: {\r\n                id: '1',\r\n                userId: '1',\r\n                currentStreak: 12,\r\n                longestStreak: 28,\r\n                lastStudyDate: new Date().toISOString(),\r\n                freezeCount: 2,\r\n                createdAt: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString()\r\n              },\r\n              userChallengeParticipations: [\r\n                {\r\n                  id: '1',\r\n                  userId: '1',\r\n                  challengeId: '1',\r\n                  progress: { cards_studied_today: 45 } as Record<string, number>,\r\n                  completed: true,\r\n                  joinedAt: new Date().toISOString(),\r\n                  completedAt: new Date().toISOString()\r\n                },\r\n                {\r\n                  id: '2',\r\n                  userId: '1',\r\n                  challengeId: '2',\r\n                  progress: { cards_studied_week: 180 } as Record<string, number>,\r\n                  completed: false,\r\n                  joinedAt: new Date(Date.now() - 3 * 24 * 60 * 60 * 1000).toISOString()\r\n                }\r\n              ] as ChallengeParticipation[],\r\n              isFirstTimeUser: false,\r\n              isInitialized: true\r\n            })\r\n          } else {\r\n            // Initialize fresh user data for new authenticated users\r\n            set({\r\n              userStats: getInitialUserStats(),\r\n              userAchievements: [],\r\n              userStreak: null,\r\n              userChallengeParticipations: [],\r\n              isFirstTimeUser: false,\r\n              isInitialized: true\r\n            })\r\n          }\r\n        }\r\n      },\r\n\r\n      // Monthly Challenge Management Methods\r\n      updateMilestoneProgress: (challengeId, milestoneId, completed) => {\r\n        set((state) => ({\r\n          userChallengeParticipations: state.userChallengeParticipations.map(p =>\r\n            p.challengeId === challengeId\r\n              ? {\r\n                  ...p,\r\n                  milestoneProgress: {\r\n                    ...p.milestoneProgress,\r\n                    [milestoneId]: completed\r\n                  }\r\n                }\r\n              : p\r\n          )\r\n        }))\r\n      },\r\n\r\n      updateWeeklyProgress: (challengeId, weekData) => {\r\n        set((state) => ({\r\n          userChallengeParticipations: state.userChallengeParticipations.map(p =>\r\n            p.challengeId === challengeId\r\n              ? {\r\n                  ...p,\r\n                  weeklyProgress: p.weeklyProgress\r\n                    ? [...p.weeklyProgress.filter(w => w.week !== weekData.week), weekData]\r\n                    : [weekData]\r\n                }\r\n              : p\r\n          )\r\n        }))\r\n      },\r\n\r\n      updateChallengeStreak: (challengeId, streak) => {\r\n        set((state) => ({\r\n          userChallengeParticipations: state.userChallengeParticipations.map(p =>\r\n            p.challengeId === challengeId\r\n              ? { ...p, currentStreak: streak }\r\n              : p\r\n          )\r\n        }))\r\n      },\r\n\r\n      unlockStoryChapter: (challengeId, week) => {\r\n        set((state) => ({\r\n          userChallengeParticipations: state.userChallengeParticipations.map(p =>\r\n            p.challengeId === challengeId\r\n              ? {\r\n                  ...p,\r\n                  weeklyProgress: p.weeklyProgress?.map(w =>\r\n                    w.week === week\r\n                      ? { ...w, storyUnlocked: true }\r\n                      : w\r\n                  ) || []\r\n                }\r\n              : p\r\n          )\r\n        }))\r\n      },\r\n\r\n      claimMilestoneReward: (challengeId, milestoneId) => {\r\n        // Find the challenge and milestone to get reward details\r\n        const { activeChallenges } = get()\r\n        const challenge = activeChallenges.find(c => c.id === challengeId)\r\n        \r\n        if (challenge) {\r\n          // Add milestone reward logic here\r\n          // For now, just mark milestone as claimed\r\n          set((state) => ({\r\n            userChallengeParticipations: state.userChallengeParticipations.map(p =>\r\n              p.challengeId === challengeId\r\n                ? {\r\n                    ...p,\r\n                    milestoneProgress: {\r\n                      ...p.milestoneProgress,\r\n                      [`${milestoneId}_claimed`]: true\r\n                    }\r\n                  }\r\n                : p\r\n            )\r\n          }))\r\n        }\r\n      },\r\n\r\n      contributeToCommunityGoal: (goalId, contribution) => {\r\n        // Update community goal progress\r\n        // This would typically involve API calls to update server-side data\r\n        // For now, we'll just update local state\r\n        console.log(`Contributing ${contribution} to community goal ${goalId}`)\r\n        \r\n        // Update user stats to reflect contribution\r\n        set((state) => ({\r\n          userStats: {\r\n            ...state.userStats,\r\n            // Add contribution tracking if needed\r\n          }\r\n        }))\r\n      },\r\n\r\n      awardStudyXP: (cardsStudied, correctAnswers) => {\r\n        // Award XP based on study performance\r\n        // Base XP: 1 XP per card studied\r\n        // Bonus XP: 1 additional XP per correct answer (rating higher than \"Again\")\r\n        // Milestone bonus: 10 XP for every 10 cards studied with good performance\r\n        \r\n        let xpGained = cardsStudied // Base XP\r\n        xpGained += correctAnswers // Bonus for correct answers\r\n        \r\n        // Milestone bonus: 10 XP for every 10 cards with good performance\r\n        const milestoneBonus = Math.floor(correctAnswers / 10) * 10\r\n        xpGained += milestoneBonus\r\n        \r\n        if (xpGained > 0) {\r\n          set((state) => {\r\n            const newXP = state.userStats.xp + xpGained\r\n            const newLevel = calculateLevel(newXP)\r\n            const newXPToNextLevel = calculateXPToNextLevel(newLevel)\r\n            \r\n            console.log(` XP Awarded: +${xpGained} XP (${cardsStudied} cards, ${correctAnswers} correct, ${milestoneBonus} milestone bonus)`)\r\n            console.log(` Total XP: ${state.userStats.xp}  ${newXP} (Level ${state.userStats.level}  ${newLevel})`)\r\n            \r\n            return {\r\n              userStats: {\r\n                ...state.userStats,\r\n                xp: newXP,\r\n                level: newLevel,\r\n                xpToNextLevel: newXPToNextLevel,\r\n                totalCards: state.userStats.totalCards + cardsStudied,\r\n                cardsStudiedToday: state.userStats.cardsStudiedToday + cardsStudied\r\n              }\r\n            }\r\n          })\r\n        }\r\n      }\r\n    }),\r\n    {\r\n      name: 'gamification-storage',\r\n      partialize: (state) => ({\r\n        userStats: state.userStats,\r\n        userAchievements: state.userAchievements,\r\n        userStreak: state.userStreak,\r\n        userChallengeParticipations: state.userChallengeParticipations,\r\n        isFirstTimeUser: state.isFirstTimeUser,\r\n        isInitialized: state.isInitialized\r\n      })\r\n    }\r\n  )\r\n)","import { Card, CardType, MediaReference } from '../../../shared/types'\r\n\r\n/**\r\n * Create a new card with all required Anki-style fields populated with defaults\r\n */\r\nexport function createNewCard(\r\n  frontContent: string,\r\n  backContent: string,\r\n  cardType: CardType = { type: 'basic' },\r\n  mediaRefs: MediaReference[] = []\r\n): Omit<Card, 'id' | 'createdAt' | 'deckId' | 'easeFactor' | 'intervalDays' | 'nextReview' | 'reviewCount' | 'lapseCount'> {\r\n  return {\r\n    frontContent,\r\n    backContent,\r\n    cardType,\r\n    mediaRefs,\r\n    \r\n    // Enhanced Anki-style fields with defaults\r\n    state: 'new',\r\n    queue: 0, // 0 = new\r\n    due: 0, // New cards have no due date\r\n    ivl: 0, // No interval yet\r\n    factor: 2500, // Default ease factor (250%)\r\n    reps: 0, // No repetitions yet\r\n    lapses: 0, // No lapses yet\r\n    left: 0, // No learning time left\r\n    \r\n    // Learning state defaults\r\n    learningStep: 0,\r\n    graduationInterval: 1, // Default 1 day\r\n    easyInterval: 4, // Default 4 days\r\n    \r\n    // Timing and performance defaults\r\n    totalStudyTime: 0,\r\n    averageAnswerTime: 0,\r\n    \r\n    // Metadata defaults\r\n    flags: 0,\r\n    originalDue: 0,\r\n    originalDeck: '', // Will be set when card is created\r\n    \r\n    // Gamification defaults\r\n    xpAwarded: 0,\r\n    difficultyRating: 3 // Default medium difficulty\r\n  }\r\n}\r\n\r\n/**\r\n * Create a complete card object for SVG map cards\r\n */\r\nexport function createSvgMapCard(\r\n  id: string,\r\n  deckId: string,\r\n  frontContent: string,\r\n  backContent: string,\r\n  cardType: CardType,\r\n  mediaRefs: MediaReference[] = []\r\n): Card {\r\n  const baseCard = createNewCard(frontContent, backContent, cardType, mediaRefs)\r\n  \r\n  return {\r\n    ...baseCard,\r\n    id,\r\n    deckId,\r\n    createdAt: new Date().toISOString(),\r\n    \r\n    // Legacy fields for backward compatibility\r\n    easeFactor: 2.5,\r\n    intervalDays: 0,\r\n    nextReview: new Date().toISOString(),\r\n    reviewCount: 0,\r\n    lapseCount: 0,\r\n    \r\n    // Set original deck\r\n    originalDeck: deckId\r\n  }\r\n}","import { create } from 'zustand'\nimport { persist } from 'zustand/middleware'\nimport { Deck, Card, DeckSettings } from '../../../shared/types'\nimport { createNewCard } from '../utils/cardDefaults'\n\ninterface StudySession {\n  deckId: string\n  currentCardIndex: number\n  studyCards: Card[] // For in-memory access during a session\n  studyCardIds: string[] // For persistence\n  sessionStats: {\n    total: number\n    correct: number\n    incorrect: number\n  }\n  startedAt: string\n}\n\ninterface DeckStore {\n  decks: Deck[]\n  cards: Record<string, Card[]> // deckId -> cards\n  currentStudySession: StudySession | null\n  isLoading: boolean\n  error: string | null\n  importProgress: number // 0-100\n  importStatus: string | null\n  \n  // Deck operations\n  createDeck: (deck: Omit<Deck, 'id' | 'createdAt' | 'updatedAt'>) => Promise<Deck>\n  updateDeck: (id: string, updates: Partial<Deck>) => Promise<void>\n  deleteDeck: (id: string) => Promise<void>\n  getDeck: (id: string) => Deck | undefined\n  \n  // Card operations\n  addCard: (deckId: string, card: Omit<Card, 'id' | 'deckId' | 'createdAt' | 'easeFactor' | 'intervalDays' | 'nextReview' | 'reviewCount' | 'lapseCount'>) => Promise<Card>\n  addCardBulk: (deckId: string, card: Omit<Card, 'id' | 'deckId' | 'createdAt' | 'easeFactor' | 'intervalDays' | 'nextReview' | 'reviewCount' | 'lapseCount'>) => Promise<Card>\n  addCardsBatch: (deckId: string, cards: Array<Omit<Card, 'id' | 'deckId' | 'createdAt' | 'easeFactor' | 'intervalDays' | 'nextReview' | 'reviewCount' | 'lapseCount'>>) => Promise<Card[]>\n  createDeckBulk: (deck: Omit<Deck, 'id' | 'createdAt' | 'updatedAt'>) => Promise<Deck>\n  updateCard: (cardId: string, updates: Partial<Card>) => Promise<void>\n  deleteCard: (cardId: string) => Promise<void>\n  getCards: (deckId: string) => Card[]\n  \n  // Import operations\n  importAnkiDeck: (file: File) => Promise<Deck>\n  importFromText: (deckName: string, text: string, separator?: string) => Promise<Deck>\n  \n  // Example data\n  loadExampleDecks: () => Promise<void>\n  \n  // Utility\n  clearError: () => void\n  setLoading: (loading: boolean) => void\n  setImportProgress: (progress: number, status?: string) => void\n  resetImportProgress: () => void\n  removeDuplicateCards: (deckId: string) => Promise<number>\n  \n  // Study session functions\n  startStudySession: (deckId: string, studyCards: Card[]) => void\n  updateStudySession: (currentCardIndex: number, sessionStats: StudySession['sessionStats']) => void\n  clearStudySession: () => void\n  getStudySession: (deckId: string) => StudySession | null\n  resetAllStudyData: () => void\n}\n\nconst defaultDeckSettings: DeckSettings = {\n  newCardsPerDay: 20,\n  maxReviewsPerDay: 100,\n  easyBonus: 1.3,\n  intervalModifier: 1.0,\n  maximumInterval: 36500, // 100 years\n  minimumInterval: 1\n}\n\n// Helper function to clean field content\nconst cleanFieldContent = (content: string): string => {\n  return content\n    .replace(/<[^>]*>/g, '') // Remove HTML tags\n    .replace(/&nbsp;/g, ' ')\n    .replace(/&lt;/g, '<')\n    .replace(/&gt;/g, '>')\n    .replace(/&amp;/g, '&')\n    .replace(/\\[sound:[^\\]]*\\]/g, '') // Remove sound references\n    .trim()\n}\n\n// Helper function to detect the best field combination for front/back\nconst detectBestFieldCombination = (sampleFields: string[][]): { frontIndex: number; backIndex: number } => {\n  if (sampleFields.length === 0) {\n    return { frontIndex: 0, backIndex: 1 }\n  }\n  \n  const fieldCount = sampleFields[0].length\n  const combinations: Array<{ frontIndex: number; backIndex: number; score: number }> = []\n  \n  // Try different field combinations\n  for (let front = 0; front < fieldCount; front++) {\n    for (let back = front + 1; back < fieldCount; back++) {\n      let score = 0\n      let validPairs = 0\n      \n      for (const fields of sampleFields) {\n        const frontContent = cleanFieldContent(fields[front] || '')\n        const backContent = cleanFieldContent(fields[back] || '')\n        \n        // Score based on content quality\n        if (frontContent && backContent) {\n          validPairs++\n          \n          // Prefer combinations where both fields have substantial content\n          if (frontContent.length > 2 && backContent.length > 2) {\n            score += 10\n          }\n          \n          // Prefer combinations where fields are different\n          if (frontContent !== backContent) {\n            score += 5\n          }\n          \n          // Avoid fields that look like audio references or numbers only\n          if (!frontContent.match(/^\\[sound:/) && !backContent.match(/^\\[sound:/)) {\n            score += 3\n          }\n          \n          if (!frontContent.match(/^\\d+$/) && !backContent.match(/^\\d+$/)) {\n            score += 2\n          }\n        }\n      }\n      \n      // Normalize score by number of valid pairs\n      const normalizedScore = validPairs > 0 ? score / validPairs : 0\n      combinations.push({ frontIndex: front, backIndex: back, score: normalizedScore })\n    }\n  }\n  \n  // Sort by score and return the best combination\n  combinations.sort((a, b) => b.score - a.score)\n  \n  if (combinations.length > 0 && combinations[0].score > 0) {\n    console.log(`Best field combination: ${combinations[0].frontIndex} -> ${combinations[0].backIndex} (score: ${combinations[0].score})`)\n    return { frontIndex: combinations[0].frontIndex, backIndex: combinations[0].backIndex }\n  }\n  \n  // Fallback to 0->1 or 0->2 if available\n  if (fieldCount >= 3) {\n    return { frontIndex: 0, backIndex: 2 }\n  }\n  return { frontIndex: 0, backIndex: 1 }\n}\n\n// Helper function to parse .apkg files (with dynamic imports for bundle optimization)\nconst parseApkgFile = async (file: File): Promise<{ name: string; cards: Array<{ front: string; back: string }> }> => {\n  try {\n    // Dynamic imports to reduce initial bundle size\n    const [{ default: JSZip }, { default: initSqlJs }] = await Promise.all([\n      import('jszip'),\n      import('sql.js')\n    ])\n\n    // Initialize SQL.js\n    const SQL = await initSqlJs({\n      locateFile: (file) => {\n        if (file.endsWith('.wasm')) {\n          return '/sql-wasm.wasm'\n        }\n        return `/${file}`\n      }\n    })\n\n    // Read the .apkg file as array buffer\n    const arrayBuffer = await file.arrayBuffer()\n    \n    // Extract the ZIP file\n    const zip = new JSZip()\n    const zipContent = await zip.loadAsync(arrayBuffer)\n    \n    // Get the collection.anki2 file (SQLite database)\n    const dbFile = zipContent.file('collection.anki2')\n    if (!dbFile) {\n      throw new Error('Invalid .apkg file: collection.anki2 not found')\n    }\n    \n    // Read the database file\n    const dbArrayBuffer = await dbFile.async('arraybuffer')\n    const db = new SQL.Database(new Uint8Array(dbArrayBuffer))\n    \n    // Query to get deck name from the col table\n    const deckQuery = db.exec(\"SELECT decks FROM col LIMIT 1\")\n    let deckName = file.name.replace(/\\.apkg$/, '')\n    if (deckQuery.length > 0 && deckQuery[0].values.length > 0) {\n      try {\n        const decksJson = deckQuery[0].values[0][0] as string\n        const decks = JSON.parse(decksJson)\n        // Find the first non-default deck (id != 1)\n        const deckIds = Object.keys(decks).filter(id => id !== '1')\n        if (deckIds.length > 0) {\n          deckName = decks[deckIds[0]].name || deckName\n        }\n      } catch (e) {\n        console.warn('Could not parse deck names from .apkg file, using filename')\n      }\n    }\n    \n    // Query to get notes and cards\n    const notesQuery = db.exec(`\n      SELECT n.flds, n.tags, c.type\n      FROM notes n\n      JOIN cards c ON n.id = c.nid\n      WHERE c.type >= 0\n      ORDER BY n.id\n    `)\n    \n    const cards: Array<{ front: string; back: string }> = []\n    \n    if (notesQuery.length > 0) {\n      // First, analyze a sample of fields to determine the best field combination\n      const sampleSize = Math.min(10, notesQuery[0].values.length)\n      const sampleFields: string[][] = []\n      \n      for (let i = 0; i < sampleSize; i++) {\n        const fields = (notesQuery[0].values[i][0] as string).split('\\x1f')\n        sampleFields.push(fields)\n      }\n      \n      // Detect the best field combination\n      const { frontIndex, backIndex } = detectBestFieldCombination(sampleFields)\n      console.log(`Using field combination: ${frontIndex} (front) -> ${backIndex} (back)`)\n      \n      // Process all cards using the detected field combination\n      for (const row of notesQuery[0].values) {\n        const fields = (row[0] as string).split('\\x1f') // Anki uses \\x1f as field separator\n        \n        if (fields.length > Math.max(frontIndex, backIndex)) {\n          const front = cleanFieldContent(fields[frontIndex] || '')\n          const back = cleanFieldContent(fields[backIndex] || '')\n          \n          if (front && back && front !== back) {\n            cards.push({ front, back })\n          }\n        }\n      }\n    }\n    \n    db.close()\n    \n    if (cards.length === 0) {\n      throw new Error('No valid cards found in the .apkg file')\n    }\n    \n    console.log(`Successfully parsed ${cards.length} cards from .apkg file`)\n    return { name: deckName, cards }\n  } catch (error) {\n    console.error('Error parsing .apkg file:', error)\n    throw new Error(`Failed to parse .apkg file: ${error instanceof Error ? error.message : 'Unknown error'}`)\n  }\n}\n\nexport const useDeckStore = create<DeckStore>()(\n  persist(\n    (set, get) => ({\n      decks: [],\n      cards: {},\n      currentStudySession: null,\n      isLoading: false,\n      error: null,\n      importProgress: 0,\n      importStatus: null,\n\n      createDeck: async (deckData) => {\n        set({ isLoading: true, error: null })\n        try {\n          const deck: Deck = {\n            ...deckData,\n            id: crypto.randomUUID(),\n            createdAt: new Date().toISOString(),\n            updatedAt: new Date().toISOString(),\n            settings: { ...defaultDeckSettings, ...deckData.settings }\n          }\n          \n          set(state => ({\n            decks: [...state.decks, deck],\n            cards: { ...state.cards, [deck.id]: [] },\n            isLoading: false\n          }))\n          \n          return deck\n        } catch (error) {\n          set({ error: 'Failed to create deck', isLoading: false })\n          throw error\n        }\n      },\n\n      updateDeck: async (id, updates) => {\n        set({ isLoading: true, error: null })\n        try {\n          set(state => ({\n            decks: state.decks.map(deck => \n              deck.id === id \n                ? { ...deck, ...updates, updatedAt: new Date().toISOString() }\n                : deck\n            ),\n            isLoading: false\n          }))\n        } catch (error) {\n          set({ error: 'Failed to update deck', isLoading: false })\n          throw error\n        }\n      },\n\n      deleteDeck: async (id) => {\n        set({ isLoading: true, error: null })\n        try {\n          set(state => {\n            // eslint-disable-next-line @typescript-eslint/no-unused-vars\n            const { [id]: _deletedCards, ...remainingCards } = state.cards\n            return {\n              decks: state.decks.filter(deck => deck.id !== id),\n              cards: remainingCards,\n              isLoading: false\n            }\n          })\n        } catch (error) {\n          set({ error: 'Failed to delete deck', isLoading: false })\n          throw error\n        }\n      },\n\n      getDeck: (id) => {\n        return get().decks.find(deck => deck.id === id)\n      },\n\n      addCard: async (deckId, cardData) => {\n        set({ isLoading: true, error: null })\n        try {\n          const card: Card = {\n            ...cardData,\n            id: crypto.randomUUID(),\n            deckId,\n            createdAt: new Date().toISOString(),\n            easeFactor: 2.5,\n            intervalDays: 0,\n            nextReview: new Date().toISOString(),\n            reviewCount: 0,\n            lapseCount: 0\n          }\n          \n          set(state => {\n            const deckCards = state.cards[deckId] || []\n            const updatedCards = [...deckCards, card]\n            \n            return {\n              cards: { ...state.cards, [deckId]: updatedCards },\n              decks: state.decks.map(deck => \n                deck.id === deckId \n                  ? { ...deck, cardCount: updatedCards.length, updatedAt: new Date().toISOString() }\n                  : deck\n              ),\n              isLoading: false\n            }\n          })\n          \n          return card\n        } catch (error) {\n          set({ error: 'Failed to add card', isLoading: false })\n          throw error\n        }\n      },\n\n      addCardBulk: async (deckId, cardData) => {\n        try {\n          const state = get()\n          const existingCards = state.cards[deckId] || []\n          \n          // Check if this card already exists\n          const cardKey = `${cardData.frontContent.trim().toLowerCase()}|${cardData.backContent.trim().toLowerCase()}`\n          const isDuplicate = existingCards.some(card =>\n            `${card.frontContent.trim().toLowerCase()}|${card.backContent.trim().toLowerCase()}` === cardKey\n          )\n          \n          if (isDuplicate) {\n            console.log('Skipping duplicate card:', cardData.frontContent)\n            // Return a dummy card to maintain the interface, but don't add it\n            return {\n              ...cardData,\n              id: 'duplicate-skipped',\n              deckId,\n              createdAt: new Date().toISOString(),\n              easeFactor: 2.5,\n              intervalDays: 0,\n              nextReview: new Date().toISOString(),\n              reviewCount: 0,\n              lapseCount: 0\n            }\n          }\n          \n          const card: Card = {\n            ...cardData,\n            id: crypto.randomUUID(),\n            deckId,\n            createdAt: new Date().toISOString(),\n            easeFactor: 2.5,\n            intervalDays: 0,\n            nextReview: new Date().toISOString(),\n            reviewCount: 0,\n            lapseCount: 0\n          }\n          \n          set(state => {\n            const deckCards = state.cards[deckId] || []\n            const updatedCards = [...deckCards, card]\n            \n            return {\n              cards: { ...state.cards, [deckId]: updatedCards },\n              decks: state.decks.map(deck =>\n                deck.id === deckId\n                  ? { ...deck, cardCount: updatedCards.length, updatedAt: new Date().toISOString() }\n                  : deck\n              )\n            }\n          })\n          \n          return card\n        } catch (error) {\n          console.error('Failed to add card during bulk import:', error)\n          throw error\n        }\n      },\n\n      createDeckBulk: async (deckData) => {\n        try {\n          const deck: Deck = {\n            ...deckData,\n            id: crypto.randomUUID(),\n            createdAt: new Date().toISOString(),\n            updatedAt: new Date().toISOString(),\n            settings: { ...defaultDeckSettings, ...deckData.settings }\n          }\n          \n          set(state => ({\n            decks: [...state.decks, deck],\n            cards: { ...state.cards, [deck.id]: [] }\n          }))\n          \n          return deck\n        } catch (error) {\n          console.error('Failed to create deck during bulk import:', error)\n          throw error\n        }\n      },\n\n      addCardsBatch: async (deckId, cardsData) => {\n        try {\n          const state = get()\n          const existingCards = state.cards[deckId] || []\n          \n          // Create a Set of existing card content for fast lookup\n          const existingCardSet = new Set(\n            existingCards.map(card => `${card.frontContent.trim().toLowerCase()}|${card.backContent.trim().toLowerCase()}`)\n          )\n          \n          // Filter out duplicates and create new cards\n          const uniqueCardsData = cardsData.filter(cardData => {\n            const cardKey = `${cardData.frontContent.trim().toLowerCase()}|${cardData.backContent.trim().toLowerCase()}`\n            return !existingCardSet.has(cardKey)\n          })\n          \n          console.log(`Batch processing: ${cardsData.length} cards submitted, ${uniqueCardsData.length} unique cards to add`)\n          \n          if (uniqueCardsData.length === 0) {\n            console.log('No new unique cards to add in this batch')\n            return []\n          }\n          \n          const cards: Card[] = uniqueCardsData.map(cardData => ({\n            ...cardData,\n            id: crypto.randomUUID(),\n            deckId,\n            createdAt: new Date().toISOString(),\n            easeFactor: 2.5,\n            intervalDays: 0,\n            nextReview: new Date().toISOString(),\n            reviewCount: 0,\n            lapseCount: 0\n          }))\n          \n          set(state => {\n            const deckCards = state.cards[deckId] || []\n            const updatedCards = [...deckCards, ...cards]\n            \n            return {\n              cards: { ...state.cards, [deckId]: updatedCards },\n              decks: state.decks.map(deck =>\n                deck.id === deckId\n                  ? { ...deck, cardCount: updatedCards.length, updatedAt: new Date().toISOString() }\n                  : deck\n              )\n            }\n          })\n          \n          return cards\n        } catch (error) {\n          console.error('Failed to add cards during batch import:', error)\n          throw error\n        }\n      },\n\n      updateCard: async (cardId, updates) => {\n        set({ isLoading: true, error: null })\n        try {\n          set(state => {\n            const newCards = { ...state.cards }\n            for (const deckId in newCards) {\n              newCards[deckId] = newCards[deckId].map(card =>\n                card.id === cardId ? { ...card, ...updates } : card\n              )\n            }\n            return { cards: newCards, isLoading: false }\n          })\n        } catch (error) {\n          set({ error: 'Failed to update card', isLoading: false })\n          throw error\n        }\n      },\n\n      deleteCard: async (cardId) => {\n        set({ isLoading: true, error: null })\n        try {\n          set(state => {\n            const newCards = { ...state.cards }\n            let targetDeckId = ''\n            \n            for (const deckId in newCards) {\n              const cardIndex = newCards[deckId].findIndex(card => card.id === cardId)\n              if (cardIndex !== -1) {\n                newCards[deckId] = newCards[deckId].filter(card => card.id !== cardId)\n                targetDeckId = deckId\n                break\n              }\n            }\n            \n            return {\n              cards: newCards,\n              decks: state.decks.map(deck => \n                deck.id === targetDeckId \n                  ? { ...deck, cardCount: newCards[targetDeckId].length, updatedAt: new Date().toISOString() }\n                  : deck\n              ),\n              isLoading: false\n            }\n          })\n        } catch (error) {\n          set({ error: 'Failed to delete card', isLoading: false })\n          throw error\n        }\n      },\n\n      getCards: (deckId) => {\n        return get().cards[deckId] || []\n      },\n\n      importAnkiDeck: async (file) => {\n        const { setImportProgress, resetImportProgress } = get()\n        set({ isLoading: true, error: null })\n        resetImportProgress()\n        \n        try {\n          const fileName = file.name.toLowerCase()\n          \n          // Handle different file types\n          if (fileName.endsWith('.apkg')) {\n            setImportProgress(10, 'Reading file...')\n            \n            // Parse .apkg file using the new parser\n            const { name, cards } = await parseApkgFile(file)\n\n            // Check if deck with the same name already exists\n            const existingDeck = get().decks.find(d => d.title === name);\n            if (existingDeck) {\n              throw new Error(`A deck named \"${name}\" already exists. Please rename the deck or the file before importing.`);\n            }\n            \n            setImportProgress(30, 'Creating deck...')\n            \n            // Create deck\n            const deck = await get().createDeckBulk({\n              userId: 'current-user',\n              title: name,\n              description: `Imported Anki deck with ${cards.length} cards`,\n              cardCount: 0,\n              isPublic: false,\n              settings: defaultDeckSettings,\n              category: 'imported'\n            })\n            \n            setImportProgress(40, `Importing ${cards.length} cards...`)\n            \n            // Remove duplicates from cards before batch processing\n            const uniqueCards: typeof cards = []\n            const seenCards = new Set<string>()\n            \n            for (const card of cards) {\n              const cardKey = `${card.front.trim().toLowerCase()}|${card.back.trim().toLowerCase()}`\n              if (!seenCards.has(cardKey)) {\n                seenCards.add(cardKey)\n                uniqueCards.push(card)\n              }\n            }\n            \n            console.log(`Removed ${cards.length - uniqueCards.length} duplicates from Anki cards. Processing ${uniqueCards.length} unique cards.`)\n            \n            // Process unique cards in smaller batches for better performance and reliability\n            const batchSize = 100\n            let successfulImports = 0\n            const totalCards = uniqueCards.length\n            \n            console.log(`Starting batch import of ${totalCards} unique cards`)\n            \n            for (let i = 0; i < totalCards; i += batchSize) {\n              const batch = uniqueCards.slice(i, i + batchSize)\n              const batchCards = batch.map(cardData => createNewCard(\n                cardData.front,\n                cardData.back,\n                { type: 'basic' as const },\n                []\n              ))\n              \n              try {\n                console.log(`Processing batch ${Math.floor(i / batchSize) + 1}/${Math.ceil(totalCards / batchSize)} (${batch.length} cards)`)\n                await get().addCardsBatch(deck.id, batchCards)\n                successfulImports += batch.length\n                \n                // Update progress (40% to 90% for card import)\n                const cardProgress = 40 + (50 * Math.min(i + batchSize, totalCards) / totalCards)\n                setImportProgress(cardProgress, `Imported ${successfulImports}/${totalCards} cards...`)\n                \n                console.log(`Batch completed. Progress: ${cardProgress.toFixed(1)}%`)\n                \n                // Add small delay to allow UI updates\n                await new Promise(resolve => setTimeout(resolve, 50))\n              } catch (cardError) {\n                console.error('Failed to import batch:', cardError)\n                // Try individual cards in this batch as fallback\n                for (const originalCard of batch) {\n                  try {\n                    await get().addCardBulk(deck.id, createNewCard(\n                      originalCard.front,\n                      originalCard.back,\n                      { type: 'basic' as const },\n                      []\n                    ))\n                    successfulImports++\n                  } catch (individualError) {\n                    console.warn('Failed to import individual card:', originalCard, individualError)\n                  }\n                }\n                \n                // Update progress even after fallback\n                const cardProgress = 40 + (50 * Math.min(i + batchSize, totalCards) / totalCards)\n                setImportProgress(cardProgress, `Imported ${successfulImports}/${totalCards} cards...`)\n              }\n            }\n            \n            console.log(`Batch import completed. Total successful: ${successfulImports}`)\n            \n            setImportProgress(95, 'Finalizing import...')\n            \n            // Update deck description with final count\n            await get().updateDeck(deck.id, {\n              description: `Imported Anki deck with ${successfulImports} cards`\n            })\n            \n            setImportProgress(100, 'Import completed!')\n            \n            // Clear progress after a short delay\n            setTimeout(() => {\n              resetImportProgress()\n            }, 1000)\n            \n            set({ isLoading: false })\n            return deck\n          } else if (fileName.endsWith('.txt') || fileName.endsWith('.tsv') || fileName.endsWith('.csv')) {\n            setImportProgress(10, 'Reading text file...')\n            \n            // Handle text-based imports\n            const text = await file.text()\n            \n            // Detect separator\n            let separator = '\\t' // Corrected: \t is a tab character\n            if (fileName.endsWith('.csv')) {\n              separator = ','\n            }\n            \n            setImportProgress(20, 'Processing text content...')\n            \n            // Clean the text and handle encoding issues\n            const cleanText = text\n              .replace(/\\r\\n/g, '\\n')  // Normalize line endings\n              .replace(/\\r/g, '\\n')    // Handle old Mac line endings\n              .trim()\n            \n            const deck = await get().importFromText(\n              file.name.replace(/\\.[^/.]+$/, \"\"),\n              cleanText,\n              separator\n            )\n            set({ isLoading: false })\n            return deck\n          } else {\n            setImportProgress(10, 'Reading file as text...')\n            \n            // Try to parse as text anyway\n            const text = await file.text()\n            \n            setImportProgress(20, 'Processing content...')\n            \n            const cleanText = text\n              .replace(/\\r\\n/g, '\\n')\n              .replace(/\\r/g, '\\n')\n              .trim()\n            \n            const deck = await get().importFromText(\n              file.name.replace(/\\.[^/.]+$/, \"\"),\n              cleanText,\n              '\\t'\n            )\n            set({ isLoading: false })\n            return deck\n          }\n        } catch (error) {\n          const errorMessage = error instanceof Error ? error.message : 'Failed to import Anki deck'\n          set({ error: errorMessage, isLoading: false })\n          resetImportProgress()\n          throw error\n        }\n      },\n\n      importFromText: async (deckName, text, separator = '\\t') => {\n        const { setImportProgress, resetImportProgress } = get()\n        set({ isLoading: true, error: null })\n        \n        try {\n          setImportProgress(30, 'Processing text content...')\n          \n          // Clean and normalize the text\n          const cleanText = text\n            .replace(/\\r\\n/g, '\\n')  // Normalize Windows line endings\n            .replace(/\\r/g, '\\n')    // Handle old Mac line endings\n            .replace(/\\\\u0000/g, '')  // Remove null characters\n            .replace(/[\\\\u0001-\\\\u0008\\\\u000B\\\\u000C\\\\u000E-\\\\u001F\\\\u007F]/g, '') // Remove control characters\n            .trim()\n          \n          const lines = cleanText\n            .split('\\n')\n            .map(line => line.trim())\n            .filter(line => line.length > 0)\n          \n          if (lines.length === 0) {\n            throw new Error('No valid content found in the file')\n          }\n          \n          setImportProgress(40, 'Creating deck...')\n          \n          const deck = await get().createDeckBulk({\n            userId: 'current-user', // This would come from auth store\n            title: deckName,\n            description: `Imported deck with ${lines.length} cards`,\n            cardCount: 0,\n            isPublic: false,\n            settings: defaultDeckSettings,\n            category: 'imported'\n          })\n          \n          setImportProgress(50, `Importing ${lines.length} cards...`)\n          \n          // Process lines and prepare cards for batch import\n          const validCards: Array<Omit<Card, 'id' | 'createdAt' | 'deckId' | 'easeFactor' | 'intervalDays' | 'nextReview' | 'reviewCount' | 'lapseCount'>> = []\n          let skippedLines = 0\n          \n          // First pass: parse and validate all lines\n          for (let i = 0; i < lines.length; i++) {\n            const line = lines[i]\n            try {\n              // Handle quoted fields (CSV style)\n              let parts: string[]\n              if (separator === ',' && line.includes('\"')) {\n                // Simple CSV parsing for quoted fields\n                parts = line.split(',').map(part =>\n                  part.replace(/^\"(.*)\"$/, '$1').trim()\n                )\n              } else {\n                parts = line.split(separator)\n              }\n              \n              if (parts.length >= 2) {\n                const front = parts[0].trim()\n                const back = parts[1].trim()\n                \n                // Skip empty cards\n                if (front && back) {\n                  validCards.push(createNewCard(\n                    front,\n                    back,\n                    { type: 'basic' as const },\n                    []\n                  ))\n                } else {\n                  skippedLines++\n                }\n              } else {\n                skippedLines++\n              }\n            } catch (cardError) {\n              console.warn('Failed to parse line:', line, cardError)\n              skippedLines++\n            }\n          }\n          \n          // Remove duplicates from validCards before batch processing\n          const uniqueValidCards: typeof validCards = []\n          const seenCards = new Set<string>()\n          \n          for (const card of validCards) {\n            const cardKey = `${card.frontContent.trim().toLowerCase()}|${card.backContent.trim().toLowerCase()}`\n            if (!seenCards.has(cardKey)) {\n              seenCards.add(cardKey)\n              uniqueValidCards.push(card)\n            }\n          }\n          \n          console.log(`Removed ${validCards.length - uniqueValidCards.length} duplicates from parsed cards. Processing ${uniqueValidCards.length} unique cards.`)\n          \n          // Second pass: batch import unique cards\n          const batchSize = 100\n          let successfulImports = 0\n          \n          console.log(`Starting text import batch processing of ${uniqueValidCards.length} unique cards`)\n          \n          for (let i = 0; i < uniqueValidCards.length; i += batchSize) {\n            const batch = uniqueValidCards.slice(i, i + batchSize)\n            \n            try {\n              console.log(`Processing text batch ${Math.floor(i / batchSize) + 1}/${Math.ceil(uniqueValidCards.length / batchSize)} (${batch.length} cards)`)\n              const addedCards = await get().addCardsBatch(deck.id, batch)\n              successfulImports += addedCards.length\n              \n              // Update progress (50% to 90% for card import)\n              const cardProgress = 50 + (40 * Math.min(i + batchSize, uniqueValidCards.length) / uniqueValidCards.length)\n              setImportProgress(cardProgress, `Imported ${successfulImports}/${uniqueValidCards.length} cards...`)\n              \n              console.log(`Text batch completed. Progress: ${cardProgress.toFixed(1)}%, Added: ${addedCards.length} cards`)\n              \n              // Add small delay to allow UI updates\n              await new Promise(resolve => setTimeout(resolve, 50))\n            } catch (cardError) {\n              console.error('Failed to import text batch:', cardError)\n              // Try individual cards in this batch as fallback\n              for (const cardData of batch) {\n                try {\n                  const addedCard = await get().addCardBulk(deck.id, cardData)\n                  if (addedCard.id !== 'duplicate-skipped') {\n                    successfulImports++\n                  }\n                } catch (individualError) {\n                  console.warn('Failed to import individual text card:', cardData, individualError)\n                }\n              }\n              \n              // Update progress even after fallback\n              const cardProgress = 50 + (40 * Math.min(i + batchSize, uniqueValidCards.length) / uniqueValidCards.length)\n              setImportProgress(cardProgress, `Imported ${successfulImports}/${uniqueValidCards.length} cards...`)\n            }\n          }\n          \n          console.log(`Text import batch processing completed. Total successful: ${successfulImports}`)\n          \n          setImportProgress(95, 'Finalizing import...')\n          \n          // Update deck description with import results\n          await get().updateDeck(deck.id, {\n            description: `Imported deck with ${successfulImports} cards${skippedLines > 0 ? ` (${skippedLines} lines skipped)` : ''}`\n          })\n          \n          if (successfulImports === 0) {\n            throw new Error('No valid cards could be imported. Please check the file format.')\n          }\n          \n          setImportProgress(100, 'Import completed!')\n          \n          // Clear progress after a short delay\n          setTimeout(() => {\n            resetImportProgress()\n          }, 1000)\n          \n          set({ isLoading: false })\n          return deck\n        } catch (error) {\n          set({ error: 'Failed to import from text', isLoading: false })\n          resetImportProgress()\n          throw error\n        }\n      },\n\n      loadExampleDecks: async () => {\n        set({ isLoading: true, error: null })\n        try {\n          const state = get()\n          \n          // Check if example decks already exist to prevent duplicates\n          const existingTitles = new Set(state.decks.map(deck => deck.title))\n          const exampleTitles = ['Spanish Vocabulary', 'JavaScript Concepts', 'World Capitals']\n          \n          // If any example deck already exists, don't load any\n          if (exampleTitles.some(title => existingTitles.has(title))) {\n            console.log('Example decks already exist, skipping load')\n            set({ isLoading: false })\n            return\n          }\n\n          const exampleDecks = [\n            {\n              title: 'Spanish Vocabulary',\n              description: 'Essential Spanish words for beginners',\n              category: 'language',\n              cards: [\n                { front: 'Hello', back: 'Hola' },\n                { front: 'Goodbye', back: 'Adis' },\n                { front: 'Thank you', back: 'Gracias' },\n                { front: 'Please', back: 'Por favor' },\n                { front: 'Yes', back: 'S' },\n                { front: 'No', back: 'No' },\n                { front: 'Water', back: 'Agua' },\n                { front: 'Food', back: 'Comida' },\n                { front: 'House', back: 'Casa' },\n                { front: 'Car', back: 'Coche' }\n              ]\n            },\n            {\n              title: 'JavaScript Concepts',\n              description: 'Important JavaScript programming concepts',\n              category: 'programming',\n              cards: [\n                { front: 'What is a closure?', back: 'A closure is a function that has access to variables in its outer (enclosing) scope even after the outer function has returned.' },\n                { front: 'What is hoisting?', back: 'Hoisting is JavaScript\\'s default behavior of moving declarations to the top of their scope.' },\n                { front: 'What is the difference between let and var?', back: 'let has block scope and cannot be redeclared, while var has function scope and can be redeclared.' },\n                { front: 'What is a Promise?', back: 'A Promise is an object representing the eventual completion or failure of an asynchronous operation.' },\n                { front: 'What is async/await?', back: 'async/await is syntactic sugar for working with Promises, making asynchronous code look more like synchronous code.' }\n              ]\n            },\n            {\n              title: 'World Capitals',\n              description: 'Capital cities of countries around the world',\n              category: 'geography',\n              cards: [\n                { front: 'France', back: 'Paris' },\n                { front: 'Germany', back: 'Berlin' },\n                { front: 'Italy', back: 'Rome' },\n                { front: 'Spain', back: 'Madrid' },\n                { front: 'United Kingdom', back: 'London' },\n                { front: 'Japan', back: 'Tokyo' },\n                { front: 'China', back: 'Beijing' },\n                { front: 'Australia', back: 'Canberra' },\n                { front: 'Brazil', back: 'Braslia' },\n                { front: 'Canada', back: 'Ottawa' }\n              ]\n            }\n          ]\n\n          console.log('Loading example decks...')\n          for (const deckData of exampleDecks) {\n            const deck = await get().createDeck({\n              userId: 'current-user',\n              title: deckData.title,\n              description: deckData.description,\n              cardCount: 0,\n              isPublic: false,\n              settings: defaultDeckSettings,\n              category: deckData.category,\n              tags: [deckData.category]\n            })\n\n            for (const cardData of deckData.cards) {\n              await get().addCard(deck.id, createNewCard(\n                cardData.front,\n                cardData.back,\n                { type: 'basic' },\n                []\n              ))\n            }\n          }\n\n          console.log('Example decks loaded successfully')\n          set({ isLoading: false })\n        } catch (error) {\n          set({ error: 'Failed to load example decks', isLoading: false })\n          throw error\n        }\n      },\n\n      clearError: () => set({ error: null }),\n      setLoading: (loading) => set({ isLoading: loading }),\n      removeDuplicateCards: async (deckId) => {\n        try {\n          const state = get()\n          const deckCards = state.cards[deckId] || []\n          \n          if (deckCards.length === 0) {\n            return 0\n          }\n          \n          // Create a Map to track unique cards (first occurrence wins)\n          const uniqueCardsMap = new Map<string, Card>()\n          let duplicatesRemoved = 0\n          \n          for (const card of deckCards) {\n            const cardKey = `${card.frontContent.trim().toLowerCase()}|${card.backContent.trim().toLowerCase()}`\n            \n            if (!uniqueCardsMap.has(cardKey)) {\n              uniqueCardsMap.set(cardKey, card)\n            } else {\n              duplicatesRemoved++\n              console.log(`Removing duplicate card: ${card.frontContent}`)\n            }\n          }\n          \n          const uniqueCards = Array.from(uniqueCardsMap.values())\n          \n          if (duplicatesRemoved > 0) {\n            set(state => ({\n              cards: { ...state.cards, [deckId]: uniqueCards },\n              decks: state.decks.map(deck =>\n                deck.id === deckId\n                  ? { ...deck, cardCount: uniqueCards.length, updatedAt: new Date().toISOString() }\n                  : deck\n              )\n            }))\n            \n            console.log(`Removed ${duplicatesRemoved} duplicate cards from deck. ${uniqueCards.length} unique cards remaining.`)\n          }\n          \n          return duplicatesRemoved\n        } catch (error) {\n          console.error('Failed to remove duplicate cards:', error)\n          throw error\n        }\n      },\n\n      setImportProgress: (progress, status) => set({ importProgress: progress, importStatus: status }),\n      resetImportProgress: () => set({ importProgress: 0, importStatus: null }),\n\n      // Study session functions\n            startStudySession: (deckId, studyCards) => {\n        const studyCardIds = studyCards.map(c => c.id);\n        set({\n          currentStudySession: {\n            deckId,\n            currentCardIndex: 0,\n            studyCards, // Keep full cards for in-memory access\n            studyCardIds, // Add the IDs for persistence\n            sessionStats: {\n              total: studyCards.length,\n              correct: 0,\n              incorrect: 0\n            },\n            startedAt: new Date().toISOString()\n          }\n        })\n      },\n\n      updateStudySession: (currentCardIndex, sessionStats) => {\n        set(state => ({\n          currentStudySession: state.currentStudySession ? {\n            ...state.currentStudySession,\n            currentCardIndex,\n            sessionStats\n          } : null\n        }))\n      },\n\n      clearStudySession: () => {\n        set({ currentStudySession: null })\n      },\n\n      getStudySession: (deckId) => {\n        const state = get()\n        return state.currentStudySession?.deckId === deckId ? state.currentStudySession : null\n      },\n\n      resetAllStudyData: () => {\n        // Reset all study-related data but keep decks and cards\n        set(state => {\n          // Reset all card progress data\n          const resetCards: Record<string, Card[]> = {}\n          \n          for (const [deckId, cards] of Object.entries(state.cards)) {\n            resetCards[deckId] = cards.map(card => ({\n              ...card,\n              easeFactor: 2.5,\n              intervalDays: 0,\n              nextReview: new Date().toISOString(),\n              reviewCount: 0,\n              lapseCount: 0\n            }))\n          }\n          \n          return {\n            cards: resetCards,\n            currentStudySession: null\n          }\n        })\n      }\n    }),\n    {\n      name: 'deck-storage',\n      // This function selects which parts of the state to save\n      partialize: (state) => {\n        // 1. Exclude the top-level 'cards' object entirely.\n        // 2. From the 'currentStudySession', exclude the 'studyCards' array of full objects.\n        const { cards, currentStudySession, ...restOfState } = state;\n\n        const sessionToPersist = currentStudySession\n          ? {\n              deckId: currentStudySession.deckId,\n              currentCardIndex: currentStudySession.currentCardIndex,\n              studyCardIds: currentStudySession.studyCardIds, // Only persist the IDs\n              sessionStats: currentStudySession.sessionStats,\n              startedAt: currentStudySession.startedAt,\n            }\n          : null;\n\n        // Return a new object containing only the data we want to persist.\n        // Note: `decks` are preserved via `restOfState`.\n        return { ...restOfState, currentStudySession: sessionToPersist };\n      },\n    }\n  )\n)\n\nexport const useCurrentCard = (): Card | null => {\n  const store = useDeckStore();\n  const session = store.currentStudySession;\n\n  if (!session || !session.studyCardIds || session.studyCardIds.length === 0) {\n    return null;\n  }\n\n  const currentCardId = session.studyCardIds[session.currentCardIndex];\n  if (!currentCardId) {\n    return null;\n  }\n\n  // The full, non-persisted `cards` object holds all cards for the current deck.\n  const deckCards = store.cards[session.deckId] || [];\n  return deckCards.find(card => card.id === currentCardId) || null;\n};"],"file":"assets/stores-Y6SjqVOq.js"}