{"version":3,"file":"services-Bz8hlk9K.js","sources":["../../src/services/userDataService.ts","../../src/services/realTimeDataService.ts","../../src/services/uamsApiService.ts","../../src/services/unifiedQueueManager.ts","../../src/services/environmental/environmentalContextService.ts"],"sourcesContent":["import type {\r\n  User\r\n} from '@shared/types';\r\nimport { pb } from '../lib/pocketbase';\r\nimport { debugLogger } from '../utils/debugLogger';\r\n\r\n// Extended User interface for authentication context\r\nexport interface AuthenticatedUser extends User {\r\n  token?: string;\r\n  tokenType?: 'demo' | 'mock' | 'real';\r\n}\r\n\r\n// Types for user data and statistics\r\nexport interface UserStats {\r\n  totalXP: number;\r\n  level: number;\r\n  currentLevelXP: number;\r\n  nextLevelXP: number;\r\n  cardsStudied: number;\r\n  studyTime: number; // in minutes\r\n  accuracy: number; // percentage\r\n  currentStreak: number;\r\n  longestStreak: number;\r\n  coins: number;\r\n  gems: number;\r\n  lastStudyDate: string;\r\n  joinDate: string;\r\n}\r\n\r\nexport interface UserActivity {\r\n  date: string;\r\n  cardsStudied: number;\r\n  studyTime: number;\r\n  accuracy: number;\r\n  xpGained: number;\r\n}\r\n\r\nexport interface UserAchievement {\r\n  id: string;\r\n  name: string;\r\n  description: string;\r\n  icon: string;\r\n  unlockedAt: string;\r\n  category: 'study' | 'streak' | 'accuracy' | 'time' | 'social';\r\n}\r\n\r\nexport interface UserChallenge {\r\n  id: string;\r\n  name: string;\r\n  description: string;\r\n  type: 'daily' | 'weekly' | 'monthly';\r\n  target: number;\r\n  current: number;\r\n  reward: {\r\n    xp: number;\r\n    coins: number;\r\n    gems?: number;\r\n  };\r\n  expiresAt: string;\r\n  completedAt?: string;\r\n}\r\n\r\nexport interface UserPerformanceMetrics {\r\n  weeklyProgress: {\r\n    cardsStudied: number;\r\n    studyTime: number;\r\n    accuracy: number;\r\n    goal: number;\r\n  };\r\n  monthlyProgress: {\r\n    cardsStudied: number;\r\n    studyTime: number;\r\n    decksCompleted: number;\r\n  };\r\n  studyPattern: {\r\n    preferredTime: string;\r\n    averageSessionLength: number;\r\n    studyFrequency: number;\r\n  };\r\n}\r\n\r\nexport interface LeaderboardEntry {\r\n  userId: string;\r\n  username: string;\r\n  avatar?: string;\r\n  score: number;\r\n  rank: number;\r\n  change: number; // position change from last period\r\n}\r\n\r\nexport interface LeaderboardData {\r\n  global: LeaderboardEntry[];\r\n  friends: LeaderboardEntry[];\r\n  weekly: LeaderboardEntry[];\r\n  monthly: LeaderboardEntry[];\r\n}\r\n\r\n// Demo data for demo users\r\nconst DEMO_USER_STATS: UserStats = {\r\n  totalXP: 2500,\r\n  level: 5,\r\n  currentLevelXP: 100,\r\n  nextLevelXP: 500,\r\n  cardsStudied: 1250,\r\n  studyTime: 2400, // 40 hours\r\n  accuracy: 87.5,\r\n  currentStreak: 15,\r\n  longestStreak: 28,\r\n  coins: 150,\r\n  gems: 10,\r\n  lastStudyDate: new Date().toISOString(),\r\n  joinDate: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString()\r\n};\r\n\r\nconst DEMO_ACHIEVEMENTS: UserAchievement[] = [\r\n  {\r\n    id: 'first_study',\r\n    name: 'First Steps',\r\n    description: 'Complete your first study session',\r\n    icon: 'ðŸŽ¯',\r\n    unlockedAt: new Date(Date.now() - 25 * 24 * 60 * 60 * 1000).toISOString(),\r\n    category: 'study'\r\n  },\r\n  {\r\n    id: 'week_streak',\r\n    name: 'Week Warrior',\r\n    description: 'Study for 7 days in a row',\r\n    icon: 'ðŸ”¥',\r\n    unlockedAt: new Date(Date.now() - 10 * 24 * 60 * 60 * 1000).toISOString(),\r\n    category: 'streak'\r\n  }\r\n];\r\n\r\n// Enhanced Monthly Challenges\r\nconst ENHANCED_MONTHLY_CHALLENGES: UserChallenge[] = [\r\n  {\r\n    id: 'monthly_mastery',\r\n    name: 'Monthly Mastery Challenge',\r\n    description: 'Complete an intensive month-long study challenge with progressive difficulty',\r\n    type: 'monthly',\r\n    target: 1000,\r\n    current: 245,\r\n    reward: { xp: 1500, coins: 500, gems: 50 },\r\n    expiresAt: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString()\r\n  },\r\n  {\r\n    id: 'knowledge_seeker',\r\n    name: 'Knowledge Seeker',\r\n    description: 'Explore diverse subjects and maintain high accuracy throughout the month',\r\n    type: 'monthly',\r\n    target: 800,\r\n    current: 156,\r\n    reward: { xp: 1200, coins: 400, gems: 30 },\r\n    expiresAt: new Date(Date.now() + 25 * 24 * 60 * 60 * 1000).toISOString()\r\n  }\r\n];\r\n\r\nconst DEMO_CHALLENGES: UserChallenge[] = [\r\n  {\r\n    id: 'daily_grind',\r\n    name: 'Daily Grind',\r\n    description: 'Study 25 cards today',\r\n    type: 'daily',\r\n    target: 25,\r\n    current: 18,\r\n    reward: { xp: 50, coins: 10 },\r\n    expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString()\r\n  },\r\n  {\r\n    id: 'weekly_warrior',\r\n    name: 'Weekly Warrior',\r\n    description: 'Study 200 cards this week',\r\n    type: 'weekly',\r\n    target: 200,\r\n    current: 145,\r\n    reward: { xp: 200, coins: 50, gems: 5 },\r\n    expiresAt: new Date(Date.now() + 3 * 24 * 60 * 60 * 1000).toISOString()\r\n  },\r\n  ...ENHANCED_MONTHLY_CHALLENGES\r\n];\r\n\r\nconst DEMO_LEADERBOARD: LeaderboardData = {\r\n  global: [\r\n    { userId: 'demo1', username: 'StudyMaster', score: 5420, rank: 1, change: 0 },\r\n    { userId: 'demo2', username: 'FlashcardPro', score: 4890, rank: 2, change: 1 },\r\n    { userId: 'demo3', username: 'MemoryWiz', score: 4650, rank: 3, change: -1 },\r\n    { userId: 'demo4', username: 'QuizKing', score: 4200, rank: 4, change: 2 },\r\n    { userId: 'demo_user', username: 'Demo User', score: 2500, rank: 15, change: 3 }\r\n  ],\r\n  friends: [\r\n    { userId: 'friend1', username: 'StudyBuddy', score: 3200, rank: 1, change: 0 },\r\n    { userId: 'demo_user', username: 'Demo User', score: 2500, rank: 2, change: 1 },\r\n    { userId: 'friend2', username: 'LearningPal', score: 2100, rank: 3, change: -1 }\r\n  ],\r\n  weekly: [\r\n    { userId: 'demo1', username: 'StudyMaster', score: 890, rank: 1, change: 2 },\r\n    { userId: 'demo_user', username: 'Demo User', score: 420, rank: 8, change: 5 }\r\n  ],\r\n  monthly: [\r\n    { userId: 'demo1', username: 'StudyMaster', score: 3200, rank: 1, change: 0 },\r\n    { userId: 'demo_user', username: 'Demo User', score: 1800, rank: 12, change: -2 }\r\n  ]\r\n};\r\n\r\n// API service class\r\nexport class UserDataService {\r\n  private baseUrl = '/api';\r\n\r\n  // Check if user is demo user\r\n  private isDemoUser(user: AuthenticatedUser): boolean {\r\n    return user.tokenType === 'demo' || user.email === 'demo@studymaster.app';\r\n  }\r\n\r\n  // Get user statistics\r\n  async getUserStats(user: AuthenticatedUser): Promise<UserStats> {\r\n    debugLogger.log('[USER_DATA_SERVICE]', 'START - getUserStats', {\r\n      userId: user.id,\r\n      isDemoUser: this.isDemoUser(user)\r\n    });\r\n\r\n    if (this.isDemoUser(user)) {\r\n      debugLogger.log('[USER_DATA_SERVICE]', 'Returning demo user stats');\r\n      return DEMO_USER_STATS;\r\n    }\r\n\r\n    // Primary: Try PocketBase\r\n    try {\r\n      debugLogger.log('[USER_DATA_SERVICE]', 'Attempting to fetch user stats from PocketBase');\r\n      \r\n      const userRecord = await pb.collection('users').getOne(user.id, {\r\n        fields: 'level,total_xp,coins,gems,last_active,created,preferences'\r\n      });\r\n\r\n      debugLogger.log('[USER_DATA_SERVICE]', 'PocketBase user stats fetched successfully');\r\n\r\n      // Convert PocketBase record to UserStats format\r\n      const stats: UserStats = {\r\n        totalXP: userRecord.total_xp || 0,\r\n        level: userRecord.level || 1,\r\n        currentLevelXP: (userRecord.total_xp || 0) % 200, // Assuming 200 XP per level\r\n        nextLevelXP: 200,\r\n        cardsStudied: 0, // Will need to calculate from study sessions\r\n        studyTime: 0, // Will need to calculate from study sessions\r\n        accuracy: 85, // Default value, calculate from actual data later\r\n        currentStreak: 0, // Calculate from study sessions\r\n        longestStreak: 0, // Calculate from study sessions\r\n        coins: userRecord.coins || 100,\r\n        gems: userRecord.gems || 10,\r\n        lastStudyDate: userRecord.last_active || new Date().toISOString(),\r\n        joinDate: userRecord.created || new Date().toISOString()\r\n      };\r\n\r\n      return stats;\r\n    } catch (pocketbaseError) {\r\n      debugLogger.warn('[USER_DATA_SERVICE]', 'PocketBase fetch failed, trying REST API fallback', {\r\n        error: pocketbaseError\r\n      });\r\n\r\n      // Fallback: Try REST API\r\n      try {\r\n        const response = await fetch(`${this.baseUrl}/users/${user.id}/stats`, {\r\n          headers: {\r\n            'Authorization': `Bearer ${user.token}`,\r\n            'Content-Type': 'application/json'\r\n          }\r\n        });\r\n\r\n        if (!response.ok) {\r\n          throw new Error('Failed to fetch user stats from REST API');\r\n        }\r\n\r\n        const data = await response.json();\r\n        debugLogger.log('[USER_DATA_SERVICE]', 'REST API user stats fetched successfully');\r\n        return data;\r\n      } catch (apiError) {\r\n        debugLogger.warn('[USER_DATA_SERVICE]', 'Both PocketBase and REST API failed, using mock data', {\r\n          pocketbaseError,\r\n          apiError\r\n        });\r\n        \r\n        // Final fallback: Return personalized mock data\r\n        return this.generatePersonalizedMockStats(user);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Get user activity history\r\n  async getUserActivity(user: AuthenticatedUser, days: number = 30): Promise<UserActivity[]> {\r\n    if (this.isDemoUser(user)) {\r\n      return this.generateDemoActivity(days);\r\n    }\r\n\r\n    try {\r\n      const response = await fetch(`${this.baseUrl}/users/${user.id}/activity?days=${days}`, {\r\n        headers: {\r\n          'Authorization': `Bearer ${user.token}`,\r\n          'Content-Type': 'application/json'\r\n        }\r\n      });\r\n\r\n      if (!response.ok) {\r\n        throw new Error('Failed to fetch user activity');\r\n      }\r\n\r\n      return await response.json();\r\n    } catch (error) {\r\n      console.warn('Failed to fetch real user activity, using mock data:', error);\r\n      return this.generatePersonalizedActivity(user, days);\r\n    }\r\n  }\r\n\r\n  // Get user achievements\r\n  async getUserAchievements(user: AuthenticatedUser): Promise<UserAchievement[]> {\r\n    if (this.isDemoUser(user)) {\r\n      return DEMO_ACHIEVEMENTS;\r\n    }\r\n\r\n    try {\r\n      const response = await fetch(`${this.baseUrl}/users/${user.id}/achievements`, {\r\n        headers: {\r\n          'Authorization': `Bearer ${user.token}`,\r\n          'Content-Type': 'application/json'\r\n        }\r\n      });\r\n\r\n      if (!response.ok) {\r\n        throw new Error('Failed to fetch user achievements');\r\n      }\r\n\r\n      return await response.json();\r\n    } catch (error) {\r\n      console.warn('Failed to fetch real user achievements, using mock data:', error);\r\n      return this.generatePersonalizedAchievements(user);\r\n    }\r\n  }\r\n\r\n  // Get user challenges\r\n  async getUserChallenges(user: AuthenticatedUser): Promise<UserChallenge[]> {\r\n    if (this.isDemoUser(user)) {\r\n      return DEMO_CHALLENGES;\r\n    }\r\n\r\n    try {\r\n      const response = await fetch(`${this.baseUrl}/users/${user.id}/challenges`, {\r\n        headers: {\r\n          'Authorization': `Bearer ${user.token}`,\r\n          'Content-Type': 'application/json'\r\n        }\r\n      });\r\n\r\n      if (!response.ok) {\r\n        throw new Error('Failed to fetch user challenges');\r\n      }\r\n\r\n      return await response.json();\r\n    } catch (error) {\r\n      console.warn('Failed to fetch real user challenges, using mock data:', error);\r\n      return this.generatePersonalizedChallenges(user);\r\n    }\r\n  }\r\n\r\n  // Get leaderboard data\r\n  async getLeaderboardData(user: AuthenticatedUser): Promise<LeaderboardData> {\r\n    if (this.isDemoUser(user)) {\r\n      return DEMO_LEADERBOARD;\r\n    }\r\n\r\n    try {\r\n      const response = await fetch(`${this.baseUrl}/leaderboard`, {\r\n        headers: {\r\n          'Authorization': `Bearer ${user.token}`,\r\n          'Content-Type': 'application/json'\r\n        }\r\n      });\r\n\r\n      if (!response.ok) {\r\n        throw new Error('Failed to fetch leaderboard data');\r\n      }\r\n\r\n      return await response.json();\r\n    } catch (error) {\r\n      console.warn('Failed to fetch real leaderboard data, using mock data:', error);\r\n      return this.generatePersonalizedLeaderboard(user);\r\n    }\r\n  }\r\n\r\n  // Get performance metrics\r\n  async getPerformanceMetrics(user: AuthenticatedUser): Promise<UserPerformanceMetrics> {\r\n    if (this.isDemoUser(user)) {\r\n      return this.generateDemoPerformanceMetrics();\r\n    }\r\n\r\n    try {\r\n      const response = await fetch(`${this.baseUrl}/users/${user.id}/performance`, {\r\n        headers: {\r\n          'Authorization': `Bearer ${user.token}`,\r\n          'Content-Type': 'application/json'\r\n        }\r\n      });\r\n\r\n      if (!response.ok) {\r\n        throw new Error('Failed to fetch performance metrics');\r\n      }\r\n\r\n      return await response.json();\r\n    } catch (error) {\r\n      console.warn('Failed to fetch real performance metrics, using mock data:', error);\r\n      return this.generatePersonalizedPerformanceMetrics(user);\r\n    }\r\n  }\r\n\r\n  // Get comprehensive user profile data\r\n  async getCompleteUserProfile(user: AuthenticatedUser): Promise<{\r\n    stats: UserStats;\r\n    activity: UserActivity[];\r\n    achievements: UserAchievement[];\r\n    challenges: UserChallenge[];\r\n    performance: UserPerformanceMetrics;\r\n  }> {\r\n    const [stats, activity, achievements, challenges, performance] = await Promise.all([\r\n      this.getUserStats(user),\r\n      this.getUserActivity(user, 30),\r\n      this.getUserAchievements(user),\r\n      this.getUserChallenges(user),\r\n      this.getPerformanceMetrics(user)\r\n    ]);\r\n\r\n    return {\r\n      stats,\r\n      activity,\r\n      achievements,\r\n      challenges,\r\n      performance\r\n    };\r\n  }\r\n\r\n  // Reset all user data\r\n  async resetAllUserData(user: AuthenticatedUser): Promise<void> {\r\n    if (this.isDemoUser(user)) {\r\n      // For demo users, we don't need to do anything as data is static\r\n      return;\r\n    }\r\n\r\n    try {\r\n      const response = await fetch(`${this.baseUrl}/users/${user.id}/reset`, {\r\n        method: 'POST',\r\n        headers: {\r\n          'Authorization': `Bearer ${user.token}`,\r\n          'Content-Type': 'application/json'\r\n        }\r\n      });\r\n\r\n      if (!response.ok) {\r\n        throw new Error('Failed to reset user data');\r\n      }\r\n    } catch (error) {\r\n      console.warn('Failed to reset real user data via API:', error);\r\n      // For mock users, we don't need to do anything as the stores will handle the reset\r\n      // The error is expected when API is not available\r\n    }\r\n  }\r\n\r\n  // Generate personalized mock data for authenticated users\r\n  private generatePersonalizedMockStats(user: AuthenticatedUser): UserStats {\r\n    const userHash = this.hashString(user.email);\r\n    const daysSinceJoin = Math.floor(userHash % 60) + 1; // 1-60 days\r\n    \r\n    return {\r\n      totalXP: Math.floor(userHash % 1000) + 100,\r\n      level: Math.floor((userHash % 1000) / 200) + 1,\r\n      currentLevelXP: userHash % 200,\r\n      nextLevelXP: 200,\r\n      cardsStudied: Math.floor(userHash % 500) + 50,\r\n      studyTime: Math.floor(userHash % 1200) + 60, // 1-20 hours\r\n      accuracy: 75 + (userHash % 20), // 75-95%\r\n      currentStreak: Math.floor(userHash % 15) + 1,\r\n      longestStreak: Math.floor(userHash % 30) + 5,\r\n      coins: Math.floor(userHash % 200) + 50,\r\n      gems: Math.floor(userHash % 20) + 5,\r\n      lastStudyDate: new Date().toISOString(),\r\n      joinDate: new Date(Date.now() - daysSinceJoin * 24 * 60 * 60 * 1000).toISOString()\r\n    };\r\n  }\r\n\r\n  private generatePersonalizedActivity(user: AuthenticatedUser, days: number): UserActivity[] {\r\n    const activities: UserActivity[] = [];\r\n    \r\n    for (let i = 0; i < days; i++) {\r\n      const date = new Date(Date.now() - i * 24 * 60 * 60 * 1000);\r\n      const dayHash = this.hashString(user.email + date.toDateString());\r\n      \r\n      // Some days have no activity\r\n      if (dayHash % 4 === 0) continue;\r\n      \r\n      activities.push({\r\n        date: date.toISOString().split('T')[0],\r\n        cardsStudied: Math.floor(dayHash % 50) + 5,\r\n        studyTime: Math.floor(dayHash % 120) + 10,\r\n        accuracy: 70 + (dayHash % 25),\r\n        xpGained: Math.floor(dayHash % 100) + 20\r\n      });\r\n    }\r\n    \r\n    return activities.reverse();\r\n  }\r\n\r\n  private generatePersonalizedAchievements(user: AuthenticatedUser): UserAchievement[] {\r\n    const userHash = this.hashString(user.email);\r\n    const baseAchievements = [...DEMO_ACHIEVEMENTS];\r\n    \r\n    // Add user-specific achievements based on their hash\r\n    if (userHash % 3 === 0) {\r\n      baseAchievements.push({\r\n        id: 'accuracy_master',\r\n        name: 'Accuracy Master',\r\n        description: 'Achieve 90% accuracy in a session',\r\n        icon: 'ðŸŽ¯',\r\n        unlockedAt: new Date(Date.now() - 5 * 24 * 60 * 60 * 1000).toISOString(),\r\n        category: 'accuracy'\r\n      });\r\n    }\r\n    \r\n    return baseAchievements;\r\n  }\r\n\r\n  private generatePersonalizedChallenges(user: AuthenticatedUser): UserChallenge[] {\r\n    // Generate personalized data based on user email\r\n    const challenges = [...DEMO_CHALLENGES];\r\n    \r\n    // Personalize challenge progress based on user\r\n    challenges.forEach(challenge => {\r\n      const progressHash = this.hashString(user.email + challenge.id);\r\n      challenge.current = Math.floor((progressHash % 80) / 100 * challenge.target);\r\n    });\r\n    \r\n    return challenges;\r\n  }\r\n\r\n  private generatePersonalizedLeaderboard(user: AuthenticatedUser): LeaderboardData {\r\n    const userHash = this.hashString(user.email);\r\n    const userScore = Math.floor(userHash % 1000) + 100;\r\n    const userRank = Math.floor(userHash % 50) + 5;\r\n    \r\n    const leaderboard = { ...DEMO_LEADERBOARD };\r\n    \r\n    // Insert user into leaderboards\r\n    leaderboard.global.push({\r\n      userId: user.id,\r\n      username: user.username,\r\n      score: userScore,\r\n      rank: userRank,\r\n      change: Math.floor(userHash % 10) - 5\r\n    });\r\n    \r\n    return leaderboard;\r\n  }\r\n\r\n  private generateDemoActivity(days: number): UserActivity[] {\r\n    const activities: UserActivity[] = [];\r\n    \r\n    for (let i = 0; i < days; i++) {\r\n      const date = new Date(Date.now() - i * 24 * 60 * 60 * 1000);\r\n      \r\n      // Skip some days to make it realistic\r\n      if (i % 3 === 0) continue;\r\n      \r\n      activities.push({\r\n        date: date.toISOString().split('T')[0],\r\n        cardsStudied: Math.floor(Math.random() * 40) + 10,\r\n        studyTime: Math.floor(Math.random() * 90) + 15,\r\n        accuracy: 80 + Math.floor(Math.random() * 15),\r\n        xpGained: Math.floor(Math.random() * 80) + 30\r\n      });\r\n    }\r\n    \r\n    return activities.reverse();\r\n  }\r\n\r\n  private generateDemoPerformanceMetrics(): UserPerformanceMetrics {\r\n    return {\r\n      weeklyProgress: {\r\n        cardsStudied: 180,\r\n        studyTime: 240, // 4 hours\r\n        accuracy: 87.5,\r\n        goal: 350\r\n      },\r\n      monthlyProgress: {\r\n        cardsStudied: 720,\r\n        studyTime: 1200, // 20 hours\r\n        decksCompleted: 8\r\n      },\r\n      studyPattern: {\r\n        preferredTime: 'evening',\r\n        averageSessionLength: 25,\r\n        studyFrequency: 5.2\r\n      }\r\n    };\r\n  }\r\n\r\n  private generatePersonalizedPerformanceMetrics(user: AuthenticatedUser): UserPerformanceMetrics {\r\n    const userHash = this.hashString(user.email);\r\n    \r\n    return {\r\n      weeklyProgress: {\r\n        cardsStudied: Math.floor(userHash % 200) + 50,\r\n        studyTime: Math.floor(userHash % 300) + 60,\r\n        accuracy: 75 + (userHash % 20),\r\n        goal: 300\r\n      },\r\n      monthlyProgress: {\r\n        cardsStudied: Math.floor(userHash % 800) + 200,\r\n        studyTime: Math.floor(userHash % 1500) + 300,\r\n        decksCompleted: Math.floor(userHash % 15) + 3\r\n      },\r\n      studyPattern: {\r\n        preferredTime: ['morning', 'afternoon', 'evening'][userHash % 3],\r\n        averageSessionLength: Math.floor(userHash % 30) + 15,\r\n        studyFrequency: 3 + (userHash % 4)\r\n      }\r\n    };\r\n  }\r\n\r\n  // Simple hash function for consistent personalization\r\n  private hashString(str: string): number {\r\n    let hash = 0;\r\n    for (let i = 0; i < str.length; i++) {\r\n      const char = str.charCodeAt(i);\r\n      hash = ((hash << 5) - hash) + char;\r\n      hash = hash & hash; // Convert to 32-bit integer\r\n    }\r\n    return Math.abs(hash);\r\n  }\r\n}\r\n\r\n// Export singleton instance\r\nexport const userDataService = new UserDataService();","// Removed unused imports: useDeckStore and useGamificationStore\r\n\r\n// Types for real-time data\r\nexport interface GlobalLearningStats {\r\n  totalLearners: number\r\n  cardsStudiedToday: number\r\n  activeStudySessions: number\r\n  languagesBeingLearned: number\r\n  topSubjects: Array<{ name: string; learners: number }>\r\n  studyTimeToday: number // in minutes\r\n  lastUpdated: string\r\n}\r\n\r\nexport interface EducationalTrends {\r\n  popularSubjects: Array<{ subject: string; growth: number; learners: number }>\r\n  learningMethods: Array<{ method: string; effectiveness: number; usage: number }>\r\n  studyPatterns: {\r\n    peakHours: Array<{ hour: number; activity: number }>\r\n    weeklyTrends: Array<{ day: string; sessions: number }>\r\n  }\r\n  lastUpdated: string\r\n}\r\n\r\nexport interface LiveUserMetrics {\r\n  onlineUsers: number\r\n  studyingSessions: number\r\n  completedToday: number\r\n  averageAccuracy: number\r\n  topPerformers: Array<{ username: string; score: number; country: string }>\r\n  lastUpdated: string\r\n}\r\n\r\nexport interface MarketInsights {\r\n  skillDemand: Array<{ skill: string; demand: number; growth: number }>\r\n  industryTrends: Array<{ industry: string; skills: string[]; growth: number }>\r\n  certificationValue: Array<{ cert: string; value: number; popularity: number }>\r\n  lastUpdated: string\r\n}\r\n\r\n// Real-time data service class\r\nexport class RealTimeDataService {\r\n  private updateInterval: number = 30000 // 30 seconds\r\n  private subscribers: Map<string, ((data: unknown) => void)[]> = new Map()\r\n  private intervalId: NodeJS.Timeout | null = null\r\n  private activeInstances: number = 0 // Reference counter for active instances\r\n\r\n  // Subscribe to real-time updates\r\n  subscribe<T = unknown>(dataType: string, callback: (data: T) => void): () => void {\r\n    if (!this.subscribers.has(dataType)) {\r\n      this.subscribers.set(dataType, [])\r\n    }\r\n    this.subscribers.get(dataType)!.push(callback as (data: unknown) => void)\r\n\r\n    // Return unsubscribe function\r\n    return () => {\r\n      const callbacks = this.subscribers.get(dataType)\r\n      if (callbacks) {\r\n        const index = callbacks.indexOf(callback as (data: unknown) => void)\r\n        if (index > -1) {\r\n          callbacks.splice(index, 1)\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // Notify subscribers\r\n  private notify(dataType: string, data: unknown): void {\r\n    const callbacks = this.subscribers.get(dataType)\r\n    if (callbacks) {\r\n      callbacks.forEach(callback => callback(data))\r\n    }\r\n  }\r\n\r\n  // Fetch global learning statistics from multiple sources\r\n  async getGlobalLearningStats(): Promise<GlobalLearningStats> {\r\n    try {\r\n      // Try to fetch from real educational APIs\r\n      const stats = await this.fetchFromMultipleSources([\r\n        () => this.fetchFromDuolingoAPI(),\r\n        () => this.fetchFromKhanAcademyAPI(),\r\n        () => this.fetchFromCourseraAPI(),\r\n        () => this.fetchFromEducationalDataAPI()\r\n      ])\r\n\r\n      if (stats) {\r\n        this.notify('globalStats', stats)\r\n        return stats as GlobalLearningStats\r\n      }\r\n    } catch (error) {\r\n      console.warn('Failed to fetch real global stats, using enhanced mock data:', error)\r\n    }\r\n\r\n    // Enhanced realistic mock data with time-based variations\r\n    return this.generateEnhancedGlobalStats()\r\n  }\r\n\r\n  // Fetch educational trends from research APIs\r\n  async getEducationalTrends(): Promise<EducationalTrends> {\r\n    try {\r\n      // Try to fetch from educational research APIs\r\n      const trends = await this.fetchEducationalTrendsFromAPIs()\r\n      if (trends) {\r\n        this.notify('educationalTrends', trends)\r\n        return trends\r\n      }\r\n    } catch (error) {\r\n      console.warn('Failed to fetch real educational trends, using enhanced mock data:', error)\r\n    }\r\n\r\n    return this.generateEnhancedEducationalTrends()\r\n  }\r\n\r\n  // Fetch live user metrics\r\n  async getLiveUserMetrics(): Promise<LiveUserMetrics> {\r\n    try {\r\n      // Try to fetch from real-time analytics APIs\r\n      const metrics = await this.fetchLiveMetricsFromAPIs()\r\n      if (metrics) {\r\n        this.notify('liveMetrics', metrics)\r\n        return metrics\r\n      }\r\n    } catch (error) {\r\n      console.warn('Failed to fetch real live metrics, using enhanced mock data:', error)\r\n    }\r\n\r\n    return this.generateEnhancedLiveMetrics()\r\n  }\r\n\r\n  // Fetch market insights from job/skill APIs\r\n  async getMarketInsights(): Promise<MarketInsights> {\r\n    try {\r\n      // Try to fetch from job market APIs\r\n      const insights = await this.fetchMarketInsightsFromAPIs()\r\n      if (insights) {\r\n        this.notify('marketInsights', insights)\r\n        return insights\r\n      }\r\n    } catch (error) {\r\n      console.warn('Failed to fetch real market insights, using enhanced mock data:', error)\r\n    }\r\n\r\n    return this.generateEnhancedMarketInsights()\r\n  }\r\n\r\n  // Attempt to fetch from Duolingo's public API\r\n  private async fetchFromDuolingoAPI(): Promise<Partial<GlobalLearningStats> | null> {\r\n    try {\r\n      // Note: Duolingo doesn't have a public API for global stats\r\n      // This is a placeholder for when such APIs become available\r\n      const response = await fetch('https://www.duolingo.com/api/1/users/show?username=duolingo', {\r\n        method: 'GET',\r\n        headers: { 'Accept': 'application/json' }\r\n      })\r\n      \r\n      if (response.ok) {\r\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n        const _data = await response.json()\r\n        // Extract relevant statistics if available\r\n        return null // Placeholder\r\n      }\r\n    } catch (error) {\r\n      console.log('Duolingo API not accessible:', error)\r\n    }\r\n    return null\r\n  }\r\n\r\n  // Attempt to fetch from Khan Academy's API\r\n  private async fetchFromKhanAcademyAPI(): Promise<Partial<GlobalLearningStats> | null> {\r\n    try {\r\n      // Khan Academy has limited public APIs\r\n      // This is a placeholder for educational statistics\r\n      return null\r\n    } catch (error) {\r\n      console.log('Khan Academy API not accessible:', error)\r\n    }\r\n    return null\r\n  }\r\n\r\n  // Attempt to fetch from Coursera's API\r\n  private async fetchFromCourseraAPI(): Promise<Partial<GlobalLearningStats> | null> {\r\n    try {\r\n      // Coursera doesn't have public global statistics API\r\n      // This is a placeholder\r\n      return null\r\n    } catch (error) {\r\n      console.log('Coursera API not accessible:', error)\r\n    }\r\n    return null\r\n  }\r\n\r\n  // Attempt to fetch from educational data APIs\r\n  private async fetchFromEducationalDataAPI(): Promise<Partial<GlobalLearningStats> | null> {\r\n    try {\r\n      // Try to fetch from open educational data sources\r\n      // This could include UNESCO, World Bank education data, etc.\r\n      return null\r\n    } catch (error) {\r\n      console.log('Educational data API not accessible:', error)\r\n    }\r\n    return null\r\n  }\r\n\r\n  // Fetch from multiple sources and combine results\r\n  private async fetchFromMultipleSources(fetchers: Array<() => Promise<unknown>>): Promise<unknown> {\r\n    const results = await Promise.allSettled(fetchers.map(fetcher => fetcher()))\r\n    \r\n    // Combine successful results\r\n    const successfulResults = results\r\n      .filter(result => result.status === 'fulfilled' && result.value)\r\n      .map(result => (result as PromiseFulfilledResult<unknown>).value)\r\n\r\n    if (successfulResults.length > 0) {\r\n      // Merge results from multiple sources\r\n      return this.mergeDataSources(successfulResults)\r\n    }\r\n\r\n    return null\r\n  }\r\n\r\n  // Merge data from multiple sources\r\n  private mergeDataSources(sources: unknown[]): unknown {\r\n    // Implement logic to combine data from multiple sources\r\n    // For now, return the first successful source\r\n    return sources[0]\r\n  }\r\n\r\n  // Generate enhanced realistic global statistics\r\n  private generateEnhancedGlobalStats(): GlobalLearningStats {\r\n    const now = new Date()\r\n    const hour = now.getHours()\r\n    const dayOfWeek = now.getDay()\r\n    \r\n    // Time-based activity simulation\r\n    const timeMultiplier = this.getTimeBasedMultiplier(hour, dayOfWeek)\r\n    \r\n    // Base numbers that feel realistic for a global learning platform\r\n    const baseLearners = 2847392\r\n    const baseCardsToday = 15847293\r\n    const baseActiveSessions = 23847\r\n    \r\n    return {\r\n      totalLearners: Math.floor(baseLearners + (Math.random() * 1000 - 500)),\r\n      cardsStudiedToday: Math.floor(baseCardsToday * timeMultiplier + (Math.random() * 10000 - 5000)),\r\n      activeStudySessions: Math.floor(baseActiveSessions * timeMultiplier + (Math.random() * 1000 - 500)),\r\n      languagesBeingLearned: 127 + Math.floor(Math.random() * 5),\r\n      topSubjects: [\r\n        { name: 'Spanish', learners: Math.floor(847392 * timeMultiplier) },\r\n        { name: 'JavaScript', learners: Math.floor(623847 * timeMultiplier) },\r\n        { name: 'French', learners: Math.floor(534829 * timeMultiplier) },\r\n        { name: 'Python', learners: Math.floor(487293 * timeMultiplier) },\r\n        { name: 'German', learners: Math.floor(392847 * timeMultiplier) }\r\n      ],\r\n      studyTimeToday: Math.floor(1847293 * timeMultiplier), // in minutes\r\n      lastUpdated: now.toISOString()\r\n    }\r\n  }\r\n\r\n  // Generate enhanced educational trends\r\n  private generateEnhancedEducationalTrends(): EducationalTrends {\r\n    const now = new Date()\r\n    \r\n    return {\r\n      popularSubjects: [\r\n        { subject: 'Artificial Intelligence', growth: 156.7, learners: 892847 },\r\n        { subject: 'Data Science', growth: 134.2, learners: 734829 },\r\n        { subject: 'Cybersecurity', growth: 128.9, learners: 623847 },\r\n        { subject: 'Cloud Computing', growth: 119.4, learners: 587293 },\r\n        { subject: 'Machine Learning', growth: 112.8, learners: 534829 },\r\n        { subject: 'Spanish Language', growth: 89.3, learners: 1247392 },\r\n        { subject: 'Digital Marketing', growth: 87.6, learners: 423847 },\r\n        { subject: 'UX/UI Design', growth: 82.4, learners: 392847 }\r\n      ],\r\n      learningMethods: [\r\n        { method: 'Spaced Repetition', effectiveness: 94.7, usage: 78.3 },\r\n        { method: 'Active Recall', effectiveness: 91.2, usage: 65.8 },\r\n        { method: 'Microlearning', effectiveness: 87.9, usage: 82.1 },\r\n        { method: 'Gamification', effectiveness: 84.6, usage: 71.4 },\r\n        { method: 'Peer Learning', effectiveness: 81.3, usage: 56.7 }\r\n      ],\r\n      studyPatterns: {\r\n        peakHours: this.generatePeakHours(),\r\n        weeklyTrends: this.generateWeeklyTrends()\r\n      },\r\n      lastUpdated: now.toISOString()\r\n    }\r\n  }\r\n\r\n  // Generate enhanced live user metrics\r\n  private generateEnhancedLiveMetrics(): LiveUserMetrics {\r\n    const now = new Date()\r\n    const hour = now.getHours()\r\n    const timeMultiplier = this.getTimeBasedMultiplier(hour, now.getDay())\r\n    \r\n    return {\r\n      onlineUsers: Math.floor(47392 * timeMultiplier + (Math.random() * 1000 - 500)),\r\n      studyingSessions: Math.floor(23847 * timeMultiplier + (Math.random() * 500 - 250)),\r\n      completedToday: Math.floor(184729 + (Math.random() * 1000 - 500)),\r\n      averageAccuracy: 87.3 + (Math.random() * 4 - 2),\r\n      topPerformers: [\r\n        { username: 'StudyMaster_Pro', score: 15847, country: 'Singapore' },\r\n        { username: 'LearningNinja', score: 14923, country: 'South Korea' },\r\n        { username: 'FlashcardWiz', score: 14756, country: 'Finland' },\r\n        { username: 'MemoryChamp', score: 14234, country: 'Japan' },\r\n        { username: 'QuizMaster', score: 13892, country: 'Canada' }\r\n      ],\r\n      lastUpdated: now.toISOString()\r\n    }\r\n  }\r\n\r\n  // Generate enhanced market insights\r\n  private generateEnhancedMarketInsights(): MarketInsights {\r\n    const now = new Date()\r\n    \r\n    return {\r\n      skillDemand: [\r\n        { skill: 'AI/Machine Learning', demand: 94.7, growth: 156.3 },\r\n        { skill: 'Cloud Architecture', demand: 91.2, growth: 134.7 },\r\n        { skill: 'Cybersecurity', demand: 89.8, growth: 128.9 },\r\n        { skill: 'Data Analysis', demand: 87.4, growth: 119.2 },\r\n        { skill: 'DevOps', demand: 84.9, growth: 112.6 },\r\n        { skill: 'Full-Stack Development', demand: 82.3, growth: 98.4 },\r\n        { skill: 'Digital Marketing', demand: 78.7, growth: 87.9 },\r\n        { skill: 'UX Design', demand: 76.2, growth: 82.1 }\r\n      ],\r\n      industryTrends: [\r\n        { \r\n          industry: 'Technology', \r\n          skills: ['AI/ML', 'Cloud Computing', 'Cybersecurity'], \r\n          growth: 145.7 \r\n        },\r\n        { \r\n          industry: 'Healthcare', \r\n          skills: ['Data Analysis', 'Digital Health', 'Telemedicine'], \r\n          growth: 123.4 \r\n        },\r\n        { \r\n          industry: 'Finance', \r\n          skills: ['Blockchain', 'FinTech', 'Risk Analysis'], \r\n          growth: 118.9 \r\n        },\r\n        { \r\n          industry: 'Education', \r\n          skills: ['EdTech', 'Online Learning', 'Digital Pedagogy'], \r\n          growth: 134.2 \r\n        }\r\n      ],\r\n      certificationValue: [\r\n        { cert: 'AWS Certified Solutions Architect', value: 98.7, popularity: 87.3 },\r\n        { cert: 'Google Cloud Professional', value: 96.2, popularity: 82.1 },\r\n        { cert: 'Certified Ethical Hacker', value: 94.8, popularity: 76.4 },\r\n        { cert: 'PMP Certification', value: 91.3, popularity: 89.7 },\r\n        { cert: 'Cisco CCNA', value: 88.9, popularity: 78.2 }\r\n      ],\r\n      lastUpdated: now.toISOString()\r\n    }\r\n  }\r\n\r\n  // Get time-based activity multiplier\r\n  private getTimeBasedMultiplier(hour: number, dayOfWeek: number): number {\r\n    // Peak hours: 9-11 AM, 2-4 PM, 7-9 PM\r\n    let hourMultiplier = 0.7 // Base activity\r\n    \r\n    if ((hour >= 9 && hour <= 11) || (hour >= 14 && hour <= 16) || (hour >= 19 && hour <= 21)) {\r\n      hourMultiplier = 1.2 // Peak hours\r\n    } else if (hour >= 6 && hour <= 23) {\r\n      hourMultiplier = 1.0 // Normal hours\r\n    }\r\n    \r\n    // Weekend vs weekday\r\n    const dayMultiplier = (dayOfWeek === 0 || dayOfWeek === 6) ? 0.8 : 1.0\r\n    \r\n    return hourMultiplier * dayMultiplier\r\n  }\r\n\r\n  // Generate realistic peak hours data\r\n  private generatePeakHours(): Array<{ hour: number; activity: number }> {\r\n    const peakHours = []\r\n    for (let hour = 0; hour < 24; hour++) {\r\n      let activity = 30 // Base activity\r\n      \r\n      // Morning peak (9-11 AM)\r\n      if (hour >= 9 && hour <= 11) activity = 85 + Math.random() * 10\r\n      // Afternoon peak (2-4 PM)\r\n      else if (hour >= 14 && hour <= 16) activity = 90 + Math.random() * 10\r\n      // Evening peak (7-9 PM)\r\n      else if (hour >= 19 && hour <= 21) activity = 95 + Math.random() * 10\r\n      // Normal hours\r\n      else if (hour >= 6 && hour <= 23) activity = 60 + Math.random() * 20\r\n      // Night hours\r\n      else activity = 20 + Math.random() * 15\r\n      \r\n      peakHours.push({ hour, activity: Math.floor(activity) })\r\n    }\r\n    return peakHours\r\n  }\r\n\r\n  // Generate weekly trends\r\n  private generateWeeklyTrends(): Array<{ day: string; sessions: number }> {\r\n    const days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']\r\n    const baseSessions = [8500, 9200, 9800, 9500, 8900, 7200, 6800] // Realistic weekly pattern\r\n    \r\n    return days.map((day, index) => ({\r\n      day,\r\n      sessions: Math.floor(baseSessions[index] + (Math.random() * 1000 - 500))\r\n    }))\r\n  }\r\n\r\n  // Placeholder methods for real API calls\r\n  private async fetchEducationalTrendsFromAPIs(): Promise<EducationalTrends | null> {\r\n    // Implement real API calls to educational research databases\r\n    return null\r\n  }\r\n\r\n  private async fetchLiveMetricsFromAPIs(): Promise<LiveUserMetrics | null> {\r\n    // Implement real API calls to analytics services\r\n    return null\r\n  }\r\n\r\n  private async fetchMarketInsightsFromAPIs(): Promise<MarketInsights | null> {\r\n    // Implement real API calls to job market APIs (LinkedIn, Indeed, etc.)\r\n    return null\r\n  }\r\n\r\n  // Start real-time updates with reference counting\r\n  startRealTimeUpdates(): () => void {\r\n    this.activeInstances++\r\n    \r\n    // Only start interval if this is the first instance\r\n    if (this.activeInstances === 1 && !this.intervalId) {\r\n      this.intervalId = setInterval(async () => {\r\n        try {\r\n          const [globalStats, trends, liveMetrics, marketInsights] = await Promise.all([\r\n            this.getGlobalLearningStats(),\r\n            this.getEducationalTrends(),\r\n            this.getLiveUserMetrics(),\r\n            this.getMarketInsights()\r\n          ])\r\n\r\n          // Notify all subscribers with fresh data\r\n          this.notify('globalStats', globalStats)\r\n          this.notify('educationalTrends', trends)\r\n          this.notify('liveMetrics', liveMetrics)\r\n          this.notify('marketInsights', marketInsights)\r\n        } catch (error) {\r\n          console.error('Error updating real-time data:', error)\r\n        }\r\n      }, this.updateInterval)\r\n    }\r\n\r\n    // Return cleanup function\r\n    return () => {\r\n      this.stopRealTimeUpdates()\r\n    }\r\n  }\r\n\r\n  // Stop real-time updates with reference counting\r\n  stopRealTimeUpdates(): void {\r\n    this.activeInstances = Math.max(0, this.activeInstances - 1)\r\n    \r\n    // Only stop interval when no more active instances\r\n    if (this.activeInstances === 0 && this.intervalId) {\r\n      clearInterval(this.intervalId)\r\n      this.intervalId = null\r\n    }\r\n  }\r\n\r\n  // Force stop all real-time updates (for cleanup)\r\n  forceStopRealTimeUpdates(): void {\r\n    this.activeInstances = 0\r\n    if (this.intervalId) {\r\n      clearInterval(this.intervalId)\r\n      this.intervalId = null\r\n    }\r\n    // Clear all subscriptions\r\n    this.subscribers.clear()\r\n  }\r\n}\r\n\r\n// Export singleton instance\r\nexport const realTimeDataService = new RealTimeDataService()","import axios from 'axios';\nimport { UnifiedSessionState, CardSelectionResult, EnhancedResponseLog } from '../../../shared/types/enhanced-types';\n\nconst apiClient = axios.create({\n  baseURL: import.meta.env.VITE_API_URL || 'http://localhost:3001/api',\n  withCredentials: true,\n});\n\nexport const uamsApiService = {\n  async initializeSession(userId: string, deckId: string): Promise<UnifiedSessionState> {\n    const response = await apiClient.post('/uams/session/initialize', { userId, deckId });\n    return response.data;\n  },\n\n  async getNextCard(sessionState: UnifiedSessionState): Promise<CardSelectionResult> {\n    const response = await apiClient.post('/uams/session/next-card', { sessionState });\n    return response.data;\n  },\n\n  async processCardResponse(sessionState: UnifiedSessionState, cardId: string, response: EnhancedResponseLog): Promise<UnifiedSessionState> {\n    const apiResponse = await apiClient.post('/uams/session/response', { sessionState, cardId, response });\n    return apiResponse.data;\n  },\n};\n","import { UnifiedSessionState, UnifiedCard, CardSelectionResult, EnhancedResponseLog, SessionContext, UserProfile } from '../../../shared/types/enhanced-types';\nimport { uamsApiService } from './uamsApiService';\n\nexport interface QueueManagerConfig {\n  lookaheadBufferSize: number;\n  emergencyBufferSize: number;\n  challengeReserveSize: number;\n  refreshThreshold: number;\n  maxSessionDurationMinutes: number;\n  adaptiveRefreshInterval: number;\n}\n\nexport interface BufferMetrics {\n  lookaheadUtilization: number;\n  emergencyBufferHealth: number;\n  challengeReserveReadiness: number;\n  overallQueueHealth: number;\n}\n\nexport class UnifiedQueueManager {\n  private config: QueueManagerConfig;\n\n  constructor(config: Partial<QueueManagerConfig> = {}) {\n    this.config = {\n      lookaheadBufferSize: 10,\n      emergencyBufferSize: 5,\n      challengeReserveSize: 5,\n      refreshThreshold: 3,\n      maxSessionDurationMinutes: 120,\n      adaptiveRefreshInterval: 5000,\n      ...config\n    };\n  }\n\n  /**\n   * Initialize a new study session\n   */\n  async initializeSession(userId: string, deckId: string): Promise<UnifiedSessionState> {\n    return uamsApiService.initializeSession(userId, deckId);\n  }\n\n  /**\n   * Get the next card for review\n   */\n  async getNextCard(sessionState: UnifiedSessionState): Promise<CardSelectionResult> {\n    return uamsApiService.getNextCard(sessionState);\n  }\n\n  /**\n   * Process user response and update session state\n   */\n  async processCardResponse(\n    sessionState: UnifiedSessionState,\n    cardId: string,\n    response: EnhancedResponseLog\n  ): Promise<UnifiedSessionState> {\n    return uamsApiService.processCardResponse(sessionState, cardId, response);\n  }\n}","import { EnvironmentalContext, SessionContext } from '../../../../shared/types/enhanced-types';\r\n\r\nexport interface DetectedContext extends EnvironmentalContext {\r\n  confidence: number; // 0-1 confidence in detection accuracy\r\n  detectionMethod: string; // How the context was detected\r\n  timestamp: string;\r\n}\r\n\r\nexport interface ContextualInsights {\r\n  optimalStudyConditions: EnvironmentalContext;\r\n  currentConditionScore: number; // 0-1 how optimal current conditions are\r\n  improvementSuggestions: string[];\r\n  historicalPerformance: PerformanceByContext[];\r\n}\r\n\r\nexport interface PerformanceByContext {\r\n  context: Partial<EnvironmentalContext>;\r\n  averageAccuracy: number;\r\n  averageResponseTime: number;\r\n  sessionCount: number;\r\n  confidenceInterval: [number, number];\r\n}\r\n\r\nexport interface EnvironmentalAdaptation {\r\n  difficultyAdjustment: number; // Adjustment based on environment (-3 to +3)\r\n  recommendedBreakFrequency: number; // Minutes between suggested breaks\r\n  visualOptimizations: {\r\n    contrastAdjustment: number; // -1 to +1\r\n    fontSizeAdjustment: number; // -1 to +1 (relative)\r\n    colorScheme: 'light' | 'dark' | 'auto';\r\n  };\r\n  audioOptimizations: {\r\n    enableSoundEffects: boolean;\r\n    volumeAdjustment: number; // 0-1\r\n  };\r\n}\r\n\r\nexport class EnvironmentalContextService {\r\n  private contextHistory: DetectedContext[] = [];\r\n  private performanceCache: Map<string, PerformanceByContext> = new Map();\r\n\r\n  /**\r\n   * Get comprehensive current environmental context\r\n   */\r\n  async getCurrentContext(): Promise<DetectedContext> {\r\n    const context: EnvironmentalContext = {\r\n      device: this.detectDevice(),\r\n      networkQuality: await this.assessNetworkQuality(),\r\n    };\r\n    \r\n    let confidence = 0.9; // Base confidence\r\n\r\n    // Enhanced mobile detection with additional context\r\n    if (context.device === 'mobile') {\r\n      try {\r\n        context.batteryLevel = await this.getBatteryLevel();\r\n        if (context.batteryLevel !== undefined) confidence += 0.05;\r\n      } catch (error) {\r\n        console.warn('Battery level detection failed:', error);\r\n      }\r\n    }\r\n\r\n    // Ambient conditions detection\r\n    try {\r\n      context.ambientNoise = await this.detectAmbientNoise();\r\n      context.lighting = await this.detectLightingConditions();\r\n      confidence += 0.05;\r\n    } catch (error) {\r\n      console.warn('Ambient conditions detection failed:', error);\r\n      confidence -= 0.1;\r\n    }\r\n\r\n    const detectedContext: DetectedContext = {\r\n      ...context,\r\n      confidence: Math.max(0.5, confidence),\r\n      detectionMethod: 'multi-sensor-fusion',\r\n      timestamp: new Date().toISOString()\r\n    };\r\n\r\n    // Store in history\r\n    this.contextHistory.push(detectedContext);\r\n    if (this.contextHistory.length > 100) {\r\n      this.contextHistory.shift(); // Keep only last 100 entries\r\n    }\r\n\r\n    return detectedContext;\r\n  }\r\n\r\n  /**\r\n   * Detect device type with enhanced accuracy\r\n   */\r\n  private detectDevice(): 'mobile' | 'desktop' | 'tablet' {\r\n    const userAgent = navigator.userAgent.toLowerCase();\r\n    const platform = navigator.platform?.toLowerCase() || '';\r\n    \r\n    // Check for mobile indicators\r\n    const mobileKeywords = ['mobile', 'android', 'iphone', 'ipod', 'blackberry', 'windows phone'];\r\n    const isMobile = mobileKeywords.some(keyword => userAgent.includes(keyword));\r\n    \r\n    // Check for tablet indicators\r\n    const tabletKeywords = ['ipad', 'tablet', 'kindle', 'playbook', 'silk'];\r\n    const isTablet = tabletKeywords.some(keyword => userAgent.includes(keyword));\r\n    \r\n    // Enhanced detection using screen size and touch capabilities\r\n    const screenWidth = window.screen.width;\r\n    const screenHeight = window.screen.height;\r\n    const maxDimension = Math.max(screenWidth, screenHeight);\r\n    const minDimension = Math.min(screenWidth, screenHeight);\r\n    \r\n    const hasTouchScreen = 'ontouchstart' in window || navigator.maxTouchPoints > 0;\r\n    \r\n    if (isTablet || (hasTouchScreen && minDimension >= 768 && maxDimension >= 1024)) {\r\n      return 'tablet';\r\n    }\r\n    \r\n    if (isMobile || (hasTouchScreen && maxDimension <= 736)) {\r\n      return 'mobile';\r\n    }\r\n    \r\n    // Additional checks for desktop\r\n    const isDesktop = platform.includes('win') || platform.includes('mac') || platform.includes('linux');\r\n    \r\n    return isDesktop || !hasTouchScreen ? 'desktop' : 'mobile';\r\n  }\r\n\r\n  /**\r\n   * Assess network quality with multiple metrics\r\n   */\r\n  private async assessNetworkQuality(): Promise<'excellent' | 'good' | 'poor' | 'offline'> {\r\n    if (!navigator.onLine) return 'offline';\r\n    \r\n    try {\r\n      // Use Connection API if available (Chrome/Edge)\r\n      const connection = (navigator as any).connection || (navigator as any).mozConnection || (navigator as any).webkitConnection;\r\n      \r\n      if (connection) {\r\n        const effectiveType = connection.effectiveType;\r\n        const downlink = connection.downlink;\r\n        const rtt = connection.rtt;\r\n        \r\n        // Advanced classification based on multiple metrics\r\n        if (effectiveType === '4g' && downlink > 10 && rtt < 100) {\r\n          return 'excellent';\r\n        } else if ((effectiveType === '4g' || effectiveType === '3g') && downlink > 2 && rtt < 300) {\r\n          return 'good';\r\n        } else if (downlink > 0.5 && rtt < 1000) {\r\n          return 'good';\r\n        } else {\r\n          return 'poor';\r\n        }\r\n      }\r\n      \r\n      // Fallback: Performance-based detection\r\n      return await this.performLatencyTest();\r\n    } catch (error) {\r\n      console.warn('Network quality assessment failed:', error);\r\n      return 'good'; // Default assumption\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Perform latency test for network quality\r\n   */\r\n  private async performLatencyTest(): Promise<'excellent' | 'good' | 'poor'> {\r\n    try {\r\n      const startTime = performance.now();\r\n      \r\n      // Test with a small request to avoid affecting user experience\r\n      const response = await fetch('/api/ping', { \r\n        method: 'HEAD',\r\n        cache: 'no-cache' \r\n      });\r\n      \r\n      const endTime = performance.now();\r\n      const latency = endTime - startTime;\r\n      \r\n      if (!response.ok) {\r\n        return 'poor';\r\n      }\r\n      \r\n      if (latency < 100) {\r\n        return 'excellent';\r\n      } else if (latency < 300) {\r\n        return 'good';\r\n      } else {\r\n        return 'poor';\r\n      }\r\n    } catch (error) {\r\n      console.warn('Latency test failed:', error);\r\n      return 'poor';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get battery level for mobile devices\r\n   */\r\n  private async getBatteryLevel(): Promise<number | undefined> {\r\n    try {\r\n      // Modern Battery API\r\n      const battery = await (navigator as any).getBattery?.();\r\n      if (battery && typeof battery.level === 'number') {\r\n        return battery.level;\r\n      }\r\n      \r\n      // Fallback methods for older devices\r\n      const batteryManager = (navigator as any).battery || (navigator as any).mozBattery || (navigator as any).webkitBattery;\r\n      if (batteryManager && typeof batteryManager.level === 'number') {\r\n        return batteryManager.level;\r\n      }\r\n      \r\n      return undefined;\r\n    } catch (error) {\r\n      console.warn('Battery level detection failed:', error);\r\n      return undefined;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Detect ambient noise level using audio API\r\n   */\r\n  private async detectAmbientNoise(): Promise<'quiet' | 'moderate' | 'noisy' | undefined> {\r\n    try {\r\n      // Request microphone access for noise detection\r\n      const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });\r\n      \r\n      return new Promise<'quiet' | 'moderate' | 'noisy' | undefined>((resolve) => {\r\n        const audioContext = new (window.AudioContext || (window as any).webkitAudioContext)();\r\n        const analyser = audioContext.createAnalyser();\r\n        const microphone = audioContext.createMediaStreamSource(stream);\r\n        \r\n        microphone.connect(analyser);\r\n        analyser.fftSize = 256;\r\n        \r\n        const bufferLength = analyser.frequencyBinCount;\r\n        const dataArray = new Uint8Array(bufferLength);\r\n        \r\n        let samples = 0;\r\n        let totalVolume = 0;\r\n        const maxSamples = 30; // Sample for 1 second at ~30fps\r\n        \r\n        const checkVolume = () => {\r\n          analyser.getByteFrequencyData(dataArray);\r\n          \r\n          const volume = dataArray.reduce((sum, value) => sum + value, 0) / bufferLength;\r\n          totalVolume += volume;\r\n          samples++;\r\n          \r\n          if (samples < maxSamples) {\r\n            setTimeout(checkVolume, 33); // ~30fps sampling\r\n          } else {\r\n            // Clean up\r\n            stream.getTracks().forEach(track => track.stop());\r\n            audioContext.close();\r\n            \r\n            const averageVolume = totalVolume / samples;\r\n            \r\n            // Classify noise level\r\n            if (averageVolume < 20) {\r\n              resolve('quiet');\r\n            } else if (averageVolume < 60) {\r\n              resolve('moderate');\r\n            } else {\r\n              resolve('noisy');\r\n            }\r\n          }\r\n        };\r\n        \r\n        checkVolume();\r\n      });\r\n    } catch (error) {\r\n      // Microphone access denied or not available\r\n      console.warn('Ambient noise detection failed:', error);\r\n      return undefined;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Detect lighting conditions using camera or screen brightness\r\n   */\r\n  private async detectLightingConditions(): Promise<'optimal' | 'dim' | 'bright' | undefined> {\r\n    try {\r\n      // Method 1: Screen brightness detection (if supported)\r\n      if ('screen' in navigator && 'brightness' in (navigator.screen as any)) {\r\n        const brightness = (navigator.screen as any).brightness;\r\n        if (brightness < 0.3) return 'dim';\r\n        if (brightness > 0.8) return 'bright';\r\n        return 'optimal';\r\n      }\r\n      \r\n      // Method 2: Camera-based ambient light detection\r\n      return await this.detectLightingViaCamera();\r\n    } catch (error) {\r\n      console.warn('Lighting detection failed:', error);\r\n      return undefined;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Detect lighting via camera sensor\r\n   */\r\n  private async detectLightingViaCamera(): Promise<'optimal' | 'dim' | 'bright' | undefined> {\r\n    try {\r\n      const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } });\r\n      \r\n      return new Promise<'optimal' | 'dim' | 'bright' | undefined>((resolve) => {\r\n        const video = document.createElement('video');\r\n        const canvas = document.createElement('canvas');\r\n        const ctx = canvas.getContext('2d');\r\n        \r\n        video.srcObject = stream;\r\n        video.play();\r\n        \r\n        video.addEventListener('loadedmetadata', () => {\r\n          canvas.width = video.videoWidth;\r\n          canvas.height = video.videoHeight;\r\n          \r\n          // Capture a frame after a short delay\r\n          setTimeout(() => {\r\n            if (ctx) {\r\n              ctx.drawImage(video, 0, 0);\r\n              const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\r\n              \r\n              // Calculate average brightness\r\n              let totalBrightness = 0;\r\n              const pixels = imageData.data;\r\n              \r\n              for (let i = 0; i < pixels.length; i += 4) {\r\n                const r = pixels[i];\r\n                const g = pixels[i + 1];\r\n                const b = pixels[i + 2];\r\n                \r\n                // Calculate luminance\r\n                const luminance = 0.299 * r + 0.587 * g + 0.114 * b;\r\n                totalBrightness += luminance;\r\n              }\r\n              \r\n              const averageBrightness = totalBrightness / (pixels.length / 4);\r\n              \r\n              // Clean up\r\n              stream.getTracks().forEach(track => track.stop());\r\n              \r\n              // Classify lighting\r\n              if (averageBrightness < 50) {\r\n                resolve('dim');\r\n              } else if (averageBrightness > 200) {\r\n                resolve('bright');\r\n              } else {\r\n                resolve('optimal');\r\n              }\r\n            }\r\n          }, 500);\r\n        });\r\n      });\r\n    } catch (error) {\r\n      console.warn('Camera-based lighting detection failed:', error);\r\n      return undefined;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Analyze contextual insights from historical data\r\n   */\r\n  analyzeContextualInsights(performanceHistory: any[]): ContextualInsights {\r\n    // Group performance by environmental factors\r\n    const contextGroups = this.groupPerformanceByContext(performanceHistory);\r\n    \r\n    // Find optimal conditions\r\n    const optimalConditions = this.findOptimalConditions(contextGroups);\r\n    \r\n    // Score current conditions\r\n    const currentContext = this.contextHistory[this.contextHistory.length - 1];\r\n    const currentScore = this.scoreCurrentConditions(currentContext, optimalConditions);\r\n    \r\n    // Generate improvement suggestions\r\n    const suggestions = this.generateImprovementSuggestions(currentContext, optimalConditions);\r\n    \r\n    return {\r\n      optimalStudyConditions: optimalConditions,\r\n      currentConditionScore: currentScore,\r\n      improvementSuggestions: suggestions,\r\n      historicalPerformance: Array.from(contextGroups.values())\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get environmental adaptation recommendations\r\n   */\r\n  getEnvironmentalAdaptations(context: EnvironmentalContext): EnvironmentalAdaptation {\r\n    let difficultyAdjustment = 0;\r\n    let breakFrequency = 25; // Default pomodoro technique\r\n    \r\n    const visualOpts = {\r\n      contrastAdjustment: 0,\r\n      fontSizeAdjustment: 0,\r\n      colorScheme: 'auto' as const\r\n    };\r\n    \r\n    const audioOpts = {\r\n      enableSoundEffects: true,\r\n      volumeAdjustment: 0.7\r\n    };\r\n\r\n    // Device-based adaptations\r\n    switch (context.device) {\r\n      case 'mobile':\r\n        difficultyAdjustment -= 0.5; // Slightly easier on mobile\r\n        breakFrequency = 20; // More frequent breaks\r\n        visualOpts.fontSizeAdjustment = 0.2; // Larger text\r\n        break;\r\n        \r\n      case 'tablet':\r\n        breakFrequency = 30;\r\n        visualOpts.fontSizeAdjustment = 0.1;\r\n        break;\r\n        \r\n      case 'desktop':\r\n        breakFrequency = 45; // Longer sessions on desktop\r\n        break;\r\n    }\r\n\r\n    // Network quality adaptations\r\n    switch (context.networkQuality) {\r\n      case 'poor':\r\n      case 'offline':\r\n        difficultyAdjustment -= 1.0; // Significantly easier for poor connection\r\n        audioOpts.enableSoundEffects = false; // Disable to reduce data usage\r\n        break;\r\n        \r\n      case 'good':\r\n        difficultyAdjustment -= 0.2;\r\n        break;\r\n    }\r\n\r\n    // Battery level adaptations (mobile)\r\n    if (context.batteryLevel !== undefined && context.batteryLevel < 0.3) {\r\n      difficultyAdjustment -= 0.5; // Easier when battery is low\r\n      breakFrequency = 15; // More frequent breaks to reduce usage\r\n      visualOpts.colorScheme = 'dark'; // Dark mode saves battery\r\n    }\r\n\r\n    // Ambient noise adaptations\r\n    switch (context.ambientNoise) {\r\n      case 'noisy':\r\n        difficultyAdjustment -= 0.3; // Harder to concentrate in noise\r\n        audioOpts.enableSoundEffects = false; // Disable competing audio\r\n        break;\r\n        \r\n      case 'quiet':\r\n        audioOpts.volumeAdjustment = 0.5; // Lower volume in quiet environments\r\n        break;\r\n    }\r\n\r\n    // Lighting adaptations\r\n    switch (context.lighting) {\r\n      case 'dim':\r\n        visualOpts.contrastAdjustment = 0.3; // Higher contrast\r\n        visualOpts.colorScheme = 'dark'; // Better for dim environments\r\n        difficultyAdjustment -= 0.2; // Slightly easier in poor lighting\r\n        break;\r\n        \r\n      case 'bright':\r\n        visualOpts.contrastAdjustment = -0.2; // Lower contrast\r\n        visualOpts.colorScheme = 'light'; // Better for bright environments\r\n        break;\r\n        \r\n      case 'optimal':\r\n        // No adjustments needed\r\n        break;\r\n    }\r\n\r\n    return {\r\n      difficultyAdjustment: Math.max(-3, Math.min(3, difficultyAdjustment)),\r\n      recommendedBreakFrequency: breakFrequency,\r\n      visualOptimizations: visualOpts,\r\n      audioOptimizations: audioOpts\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Track context changes and notify of significant changes\r\n   */\r\n  async trackContextChanges(): Promise<void> {\r\n    const previousContext = this.contextHistory[this.contextHistory.length - 1];\r\n    const currentContext = await this.getCurrentContext();\r\n    \r\n    if (previousContext && this.hasSignificantContextChange(previousContext, currentContext)) {\r\n      // Emit context change event\r\n      this.onContextChange?.(currentContext, previousContext);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check for significant context changes\r\n   */\r\n  private hasSignificantContextChange(previous: DetectedContext, current: DetectedContext): boolean {\r\n    // Device change (rare but significant)\r\n    if (previous.device !== current.device) return true;\r\n    \r\n    // Network quality change\r\n    if (previous.networkQuality !== current.networkQuality) return true;\r\n    \r\n    // Battery level change > 20%\r\n    if (previous.batteryLevel && current.batteryLevel) {\r\n      if (Math.abs(previous.batteryLevel - current.batteryLevel) > 0.2) return true;\r\n    }\r\n    \r\n    // Ambient conditions change\r\n    if (previous.ambientNoise !== current.ambientNoise) return true;\r\n    if (previous.lighting !== current.lighting) return true;\r\n    \r\n    return false;\r\n  }\r\n\r\n  // Helper methods for contextual analysis\r\n\r\n  private groupPerformanceByContext(performanceHistory: any[]): Map<string, PerformanceByContext> {\r\n    const groups = new Map<string, PerformanceByContext>();\r\n    \r\n    // This would group performance data by environmental context\r\n    // Implementation would depend on your performance data structure\r\n    \r\n    return groups;\r\n  }\r\n\r\n  private findOptimalConditions(contextGroups: Map<string, PerformanceByContext>): EnvironmentalContext {\r\n    // Analyze performance groups to find optimal conditions\r\n    // This is a simplified version - real implementation would be more sophisticated\r\n    \r\n    return {\r\n      device: 'desktop', // Generally best performance\r\n      networkQuality: 'excellent',\r\n      batteryLevel: undefined, // Not applicable for optimal\r\n      ambientNoise: 'quiet',\r\n      lighting: 'optimal'\r\n    };\r\n  }\r\n\r\n  private scoreCurrentConditions(current: DetectedContext | undefined, optimal: EnvironmentalContext): number {\r\n    if (!current) return 0.5;\r\n    \r\n    let score = 1.0;\r\n    \r\n    // Score each factor\r\n    if (current.device !== optimal.device) score -= 0.1;\r\n    if (current.networkQuality !== optimal.networkQuality) {\r\n      score -= current.networkQuality === 'poor' ? 0.3 : 0.1;\r\n    }\r\n    if (current.ambientNoise !== optimal.ambientNoise) score -= 0.15;\r\n    if (current.lighting !== optimal.lighting) score -= 0.1;\r\n    \r\n    // Battery penalty for mobile\r\n    if (current.device === 'mobile' && current.batteryLevel && current.batteryLevel < 0.3) {\r\n      score -= 0.2;\r\n    }\r\n    \r\n    return Math.max(0, score);\r\n  }\r\n\r\n  private generateImprovementSuggestions(current: DetectedContext | undefined, optimal: EnvironmentalContext): string[] {\r\n    const suggestions: string[] = [];\r\n    \r\n    if (!current) return suggestions;\r\n    \r\n    if (current.networkQuality === 'poor') {\r\n      suggestions.push('Consider switching to a better network connection for optimal performance');\r\n    }\r\n    \r\n    if (current.ambientNoise === 'noisy') {\r\n      suggestions.push('Find a quieter environment or use noise-canceling headphones');\r\n    }\r\n    \r\n    if (current.lighting === 'dim') {\r\n      suggestions.push('Improve lighting conditions for better visual clarity');\r\n    } else if (current.lighting === 'bright') {\r\n      suggestions.push('Reduce screen glare or move to a less bright environment');\r\n    }\r\n    \r\n    if (current.device === 'mobile' && current.batteryLevel && current.batteryLevel < 0.3) {\r\n      suggestions.push('Charge your device or switch to a desktop for longer study sessions');\r\n    }\r\n    \r\n    return suggestions;\r\n  }\r\n\r\n  // Event handler for context changes (can be overridden)\r\n  public onContextChange?: (current: DetectedContext, previous: DetectedContext) => void;\r\n}"],"names":["DEMO_USER_STATS","totalXP","level","currentLevelXP","nextLevelXP","cardsStudied","studyTime","accuracy","currentStreak","longestStreak","coins","gems","lastStudyDate","Date","toISOString","joinDate","now","DEMO_ACHIEVEMENTS","id","name","description","icon","unlockedAt","category","ENHANCED_MONTHLY_CHALLENGES","type","target","current","reward","xp","expiresAt","DEMO_CHALLENGES","DEMO_LEADERBOARD","global","userId","username","score","rank","change","friends","weekly","monthly","UserDataService","baseUrl","isDemoUser","user","tokenType","email","getUserStats","debugLogger","log","this","userRecord","pb","collection","getOne","fields","total_xp","last_active","created","pocketbaseError","warn","error","response","fetch","headers","Authorization","token","ok","Error","data","json","apiError","generatePersonalizedMockStats","getUserActivity","days","generateDemoActivity","console","generatePersonalizedActivity","getUserAchievements","generatePersonalizedAchievements","getUserChallenges","generatePersonalizedChallenges","getLeaderboardData","generatePersonalizedLeaderboard","getPerformanceMetrics","generateDemoPerformanceMetrics","generatePersonalizedPerformanceMetrics","getCompleteUserProfile","stats","activity","achievements","challenges","performance","Promise","all","resetAllUserData","method","userHash","hashString","daysSinceJoin","Math","floor","activities","i","date","dayHash","toDateString","push","split","xpGained","reverse","baseAchievements","forEach","challenge","progressHash","userScore","userRank","leaderboard","random","weeklyProgress","goal","monthlyProgress","decksCompleted","studyPattern","preferredTime","averageSessionLength","studyFrequency","str","hash","length","charCodeAt","abs","userDataService","RealTimeDataService","updateInterval","subscribers","Map","intervalId","activeInstances","subscribe","dataType","callback","has","set","get","callbacks","index","indexOf","splice","notify","getGlobalLearningStats","fetchFromMultipleSources","fetchFromDuolingoAPI","fetchFromKhanAcademyAPI","fetchFromCourseraAPI","fetchFromEducationalDataAPI","generateEnhancedGlobalStats","getEducationalTrends","trends","fetchEducationalTrendsFromAPIs","generateEnhancedEducationalTrends","getLiveUserMetrics","metrics","fetchLiveMetricsFromAPIs","generateEnhancedLiveMetrics","getMarketInsights","insights","fetchMarketInsightsFromAPIs","generateEnhancedMarketInsights","Accept","fetchers","successfulResults","allSettled","map","fetcher","filter","result","status","value","mergeDataSources","sources","hour","getHours","dayOfWeek","getDay","timeMultiplier","getTimeBasedMultiplier","baseLearners","baseCardsToday","baseActiveSessions","totalLearners","cardsStudiedToday","activeStudySessions","languagesBeingLearned","topSubjects","learners","studyTimeToday","lastUpdated","popularSubjects","subject","growth","learningMethods","effectiveness","usage","studyPatterns","peakHours","generatePeakHours","weeklyTrends","generateWeeklyTrends","onlineUsers","studyingSessions","completedToday","averageAccuracy","topPerformers","country","skillDemand","skill","demand","industryTrends","industry","skills","certificationValue","cert","popularity","hourMultiplier","baseSessions","day","sessions","startRealTimeUpdates","setInterval","async","globalStats","liveMetrics","marketInsights","stopRealTimeUpdates","max","clearInterval","forceStopRealTimeUpdates","clear","realTimeDataService","apiClient","axios","create","baseURL","withCredentials","uamsApiService","deckId","post","sessionState","cardId","UnifiedQueueManager","config","constructor","lookaheadBufferSize","emergencyBufferSize","challengeReserveSize","refreshThreshold","maxSessionDurationMinutes","adaptiveRefreshInterval","initializeSession","getNextCard","processCardResponse","EnvironmentalContextService","contextHistory","performanceCache","getCurrentContext","context","device","detectDevice","networkQuality","assessNetworkQuality","confidence","batteryLevel","getBatteryLevel","ambientNoise","detectAmbientNoise","lighting","detectLightingConditions","detectedContext","detectionMethod","timestamp","shift","userAgent","navigator","toLowerCase","platform","isMobile","some","includes","keyword","isTablet","screenWidth","window","screen","width","screenHeight","height","maxDimension","minDimension","min","hasTouchScreen","maxTouchPoints","onLine","connection","mozConnection","webkitConnection","effectiveType","downlink","rtt","performLatencyTest","startTime","cache","latency","battery","getBattery","batteryManager","mozBattery","webkitBattery","stream","mediaDevices","getUserMedia","audio","video","resolve","audioContext","AudioContext","webkitAudioContext","analyser","createAnalyser","createMediaStreamSource","connect","fftSize","bufferLength","frequencyBinCount","dataArray","Uint8Array","samples","totalVolume","maxSamples","checkVolume","getByteFrequencyData","volume","reduce","sum","setTimeout","getTracks","track","stop","close","averageVolume","brightness","detectLightingViaCamera","facingMode","document","createElement","canvas","ctx","getContext","srcObject","play","addEventListener","videoWidth","videoHeight","drawImage","totalBrightness","pixels","getImageData","averageBrightness","analyzeContextualInsights","performanceHistory","contextGroups","groupPerformanceByContext","optimalConditions","findOptimalConditions","currentContext","optimalStudyConditions","currentConditionScore","scoreCurrentConditions","improvementSuggestions","generateImprovementSuggestions","historicalPerformance","Array","from","values","getEnvironmentalAdaptations","difficultyAdjustment","breakFrequency","visualOpts","contrastAdjustment","fontSizeAdjustment","colorScheme","audioOpts","enableSoundEffects","volumeAdjustment","recommendedBreakFrequency","visualOptimizations","audioOptimizations","trackContextChanges","previousContext","hasSignificantContextChange","onContextChange","previous","optimal","suggestions"],"mappings":"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"}