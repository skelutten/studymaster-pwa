{"version":3,"mappings":";ixCAaaA,EAAkB,CAC7BC,SAAU,CAACC,EAAU,6BACnBC,KAAOC,GAAkBA,EAAMC,OAAOC,OAAS,EAC/CJ,YAGFK,UAAW,CAACC,EAAaN,KAAA,CACvBC,KAAOC,GAAkBA,EAAME,QAAUE,EACzCN,QAASA,GAAW,oBAAoBM,sBAG1CC,UAAW,CAACC,EAAaR,KAAA,CACvBC,KAAOC,GAAkBA,EAAME,QAAUI,EACzCR,QAASA,GAAW,wBAAwBQ,sBAG9CC,MAAO,CAACT,EAAU,yCAChBC,KAAOC,GACc,6BACDD,KAAKC,GAEzBF,YAGFU,SAAU,CAACV,EAAU,sGACnBC,KAAOC,GAEiB,uEACDD,KAAKC,GAE5BF,YAGFW,SAAU,CAACX,EAAU,0FACnBC,KAAOC,GACiB,uBACDD,KAAKC,GAE5BF,YAGFY,MAAO,CAACZ,EAAU,kCAChBC,KAAOC,IAEY,wDACAD,KAAKC,GAExBF,YAGFa,eAAgB,CAACb,EAAU,kCACzBC,KAAOC,IAEY,CACf,IACA,MACA,IACA,KACA,OACA,yEAE+BY,QAAgBC,EAAQd,KAAKC,IAGhEF,aAKG,SAASgB,cAAcd,EAAee,GAC3C,MAAMC,EAAmB,GAEzB,UAAWC,KAAQF,EACZE,EAAKlB,KAAKC,IACbgB,EAAOE,KAAKD,EAAKnB,SAIrB,MAAO,CACLqB,QAA2B,IAAlBH,EAAOd,OAChBc,SAEJ,CAGO,SAASI,aAAaC,EAA8BN,GACzD,MAAMO,EAA4C,GAElD,UAAYC,EAAOC,KAAeC,OAAOC,QAAQX,GAAQ,CACvD,MAAMf,EAAQqB,EAAKE,IAAU,GAC7BD,EAAQC,GAAST,cAAcd,EAAOwB,EACxC,CAEA,OAAOF,CACT,CAQO,SAASK,cAAcC,GAC5B,OAAOA,EACJC,QAAQ,KAAM,QACdA,QAAQ,KAAM,QACdA,QAAQ,KAAM,UACdA,QAAQ,KAAM,UACdA,QAAQ,MAAO,UACf5B,MACL,CAmBO,MAAM6B,EAAoB,CAC/BC,OAAQ,CACNxB,MAAO,CAACX,EAAgBC,WAAYD,EAAgBW,SACpDC,SAAU,CAACZ,EAAgBC,WAAYD,EAAgBY,YACvDC,SAAU,CAACb,EAAgBC,WAAYD,EAAgBa,aAGzDuB,OAAQ,CACNzB,MAAO,CAACX,EAAgBC,YACxBW,SAAU,CAACZ,EAAgBC,WAAYD,EAAgBO,UAAU,MCxH/D8B,sBAAwBC,MAAOC,IACnCC,EAAYC,IAAI,0BAA2B,gCAAiC,CAC1EC,OAAQH,EAAeI,GACvBhC,MAAO4B,EAAe5B,MACtBE,SAAU0B,EAAe1B,WAG3B,IACE,MAAM+B,EAAgB,CACpBD,GAAIJ,EAAeI,GACnBhC,MAAO4B,EAAe5B,MACtBE,SAAU0B,EAAe1B,UAAY0B,EAAe5B,OAAOkC,MAAM,KAAK,IAAM,OAC5EC,MAAOP,EAAeO,OAAS,EAC/BC,QAASR,EAAeS,UAAY,EACpCC,MAAOV,EAAeU,OAAS,IAC/BC,KAAMX,EAAeW,MAAQ,GAC7BC,UAAWZ,EAAea,UAAA,IAAeC,MAAOC,cAChDC,WAAYhB,EAAeiB,cAAA,IAAmBH,MAAOC,cACrDG,YAAalB,EAAekB,aAAe,CACzCC,MAAO,SACPC,SAAU,KACVC,eAAe,EACfC,cAAc,EACdC,UAAW,GACXC,SAAU,QAKd,OADAvB,EAAYC,IAAI,0BAA2B,8BAA+BG,GACnEA,CACT,OAASoB,GACPxB,EAAYwB,MAAM,0BAA2B,iCAAkC,CAC7EA,QACAC,MAAOD,aAAiBE,MAAQF,EAAMC,WAAQ,EAC9CvB,OAAQH,EAAeI,KAIzB,MAAMwB,EAAe,CACnBxB,GAAIJ,EAAeI,GACnBhC,MAAO4B,EAAe5B,OAAS,sBAC/BE,SAAU0B,EAAe1B,UAAY0B,EAAe5B,OAAOkC,MAAM,KAAK,IAAM,OAC5EC,MAAO,EACPC,QAAS,EACTE,MAAO,IACPC,KAAM,GACNC,UAAWZ,EAAea,UAAA,IAAeC,MAAOC,cAChDC,YAAA,IAAgBF,MAAOC,cACvBG,YAAa,CACXC,MAAO,SACPC,SAAU,KACVC,eAAe,EACfC,cAAc,EACdC,UAAW,GACXC,SAAU,QAKd,OADAvB,EAAYC,IAAI,0BAA2B,yCAA0C0B,GAC9EA,CACT,GAIIC,qBAAuB,CAACzD,EAAeC,EAAkBC,KAC7D,MAAMwD,EAAoB7C,aACxB,CAAEb,QAAOC,WAAUC,YACnBqB,EAAkBC,QAGdmC,EAAmBzC,OAAOC,QAAQuC,GACrCE,OAAO,EAAEC,EAAGC,MAAaA,EAAOlD,SAChCmD,IAAI,EAAE/C,EAAO8C,KAAY,GAAG9C,MAAU8C,EAAOrD,OAAOuD,KAAK,SAE5D,GAAIL,EAAiBhE,OAAS,EAC5B,MAAM,IAAI4D,MAAMI,EAAiBK,KAAK,QAIpCC,qBAAuB,CAACjE,EAAeC,KAC3C,MAAMyD,EAAoB7C,aACxB,CAAEb,QAAOC,YACTsB,EAAkBE,QAGdkC,EAAmBzC,OAAOC,QAAQuC,GACrCE,OAAO,EAAEC,EAAGC,MAAaA,EAAOlD,SAChCmD,IAAI,EAAE/C,EAAO8C,KAAY,GAAG9C,MAAU8C,EAAOrD,OAAOuD,KAAK,SAE5D,GAAIL,EAAiBhE,OAAS,EAC5B,MAAM,IAAI4D,MAAMI,EAAiBK,KAAK,QAIpCE,yBAA2B,CAAClE,EAAeE,EAAkBD,KAAA,CACjEC,SAAUkB,cAAclB,GACxBF,MAAOoB,cAAcpB,GACrBC,WACAkE,gBAAiBlE,EACjBkC,MAAO,EACPE,SAAU,EACVC,MAAO,IACPC,KAAM,GACNM,aAAA,IAAiBH,MAAOC,cACxBG,YAAa,CACXC,MAAO,SACPC,SAAU,KACVC,eAAe,EACfC,cAAc,EACdC,UAAW,GACXC,SAAU,SAwBRgB,kBAAqBf,GACnBA,aAAiBE,MAEnBF,EAAM9D,QAAQ8E,SAAS,YAClB,wCACEhB,EAAM9D,QAAQ8E,SAAS,SACzB,qCAEAhB,EAAM9D,QAPuB,sBAWlC+E,kBAAqBjB,GACnBA,aAAiBE,MAEnBF,EAAM9D,QAAQ8E,SAAS,0BAClB,mFACEhB,EAAM9D,QAAQ8E,SAAS,qBACzB,+DAEAhB,EAAM9D,QAPuB,eAWlCgF,YAAc,CAACvE,EAAeC,KACkCuE,EAKhEC,sBAAwB9C,MAAO3B,EAAeC,KAClD,MAAMyE,EAAiBtD,cAAcpB,GAGrC,IACE,aAAa2E,EAAGC,WAAW,SAASC,iBAAiBH,EAAgBzE,EACvE,OAAS6E,GAEP,OADAjD,EAAYC,IAAI,0BAA2B,6CAC9B6C,EAAGC,WAAW,SAASC,iBAAiBH,EAAgBzE,EACvE,GAGI8E,qBAAuBpD,MAAOI,IAClC,UACQ4C,EAAGC,WAAW,SAASI,OAAOjD,EAAQ,CAC1Cc,aAAA,IAAiBH,MAAOC,gBAE1Bd,EAAYC,IAAI,0BAA2B,2BAC7C,OAASmD,GACPpD,EAAYqD,KAAK,0BAA2B,oCAAqC,CAC/E7B,MAAO4B,GAEX,GAKWE,EAAeC,IAAoB,CAACC,EAAKC,KAAA,CACpDC,KAAM,KACNC,QAAS,KACTC,iBAAiB,EACjBC,WAAW,EACXrC,MAAO,KAEP7B,OAAQG,MAAO3B,EAAeC,EAAkBC,KAC9C2B,EAAYC,IAAI,0BAA2B,iBAAkB,CAC3D9B,QACAE,WACAyF,eAAgB1F,EAASN,SAG3B0F,EAAI,CAAEK,WAAW,EAAMrC,MAAO,OAE9B,IACEI,qBAAqBzD,EAAOC,EAAUC,GAEtC,MAAM0F,EAAW1B,yBAAyBlE,EAAOE,EAAUD,GAC3D4B,EAAYC,IAAI,0BAA2B,8BAA+B,CACxE9B,MAAO4F,EAAS5F,MAChBE,SAAU0F,EAAS1F,WAGrB,MAAM2F,QAAgBlB,EAAGC,WAAW,SAASQ,OAAOQ,GACpD/D,EAAYC,IAAI,0BAA2B,4BAA6B,CACtEC,OAAQ8D,EAAQ7D,KAIlB,MAAM8D,QAAiBnB,EAAGC,WAAW,SAASC,iBAAiBe,EAAS5F,MAAOC,GAC/E4B,EAAYC,IAAI,0BAA2B,8BAA+B,CACxEC,OAAQ+D,EAASC,OAAO/D,GACxBgE,WAAYF,EAASG,QAGvB,MAAMV,QAAa7D,sBAAsBoE,EAASC,QAElDV,EAAI,CACFE,OACAC,QAASM,EACTL,iBAAiB,EACjBC,WAAW,EACXrC,MAAO,MAGX,OAASA,GACPxB,EAAYwB,MAAM,0BAA2B,eAAgB,CAC3DA,QACAC,MAAOD,aAAiBE,MAAQF,EAAMC,WAAQ,IAGhD+B,EAAI,CACFhC,MAAOe,kBAAkBf,GACzBqC,WAAW,GAEf,CAEA7D,EAAYC,IAAI,0BAA2B,iBAG7CL,OAAQE,MAAO3B,EAAeC,KAC5B4B,EAAYC,IAAI,0BAA2B,iBAAkB,CAC3D9B,QACA2F,eAAgB1F,EAASN,OACzB4E,YAAuB,SAAVvE,IAGfqF,EAAI,CAAEK,WAAW,EAAMrC,MAAO,OAE9B,MAAM6C,EAAYC,WAAW,KAC3BtE,EAAYqD,KAAK,0BAA2B,0BAC5CG,EAAI,CAAEK,WAAW,EAAOrC,MAAO,wCAC9B,KAEH,IAEMkB,YAAYvE,EAAOC,GAkBvBgE,qBAAqBjE,EAAOC,GAG5B4B,EAAYC,IAAI,0BAA2B,wCAC3C,MAAMgE,QAAiBrB,sBAAsBzE,EAAOC,GAQpD,GANA4B,EAAYC,IAAI,0BAA2B,kBAAmB,CAC5DsE,YAAaN,EAASC,OACtBC,WAAYF,EAASG,MACrBlE,OAAQ+D,EAASC,QAAQ/D,KAGvB8D,EAASC,QAAUD,EAASG,MAAO,CACrCpE,EAAYC,IAAI,0BAA2B,8CAE3C,MAAMyD,QAAa7D,sBAAsBoE,EAASC,cAC5ChB,qBAAqBe,EAASC,OAAO/D,IAE3CqE,aAAaH,GAEbb,EAAI,CACFE,OACAC,QAASM,EACTL,iBAAiB,EACjBC,WAAW,EACXrC,MAAO,OAGTxB,EAAYC,IAAI,0BAA2B,yBAC7C,MACED,EAAYqD,KAAK,0BAA2B,gCAC5CmB,aAAaH,GACbb,EAAI,CACFhC,MAAO,4CACPqC,WAAW,GAGjB,OAASrC,GACPxB,EAAYwB,MAAM,0BAA2B,eAAgB,CAC3DA,QACAC,MAAOD,aAAiBE,MAAQF,EAAMC,WAAQ,IAGhD+C,aAAaH,GACbb,EAAI,CACFhC,MAAOiB,kBAAkBjB,GACzBqC,WAAW,GAEf,CAEA7D,EAAYC,IAAI,0BAA2B,iBAG7CwE,QAAS3E,UACPE,EAAYC,IAAI,0BAA2B,mBAE3C,IACED,EAAYC,IAAI,0BAA2B,sCAC3C6C,EAAG4B,UAAUC,QAEb3E,EAAYC,IAAI,0BAA2B,uBAC3CuD,EAAI,CACFE,KAAM,KACNC,QAAS,KACTC,iBAAiB,EACjBpC,MAAO,OAGTxB,EAAYC,IAAI,0BAA2B,0BAC7C,OAASuB,GACPxB,EAAYwB,MAAM,0BAA2B,gBAAiB,CAC5DA,QACAC,MAAOD,aAAiBE,MAAQF,EAAMC,WAAQ,IAGhD+B,EAAI,CACFhC,MAAOA,aAAiBE,MAAQF,EAAM9D,QAAU,iBAEpD,GAGFkH,cAAe9E,MAAO3B,IACpB6B,EAAYC,IAAI,0BAA2B,wBAAyB,CAAE9B,UAEtEqF,EAAI,CAAEK,WAAW,EAAMrC,MAAO,OAE9B,UACQsB,EAAGC,WAAW,SAAS8B,qBAAqB1G,GAElDqF,EAAI,CACFK,WAAW,EACXrC,MAAO,OAGTxB,EAAYC,IAAI,0BAA2B,gCAC7C,OAASuB,GACPxB,EAAYwB,MAAM,0BAA2B,uBAAwB,CACnEA,QACAC,MAAOD,aAAiBE,MAAQF,EAAMC,WAAQ,IAGhD,IAAIqD,EAAe,wBACftD,aAAiBE,QAEjBoD,EADEtD,EAAM9D,QAAQ8E,SAAS,iBACV,sCACNhB,EAAM9D,QAAQ8E,SAAS,aACjB,4CAEAhB,EAAM9D,SAIzB8F,EAAI,CACFhC,MAAOsD,EACPjB,WAAW,GAEf,GAGFkB,eAAgBjF,MAAOkF,IACrBhF,EAAYC,IAAI,0BAA2B,yBAA0B,CACnE6D,eAAgBkB,EAAYlH,SAG9B,MAAMmH,EAAexB,IACrBzD,EAAYC,IAAI,0BAA2B,qBAAsB,CAC/DiF,UAAWD,EAAavB,KACxByB,aAAcF,EAAatB,QAC3BC,gBAAiBqB,EAAarB,kBAGhCJ,EAAI,CAAEK,WAAW,EAAMrC,MAAO,OAE9B,IAEE,IAAKwD,GAAeA,EAAYlH,OAAS,EACvC,MAAM,IAAI4D,MAAM,gDAGlB,IAAKuD,EAAavB,MAAMvD,GACtB,MAAM,IAAIuB,MAAM,+BAGlB1B,EAAYC,IAAI,0BAA2B,sCAErC6C,EAAGC,WAAW,SAASI,OAAO8B,EAAavB,KAAKvD,GAAI,CACxD/B,SAAU4G,EACV1C,gBAAiB0C,IAGnBhF,EAAYC,IAAI,0BAA2B,8BAE3CuD,EAAI,CAAEK,WAAW,EAAOrC,MAAO,OAE/BxB,EAAYC,IAAI,0BAA2B,iCAC7C,OAASuB,GACP,MAAMsD,EACJtD,aAAiBE,MACbF,EAAM9D,QACN,oDAUN,MARAsC,EAAYwB,MAAM,0BAA2B,wBAAyB,CACpEA,MAAOsD,EACPM,UAAW5D,GAAO6D,aAAaC,KAC/B7D,MAAOD,aAAiBE,MAAQF,EAAMC,WAAQ,IAGhD+B,EAAI,CAAEK,WAAW,EAAOrC,MAAOsD,IAEzB,IAAIpD,MAAMoD,EAClB,GAGFS,cAAezF,MAAO0F,IACpB,MAAM9B,KAAEA,GAASD,IAOjB,GALAzD,EAAYC,IAAI,0BAA2B,wBAAyB,CAClEC,OAAQwD,GAAMvD,GACdqF,QAASnG,OAAOoG,KAAKD,KAGlB9B,EAKL,IACE,MAAMgC,EAAa,CACjBrH,SAAUmH,EAAQnH,SAClBiC,MAAOkF,EAAQlF,MACfE,SAAUgF,EAAQjF,QAClBE,MAAO+E,EAAQ/E,MACfC,KAAM8E,EAAQ9E,KACdO,YAAauE,EAAQvE,YACrBD,aAAA,IAAiBH,MAAOC,eAG1Bd,EAAYC,IAAI,0BAA2B,+BAAgCyF,SAErE5C,EAAGC,WAAW,SAASI,OAAOO,EAAKvD,GAAIuF,GAE7C1F,EAAYC,IAAI,0BAA2B,6BAC3CuD,EAAI,CAAEE,KAAM,IAAKA,KAAS8B,KAE1BxF,EAAYC,IAAI,0BAA2B,gCAC7C,OAASuB,GACPxB,EAAYwB,MAAM,0BAA2B,uBAAwB,CACnEA,QACAC,MAAOD,aAAiBE,MAAQF,EAAMC,WAAQ,IAGhD+B,EAAI,CACFhC,MAAOA,aAAiBE,MAAQF,EAAM9D,QAAU,yBAEpD,MAhCEsC,EAAYqD,KAAK,0BAA2B,qCAmChDsC,WAAY,KACV3F,EAAYC,IAAI,0BAA2B,wBAC3CuD,EAAI,CAAEhC,MAAO,QAGfoE,eAAgB9F,UACdE,EAAYC,IAAI,0BAA2B,0BAE3C,IACE,GAAI6C,EAAG4B,UAAU3F,SAAW+D,EAAG4B,UAAUmB,MAAO,CAC9C7F,EAAYC,IAAI,0BAA2B,0CAA2C,CACpFC,OAAQ4C,EAAG4B,UAAUmB,MAAM1F,GAC3BhC,MAAO2E,EAAG4B,UAAUmB,MAAM1H,QAG5B,MAAMuF,QAAa7D,sBAAsBiD,EAAG4B,UAAUmB,OAEtD7F,EAAYC,IAAI,0BAA2B,mDAC3CuD,EAAI,CACFE,OACAC,QAAS,CACPO,OAAQpB,EAAG4B,UAAUmB,MACrBzB,MAAOtB,EAAG4B,UAAUN,OAEtBR,iBAAiB,GAErB,MACE5D,EAAY8F,KAAK,0BAA2B,mDAG9C9F,EAAYC,IAAI,0BAA2B,uBAC7C,OAASuB,GACPxB,EAAYwB,MAAM,0BAA2B,4BAA6B,CACxEA,QACAC,MAAOD,aAAiBE,MAAQF,EAAMC,WAAQ,IAGhD+B,EAAI,CACFE,KAAM,KACNC,QAAS,KACTC,iBAAiB,GAErB,GAIFmC,MAAOjG,MAAO3B,EAAeC,KAC3B,MAAMwB,OAAEA,GAAW6D,UACb7D,EAAOzB,EAAOC,IAGtB4H,SAAUlG,MAAO3B,EAAeE,EAAkBD,KAChD,MAAMuB,OAAEA,GAAW8D,UACb9D,EAAOxB,EAAOC,EAAUC,IAGhC4H,OAAQ,KACN,MAAMxB,QAAEA,GAAYhB,IACpBgB,KAGFyB,WAAaV,IACX,MAAM9B,KAAEA,GAASD,IACbC,GACFF,EAAI,CAAEE,KAAM,IAAKA,KAAS8B,SAMhC1C,EAAG4B,UAAUyB,SAAS,CAAC/B,EAAOF,KAC5BlE,EAAY8F,KAAK,0BAA2B,6BAA8B,CACxE3B,WAAYC,EACZG,YAAaL,EACbhE,OAAQgE,GAAQ/D,GAChBiG,WAAA,IAAevF,MAAOC,gBAGpBsD,GAASF,GACXlE,EAAYC,IAAI,0BAA2B,iDAE3CJ,sBAAsBqE,GAAQmC,KAAK3C,IACjC1D,EAAYC,IAAI,0BAA2B,0CAC3CqD,EAAagD,SAAS,CACpB5C,OACAC,QAAS,CAAEO,SAAQE,SACnBR,iBAAiB,MAElB2C,MAAM/E,IACPxB,EAAYwB,MAAM,0BAA2B,4CAA6C,CACxFA,QACAtB,OAAQgE,EAAO/D,SAInBH,EAAYC,IAAI,0BAA2B,kDAE3CqD,EAAagD,SAAS,CACpB5C,KAAM,KACNC,QAAS,KACTC,iBAAiB,OC5mBhB,MAAM4C,EAAgBjD,IAC3BkD,EACE,CAACjD,EAAKC,KAAA,CACJvC,MAAO,SACPwF,YAAa,QAEbC,SAAWzF,IACTsC,EAAI,CAAEtC,UAGN,MAAMwF,YAAEA,GAAgBjD,IAGD,UAFU,WAAVvC,EAAqBwF,EAAcxF,GAGxD0F,SAASC,gBAAgBC,UAAUC,IAAI,QAEvCH,SAASC,gBAAgBC,UAAUE,OAAO,SAI9CC,YAAa,KACX,MAAM/F,MAAEA,GAAUuC,IACZyD,EAAqB,UAAVhG,EAAoB,OAAS,QAC9CuC,IAAMkD,SAASO,IAGjBC,gBAAiB,KAEf,MAAMT,EAAcU,OAAOC,WAAW,gCAAgCC,QAClE,OACA,QAEJ9D,EAAI,CAAEkD,gBAGNU,OAAOC,WAAW,gCACfE,iBAAiB,SAAWC,IAC3B,MAAMC,EAAiBD,EAAEF,QAAU,OAAS,QAC5C9D,EAAI,CAAEkD,YAAae,IAGnB,MAAQvG,SAAUuC,IACJ,WAAVvC,IACqB,SAAnBuG,EACFb,SAASC,gBAAgBC,UAAUC,IAAI,QAEvCH,SAASC,gBAAgBC,UAAUE,OAAO,WAMlD,MAAM9F,MAAEA,GAAUuC,IAGK,UAFU,WAAVvC,EAAqBwF,EAAcxF,GAGxD0F,SAASC,gBAAgBC,UAAUC,IAAI,QAEvCH,SAASC,gBAAgBC,UAAUE,OAAO,WAIhD,CACE1B,KAAM,gBACNoC,WAAaC,IAAA,CAAazG,MAAOyG,EAAMzG,WCEvC0G,EAAkC,CACtC,CACEzH,GAAI,IACJmF,KAAM,cACNuC,YAAa,oCACbC,KAAM,KACNC,SAAU,mBACVC,aAAc,CAAC,CAAEC,KAAM,qBAAsBrK,MAAO,EAAGsK,SAAU,QACjEC,SAAU,GACVC,WAAY,GACZC,UAAU,EACVC,OAAQ,UAEV,CACEnI,GAAI,IACJmF,KAAM,gBACNuC,YAAa,gCACbC,KAAM,KACNC,SAAU,UACVC,aAAc,CAAC,CAAEC,KAAM,iBAAkBrK,MAAO,EAAGsK,SAAU,QAC7DC,SAAU,IACVC,WAAY,GACZC,UAAU,EACVC,OAAQ,QAEV,CACEnI,GAAI,IACJmF,KAAM,gBACNuC,YAAa,0CACbC,KAAM,KACNC,SAAU,WACVC,aAAc,CACZ,CAAEC,KAAM,mBAAoBrK,MAAO,IAAKsK,SAAU,MAClD,CAAED,KAAM,gBAAiBrK,MAAO,GAAIsK,SAAU,QAEhDC,SAAU,IACVC,WAAY,GACZC,UAAU,EACVC,OAAQ,QAEV,CACEnI,GAAI,IACJmF,KAAM,cACNuC,YAAa,wCACbC,KAAM,IACNC,SAAU,UACVC,aAAc,CACZ,CAAEC,KAAM,mBAAoBrK,MAAO,GAAIsK,SAAU,OACjD,CAAED,KAAM,eAAgBrK,MAAO,IAAKsK,SAAU,QAEhDC,SAAU,IACVC,WAAY,GACZC,UAAU,EACVC,OAAQ,QAEV,CACEnI,GAAI,IACJmF,KAAM,UACNuC,YAAa,yBACbC,KAAM,KACNC,SAAU,mBACVC,aAAc,CAAC,CAAEC,KAAM,cAAerK,MAAO,IAAMsK,SAAU,QAC7DC,SAAU,IACVC,WAAY,IACZC,UAAU,EACVC,OAAQ,QAEV,CACEnI,GAAI,IACJmF,KAAM,SACNuC,YAAa,iBACbC,KAAM,KACNC,SAAU,UACVC,aAAc,CAAC,CAAEC,KAAM,aAAcrK,MAAO,GAAIsK,SAAU,QAC1DC,SAAU,IACVC,WAAY,IACZC,UAAU,EACVC,OAAQ,cAINC,EAA8B,CAClC,CACEpI,GAAI,IACJqI,MAAO,cACPX,YAAa,uBACbI,KAAM,QACND,aAAc,CAAC,CAAEC,KAAM,sBAAuBQ,OAAQ,GAAIZ,YAAa,mBACvEa,QAAS,CACP,CAAET,KAAM,KAAMU,OAAQ,IACtB,CAAEV,KAAM,QAASU,OAAQ,KAE3BC,WAAA,IAAe/H,MAAOC,cACtB+H,QAAS,IAAIhI,KAAKA,KAAKiI,MAAQ,OAAqBhI,cACpDiI,UAAU,EACVC,iBAAkB,MAEpB,CACE7I,GAAI,IACJqI,MAAO,iBACPX,YAAa,+BACbI,KAAM,SACND,aAAc,CAAC,CAAEC,KAAM,qBAAsBQ,OAAQ,IAAKZ,YAAa,8BACvEa,QAAS,CACP,CAAET,KAAM,KAAMU,OAAQ,KACtB,CAAEV,KAAM,QAASU,OAAQ,IACzB,CAAEV,KAAM,OAAQU,OAAQ,IAE1BC,UAAW,IAAI/H,KAAKA,KAAKiI,MAAQ,QAAyBhI,cAC1D+H,QAAS,IAAIhI,KAAKA,KAAKiI,MAAQ,QAAyBhI,cACxDiI,UAAU,EACVC,iBAAkB,KAEpB,CACE7I,GAAI,IACJqI,MAAO,kBACPX,YAAa,wCACbI,KAAM,SACND,aAAc,CAAC,CAAEC,KAAM,oBAAqBQ,OAAQ,EAAGZ,YAAa,2CACpEa,QAAS,CACP,CAAET,KAAM,KAAMU,OAAQ,KACtB,CAAEV,KAAM,QAASU,OAAQ,IACzB,CAAEV,KAAM,QAASgB,OAAQ,oBAE3BL,UAAW,IAAI/H,KAAKA,KAAKiI,MAAQ,QAAyBhI,cAC1D+H,QAAS,IAAIhI,KAAKA,KAAKiI,MAAQ,OAAyBhI,cACxDiI,UAAU,EACVC,iBAAkB,MAIhBE,EAAgD,CACpDC,UAAa,CACXhJ,GAAI,YACJ8H,KAAM,KACNmB,OAAQ,SACR9J,QAAS,CACP,CAAEY,OAAQ,IAAK7B,SAAU,WAAYgL,MAAO,KAAMC,KAAM,EAAGC,OAAQ,GACnE,CAAErJ,OAAQ,IAAK7B,SAAU,cAAegL,MAAO,KAAMC,KAAM,EAAGC,OAAQ,GACtE,CAAErJ,OAAQ,IAAK7B,SAAU,eAAgBgL,MAAO,KAAMC,KAAM,EAAGC,WAC/D,CAAErJ,OAAQ,IAAK7B,SAAU,YAAagL,MAAO,KAAMC,KAAM,EAAGC,OAAQ,GACpE,CAAErJ,OAAQ,IAAK7B,SAAU,aAAcgL,MAAO,KAAMC,KAAM,EAAGC,WAC7D,CAAErJ,OAAQ,IAAK7B,SAAU,WAAYgL,MAAO,KAAMC,KAAM,EAAGC,OAAQ,GACnE,CAAErJ,OAAQ,IAAK7B,SAAU,YAAagL,MAAO,KAAMC,KAAM,EAAGC,OAAQ,GACpE,CAAErJ,OAAQ,IAAK7B,SAAU,aAAcgL,MAAO,KAAMC,KAAM,EAAGC,WAC7D,CAAErJ,OAAQ,IAAK7B,SAAU,aAAcgL,MAAO,KAAMC,KAAM,EAAGC,OAAQ,GACrE,CAAErJ,OAAQ,KAAM7B,SAAU,cAAegL,MAAO,KAAMC,KAAM,GAAIC,QAAQ,IAE1EC,WAAA,IAAe3I,MAAOC,eAExB2I,gBAAmB,CACjBtJ,GAAI,kBACJ8H,KAAM,SACNmB,OAAQ,WACR9J,QAAS,CACP,CAAEY,OAAQ,IAAK7B,SAAU,cAAegL,MAAO,GAAIC,KAAM,EAAGC,OAAQ,GACpE,CAAErJ,OAAQ,IAAK7B,SAAU,eAAgBgL,MAAO,GAAIC,KAAM,EAAGC,OAAQ,GACrE,CAAErJ,OAAQ,IAAK7B,SAAU,YAAagL,MAAO,GAAIC,KAAM,EAAGC,OAAQ,GAClE,CAAErJ,OAAQ,IAAK7B,SAAU,WAAYgL,MAAO,GAAIC,KAAM,EAAGC,WACzD,CAAErJ,OAAQ,IAAK7B,SAAU,aAAcgL,MAAO,GAAIC,KAAM,EAAGC,OAAQ,GACnE,CAAErJ,OAAQ,IAAK7B,SAAU,WAAYgL,MAAO,GAAIC,KAAM,EAAGC,OAAQ,GACjE,CAAErJ,OAAQ,IAAK7B,SAAU,YAAagL,MAAO,GAAIC,KAAM,EAAGC,WAC1D,CAAErJ,OAAQ,IAAK7B,SAAU,aAAcgL,MAAO,GAAIC,KAAM,EAAGC,WAC3D,CAAErJ,OAAQ,IAAK7B,SAAU,aAAcgL,MAAO,GAAIC,KAAM,EAAGC,OAAQ,GACnE,CAAErJ,OAAQ,KAAM7B,SAAU,cAAegL,MAAO,GAAIC,KAAM,GAAIC,OAAQ,IAExEC,WAAA,IAAe3I,MAAOC,gBAKpB4I,eAAkBC,GACfC,KAAKC,MAAMD,KAAKE,KAAKH,EAAK,MAAQ,EAIrCI,uBAA0BzJ,GACW,IAArBsJ,KAAKI,IAAI1J,EAAO,GAKhC2J,oBAAsB,MAC1BC,WAAY,EACZC,kBAAmB,EACnBC,qBAAsB,EACtBC,sBAAuB,EACvBC,gBAAiB,EACjBC,eAAgB,EAChBC,eAAgB,EAChBC,kBAAmB,EACnBC,aAAc,EACdC,eAAgB,EAChBC,cAAe,EACfC,cAAe,EACfC,KAAM,EACNC,SAAU,EACVzK,MAAO,EACPqJ,GAAI,EACJqB,cAAe,MAIXC,iBAAmB,MACvBf,WAAY,KACZC,kBAAmB,GACnBC,qBAAsB,IACtBC,sBAAuB,IACvBC,gBAAiB,KACjBC,eAAgB,KAChBC,eAAgB,GAChBC,kBAAmB,IACnBC,aAAc,EACdC,eAAgB,EAChBC,cAAe,GACfC,cAAe,GACfC,KAAM,IACNC,SAAU,GACVzK,MAAO,EACPqJ,GAAI,KACJqB,cAAe,OAGJE,EAAuB3H,IAClCkD,EACE,CAACjD,EAAKC,KAAA,CACJ0H,UAAWlB,sBACXmB,iBAAiB,EACjBC,eAAe,EAEfC,aAAc1D,EACd2D,iBAAkB,GAElBC,WAAY,KAEZC,iBAAkBlD,EAClBmD,4BAA6B,GAE7BC,aAAczC,EAEd0C,gBAAkBC,IAChBrI,EAAKmE,IACH,MAAMmE,EAAW,IAAKnE,EAAMwD,aAAcU,GAQ1C,YALiB,IAAbA,EAAMlC,KACRmC,EAASxL,MAAQoJ,eAAeoC,EAASnC,IACzCmC,EAASd,cAAgBjB,uBAAuB+B,EAASxL,QAGpD,CACL6K,UAAWW,EACXV,iBAAiB,EACjBC,eAAe,MAKrBU,mBAAqBC,IACnB,MAAMT,iBAAEA,GAAqB9H,IACxB8H,EAAiBU,QAAWC,EAAGF,gBAAkBA,IACpDxI,EAAKmE,IAAA,CACH4D,iBAAkB,IACb5D,EAAM4D,iBACT,CACEpL,GAAIU,KAAKiI,MAAMqD,WACfjM,OAAQ,IACR8L,gBACAI,UAAA,IAAcvL,MAAOC,oBAO/BuL,aAAeC,IACb9I,EAAKmE,IAAA,CACH6D,WAAY7D,EAAM6D,WAAa,IAAK7D,EAAM6D,cAAec,GAAW,SAIxEC,cAAgBC,IACd,MAAMd,4BAAEA,GAAgCjI,IACnCiI,EAA4BO,QAAUQ,EAAED,cAAgBA,IAC3DhJ,EAAKmE,IAAA,CACH+D,4BAA6B,IACxB/D,EAAM+D,4BACT,CACEvL,GAAIU,KAAKiI,MAAMqD,WACfjM,OAAQ,IACRsM,cACAE,SAAU,GACVC,WAAW,EACXC,UAAA,IAAc/L,MAAOC,cACrB+L,kBAAmB,GACnBC,eAAgB,GAChBjC,cAAe,EACfkC,SAAU,QAOpBC,wBAAyB,CAACR,EAAaE,KACrClJ,EAAKmE,IAAA,CACH+D,4BAA6B/D,EAAM+D,4BAA4BxJ,IAAIuK,GACjEA,EAAED,cAAgBA,EACd,IAAKC,EAAGC,SAAU,IAAKD,EAAEC,YAAaA,IACtCD,OAKVQ,qBAAuBT,IACrB,MAAMf,iBAAEA,EAAAC,4BAAkBA,GAAgCjI,IACpDyJ,EAAYzB,EAAiBQ,KAAKkB,GAAKA,EAAEhN,KAAOqM,GAChDY,EAAgB1B,EAA4BO,KAAKQ,GAAKA,EAAED,cAAgBA,GAE9E,GAAIU,GAAaE,GAAiBA,EAAcT,UAAW,CAEzD,IAAIU,EAAW,EAEXC,EAAe,EAEnBJ,EAAUxE,QAAQ6E,QAAQC,IACJ,OAAhBA,EAAOvF,MAAiBuF,EAAO7E,OACjC0E,GAAYG,EAAO7E,OACM,UAAhB6E,EAAOvF,MAAoBuF,EAAO7E,SAC3C2E,GAAgBE,EAAO7E,UAK3BnF,EAAKmE,IAAA,CACHwD,UAAW,IACNxD,EAAMwD,UACTjB,WAAYvC,EAAMwD,UAAUjB,WAAamD,EAAW,IAGtD3B,4BAA6B/D,EAAM+D,4BAA4B3J,OAC7D0K,GAAKA,EAAED,cAAgBA,KAG7B,GAGFiB,mBAAoB,KAElBjK,EAAI,CACF2H,UAAWF,mBACXK,aAAc1D,EACd6D,iBAAkBlD,EAClBoD,aAAczC,EACdqC,iBAAkB,CAChB,CACEpL,GAAI,IACJD,OAAQ,IACR8L,cAAe,IACfI,SAAU,IAAIvL,KAAKA,KAAKiI,MAAQ,OAA0BhI,eAE5D,CACEX,GAAI,IACJD,OAAQ,IACR8L,cAAe,IACfI,SAAU,IAAIvL,KAAKA,KAAKiI,MAAQ,OAAyBhI,gBAG7D0K,WAAY,CACVrL,GAAI,IACJD,OAAQ,IACR2K,cAAe,GACfD,cAAe,GACf8C,eAAA,IAAmB7M,MAAOC,cAC1B6M,YAAa,EACbhN,UAAW,IAAIE,KAAKA,KAAKiI,MAAQ,QAA0BhI,eAE7D4K,4BAA6B,CAC3B,CACEvL,GAAI,IACJD,OAAQ,IACRsM,YAAa,IACbE,SAAU,CAAEkB,oBAAqB,IACjCjB,WAAW,EACXC,UAAA,IAAc/L,MAAOC,cACrB+M,aAAA,IAAiBhN,MAAOC,cACxB+L,kBAAmB,CAAEiB,aAAe,GACpChB,eAAgB,GAChBjC,cAAe,EACfkC,SAAU,GAEZ,CACE5M,GAAI,IACJD,OAAQ,IACRsM,YAAa,IACbE,SAAU,CAAEqB,mBAAoB,KAChCpB,WAAW,EACXC,SAAU,IAAI/L,KAAKA,KAAKiI,MAAQ,QAAyBhI,cACzD+L,kBAAmB,CAAEiB,aAAe,EAAME,aAAe,GACzDlB,eAAgB,CACd,CACEmB,KAAM,EACNrF,UAAW,IAAI/H,KAAKA,KAAKiI,MAAQ,QAAyBhI,cAC1D+H,SAAA,IAAahI,MAAOC,cACpB4L,SAAU,CAAEqB,mBAAoB,KAChCpB,WAAW,EACXkB,aAAA,IAAiBhN,MAAOC,cACxBoN,eAAe,IAGnBrD,cAAe,EACfkC,SAAU,IAGd3B,iBAAiB,EACjBC,eAAe,KAInB8C,kBAAmB,KAEjB3K,EAAI,CACF2H,UAAWlB,sBACXsB,iBAAkB,GAClBC,WAAY,KACZE,4BAA6B,GAC7BN,iBAAiB,EACjBC,eAAe,KAInB+C,iBAAkB,KAEhB5K,EAAI,CACF2H,UAAWlB,sBACXsB,iBAAkB,GAClBC,WAAY,KACZE,4BAA6B,GAC7BN,iBAAiB,EACjBC,eAAe,KAInBgD,YAAa,CAACvD,EAAMC,KAClBvH,EAAKmE,IAAA,CACHwD,UAAW,IACNxD,EAAMwD,UACTL,KAAMnD,EAAMwD,UAAUL,KAAOA,EAC7BC,SAAUpD,EAAMwD,UAAUJ,SAAWA,OAK3CuD,cAAe,CAACxD,EAAMC,KACpB,MAAMI,UAAEA,GAAc1H,IACtB,OAAI0H,EAAUL,MAAQA,GAAQK,EAAUJ,UAAYA,IAClDvH,EAAKmE,IAAA,CACHwD,UAAW,IACNxD,EAAMwD,UACTL,KAAMnD,EAAMwD,UAAUL,KAAOA,EAC7BC,SAAUpD,EAAMwD,UAAUJ,SAAWA,OAGlC,IAMXwD,mBAAoB,CAACC,GAAkB,KACvB/K,IAGH4H,eAGP7H,EAFEgL,EAEE,CACFrD,UAAWF,mBACXK,aAAc1D,EACd6D,iBAAkBlD,EAClBoD,aAAczC,EACdqC,iBAAkB,CAChB,CACEpL,GAAI,IACJD,OAAQ,IACR8L,cAAe,IACfI,SAAU,IAAIvL,KAAKA,KAAKiI,MAAQ,OAA0BhI,eAE5D,CACEX,GAAI,IACJD,OAAQ,IACR8L,cAAe,IACfI,SAAU,IAAIvL,KAAKA,KAAKiI,MAAQ,OAAyBhI,gBAG7D0K,WAAY,CACVrL,GAAI,IACJD,OAAQ,IACR2K,cAAe,GACfD,cAAe,GACf8C,eAAA,IAAmB7M,MAAOC,cAC1B6M,YAAa,EACbhN,UAAW,IAAIE,KAAKA,KAAKiI,MAAQ,QAA0BhI,eAE7D4K,4BAA6B,CAC3B,CACEvL,GAAI,IACJD,OAAQ,IACRsM,YAAa,IACbE,SAAU,CAAEkB,oBAAqB,IACjCjB,WAAW,EACXC,UAAA,IAAc/L,MAAOC,cACrB+M,aAAA,IAAiBhN,MAAOC,eAE1B,CACEX,GAAI,IACJD,OAAQ,IACRsM,YAAa,IACbE,SAAU,CAAEqB,mBAAoB,KAChCpB,WAAW,EACXC,SAAU,IAAI/L,KAAKA,KAAKiI,MAAQ,QAAyBhI,gBAG7DsK,iBAAiB,EACjBC,eAAe,GAIb,CACFF,UAAWlB,sBACXsB,iBAAkB,GAClBC,WAAY,KACZE,4BAA6B,GAC7BN,iBAAiB,EACjBC,eAAe,KAOvBoD,wBAAyB,CAACjC,EAAakC,EAAa/B,KAClDnJ,EAAKmE,IAAA,CACH+D,4BAA6B/D,EAAM+D,4BAA4BxJ,IAAIuK,GACjEA,EAAED,cAAgBA,EACd,IACKC,EACHI,kBAAmB,IACdJ,EAAEI,kBACL6B,CAACA,GAAc/B,IAGnBF,OAKVkC,qBAAsB,CAACnC,EAAaoC,KAClCpL,EAAKmE,IAAA,CACH+D,4BAA6B/D,EAAM+D,4BAA4BxJ,IAAIuK,GACjEA,EAAED,cAAgBA,EACd,IACKC,EACHK,eAAgBL,EAAEK,eACd,IAAIL,EAAEK,eAAe/K,OAAO8M,GAAKA,EAAEZ,OAASW,EAASX,MAAOW,GAC5D,CAACA,IAEPnC,OAKVqC,sBAAuB,CAACtC,EAAaF,KACnC9I,EAAKmE,IAAA,CACH+D,4BAA6B/D,EAAM+D,4BAA4BxJ,IAAIuK,GACjEA,EAAED,cAAgBA,EACd,IAAKC,EAAG5B,cAAeyB,GACvBG,OAKVsC,mBAAoB,CAACvC,EAAayB,KAChCzK,EAAKmE,IAAA,CACH+D,4BAA6B/D,EAAM+D,4BAA4BxJ,IAAIuK,GACjEA,EAAED,cAAgBA,EACd,IACKC,EACHK,eAAgBL,EAAEK,gBAAgB5K,IAAI2M,GACpCA,EAAEZ,OAASA,EACP,IAAKY,EAAGX,eAAe,GACvBW,IACD,IAEPpC,OAKVuC,qBAAsB,CAACxC,EAAakC,KAElC,MAAMjD,iBAAEA,GAAqBhI,IACXgI,EAAiBQ,KAAKkB,GAAKA,EAAEhN,KAAOqM,IAKpDhJ,EAAKmE,IAAA,CACH+D,4BAA6B/D,EAAM+D,4BAA4BxJ,IAAIuK,GACjEA,EAAED,cAAgBA,EACd,IACKC,EACHI,kBAAmB,IACdJ,EAAEI,kBACL,CAAC,GAAG6B,cAAwB,IAGhCjC,OAMZwC,0BAA2B,CAACC,EAAQC,KAIlCC,QAAQnP,IAAI,gBAAgBkP,uBAAkCD,KAG9D1L,EAAKmE,IAAA,CACHwD,UAAW,IACNxD,EAAMwD,eAMfkE,aAAc,CAACC,EAAcC,KAM3B,IAAIlC,EAAWiC,EACfjC,GAAYkC,EAGZ,MAAMC,EAAmD,GAAlC5F,KAAKC,MAAM0F,EAAiB,IACnDlC,GAAYmC,EAERnC,EAAW,GACb7J,EAAKmE,IACH,MAAM8H,EAAQ9H,EAAMwD,UAAUxB,GAAK0D,EAC7BqC,EAAWhG,eAAe+F,GAC1BE,EAAmB5F,uBAAuB2F,GAKhD,OAHAN,QAAQnP,IAAI,mBAAmBoN,SAAgBiC,YAAuBC,cAA2BC,sBACjGJ,QAAQnP,IAAI,gBAAgB0H,EAAMwD,UAAUxB,QAAQ8F,YAAgB9H,EAAMwD,UAAU7K,WAAWoP,MAExF,CACLvE,UAAW,IACNxD,EAAMwD,UACTxB,GAAI8F,EACJnP,MAAOoP,EACP1E,cAAe2E,EACfzF,WAAYvC,EAAMwD,UAAUjB,WAAaoF,EACzCnF,kBAAmBxC,EAAMwD,UAAUhB,kBAAoBmF,SAOnE,CACEhK,KAAM,uBACNoC,WAAaC,IAAA,CACXwD,UAAWxD,EAAMwD,UACjBI,iBAAkB5D,EAAM4D,iBACxBC,WAAY7D,EAAM6D,WAClBE,4BAA6B/D,EAAM+D,4BACnCN,gBAAiBzD,EAAMyD,gBACvBC,cAAe1D,EAAM0D,mBCtvBtB,SAASuE,cACdC,EACAC,EACAC,EAAqB,CAAE9H,KAAM,SAC7B+H,EAA8B,IAE9B,MAAO,CACLH,eACAC,cACAC,WACAC,YAGArI,MAAO,MACPsI,MAAO,EACPC,IAAK,EACLC,IAAK,EACLC,OAAQ,KACRC,KAAM,EACNC,OAAQ,EACRC,KAAM,EAGNC,aAAc,EACdC,mBAAoB,EACpBC,aAAc,EAGdnG,eAAgB,EAChBoG,kBAAmB,EAGnBC,MAAO,EACPC,YAAa,EACbC,aAAc,GAGdC,UAAW,EACXC,iBAAkB,EAEtB,CC9BA,MAAMC,MAAQ,IAAMpQ,KAAKiI,MA2GzBhJ,eAAeoR,oBAAoBC,SAC3BC,IACN,MAAMtI,EAAMmI,QACNI,EAAe,CACnBC,OAAQH,EAAKG,OACbhM,KAAM6L,EAAK7L,KACXuC,YAAasJ,EAAKtJ,YAClB0J,UAAW,EACXC,WAAY,EACZC,KAAMN,EAAKM,KACX9Q,UAAWmI,EACXU,UAAWV,GAGb,aADM4I,EAAGC,MAAM5K,IAAIsK,GACZA,CACT,CAEAvR,eAAe8R,iBAAiBN,GAE9B,aADMF,UACQM,EAAGC,MAAMlO,IAAI6N,IAAY,IACzC,CAEAxR,eAAe+R,qBAEb,aADMT,IACCM,EAAGC,MAAMG,QAAQ,aAAaC,UAAUC,SACjD,CAEAlS,eAAemS,oBAAoBX,EAAgBY,SAC3Cd,IACN,MAAMe,QAAiBT,EAAGC,MAAMlO,IAAI6N,GACpC,IAAKa,EAAU,MAAM,IAAIzQ,MAAM,mBAAmB4P,KAClD,MAAMc,EAAmB,IAAKD,KAAaD,EAAO1I,UAAWyH,SAE7D,aADMS,EAAGC,MAAMU,IAAID,GACZA,CACT,CAEAtS,eAAewS,oBAAoBhB,SAC3BF,UAEAM,EAAGC,MAAMY,OAAOjB,EACxB,CAEAxR,eAAe0S,oBAAoBC,SAC3BrB,IACN,MAAMtI,EAAMmI,QACNI,EAAe,CACnBqB,OAAQD,EAAKC,OACbpB,OAAQmB,EAAKnB,OACbqB,OAAQF,EAAKE,OACb3C,UAAWyC,EAAKzC,WAAa,GAC7B4C,MAAOH,EAAKG,OAAS,KACrBC,SAAUJ,EAAKI,UAAY,EAC3BC,KAAML,EAAKK,MAAQ,IACnBxC,OAAQmC,EAAKnC,QAAU,EACvB3I,MAAO8K,EAAK9K,OAAS,MACrBhH,UAAWmI,EACXU,UAAWV,GASb,aAPM4I,EAAGqB,YAAY,KAAMrB,EAAGsB,MAAOtB,EAAGC,MAAO7R,gBACvC4R,EAAGsB,MAAMjM,IAAIsK,GACnB,MAAMF,QAAaO,EAAGC,MAAMlO,IAAI4N,EAAIC,QAChCH,SACIO,EAAGC,MAAMU,IAAI,IAAKlB,EAAMI,WAAYJ,EAAKI,WAAa,GAAK,EAAG/H,UAAWyH,YAG5EI,CACT,CAEAvR,eAAemT,iBAAiBP,GAE9B,aADMtB,UACQM,EAAGsB,MAAMvP,IAAIiP,IAAY,IACzC,CAEA5S,eAAeoT,yBAAyB5B,GAEtC,aADMF,IACCM,EAAGsB,MAAMG,MAAM,UAAUC,OAAO9B,GAAQ+B,OAAO,YACxD,CAEAvT,eAAewT,oBAAoBZ,EAAgBR,SAC3Cd,IACN,MAAMe,QAAiBT,EAAGsB,MAAMvP,IAAIiP,GACpC,IAAKP,EAAU,MAAM,IAAIzQ,MAAM,mBAAmBgR,KAClD,MAAMN,EAAmB,IAAKD,KAAaD,EAAO1I,UAAWyH,SAE7D,aADMS,EAAGsB,MAAMX,IAAID,GACZA,CACT,CAEAtS,eAAeyT,oBAAoBb,SAC3BtB,IACN,MAAMe,QAAiBT,EAAGsB,MAAMvP,IAAIiP,SAC9BhB,EAAGqB,YAAY,KAAMrB,EAAGsB,MAAOtB,EAAGC,MAAO7R,UAE7C,SADM4R,EAAGsB,MAAMT,OAAOG,GAClBP,EAAU,CACZ,MAAMhB,QAAaO,EAAGC,MAAMlO,IAAI0O,EAASb,QACrCH,SACIO,EAAGC,MAAMU,IAAI,IAAKlB,EAAMI,UAAW3H,KAAK1L,IAAI,GAAIiT,EAAKI,WAAa,GAAK,GAAI/H,UAAWyH,SAEhG,GAEJ,CAEAnR,eAAe0T,mBAAmBC,SAC1BrC,IACN,MAAMC,EAAiB,IAAKoC,GAE5B,aADM/B,EAAGgC,QAAQ3M,IAAIsK,GACdA,CACT,CAEAvR,eAAe6T,2BAA2BjB,EAAgBkB,EAAQ,IAEhE,aADMxC,IACCM,EAAGgC,QAAQP,MAAM,UAAUC,OAAOV,GAAQX,UAAUsB,OAAO,cAAchN,KAAMwN,GAAQA,EAAIC,MAAM,EAAGF,GAC7G,CAEA9T,eAAeiU,kBAAkBC,SACzB5C,IACN,MAAMtI,EAAMmI,QACNI,EAAgB,CACpB4C,UAAWD,EAAQC,UACnBC,KAAMF,EAAQE,KACdC,YAAaH,EAAQG,YACrBC,SAAUJ,EAAQI,SAClBC,WAAYL,EAAQK,aAAeL,EAAQE,KAAOF,EAAQE,KAAKI,KAAO,GACtEC,eAAgBP,EAAQO,eACxBC,cAAeR,EAAQQ,cACvB7T,UAAWmI,EACXU,UAAWV,GAGb,aADM4I,EAAG+C,MAAMpC,IAAIhB,GACZA,CACT,CAEAvR,eAAe4U,kBAAkBT,GAE/B,aADM7C,UACQM,EAAG+C,MAAMhR,IAAIwQ,IAAe,IAC5C,CAEAnU,eAAe6U,kBAAkBV,SACzB7C,IAEN,eADoBM,EAAG+C,MAAMhR,IAAIwQ,GAEnC,CAEAnU,eAAe8U,qBAAqBX,SAC5B7C,UACAM,EAAG+C,MAAMlC,OAAO0B,EACxB,CAEAnU,eAAe+U,2BAA2BrV,SAClC4R,IACN,MAAMe,QAAiBT,EAAGpG,aAAa7H,IAAIjE,EAAMwM,eAC3CqF,EAAsB,CAC1BrF,cAAexM,EAAMwM,cACrB9L,OAAQV,EAAMU,OACd4U,WAAYtV,EAAMsV,YAAc3C,GAAU2C,WAC1CpI,SAAUlN,EAAMkN,UAAYyF,GAAUzF,UAAY,EAClD+E,KAAM,IAAMU,GAAUV,MAAQ,MAASjS,EAAMiS,MAAQ,KAGvD,aADMC,EAAGpG,aAAa+G,IAAIhB,GACnBA,CACT,CAEAvR,eAAeiV,gCAAgC7U,GAE7C,aADMkR,IACCM,EAAGpG,aAAa6H,MAAM,UAAUC,OAAOlT,GAAQ8R,SACxD,CAEAlS,eAAekV,6BAA6BxV,SACpC4R,IACN,MAAMC,EAA2B,CAC/B4D,MAAOzV,EAAMyV,MACb3V,QAASE,EAAMF,QACf4V,UAAW1V,EAAM0V,WAAajE,QAC9BkE,MAAO3V,EAAM2V,OAGf,aADMzD,EAAG0D,iBAAiB/C,IAAIhB,GACvBA,CACT,CAEAvR,eAAeuV,6BAA6BJ,EAAeK,SACnDlE,IACN,MAAMC,QAAYK,EAAG0D,iBAAiB3R,IAAIwR,GAC1C,IAAK5D,EAAK,OAAO,KACjB,GAAIiE,GAAMC,UAAW,OAAOlE,EAE5B,OADYJ,QAAUI,EAAI6D,UAChB7D,EAAI8D,MAAc,KACrB9D,CACT,CAeO,SAASmE,8BACd,MAAO,CACL7D,MAAO,CACLpO,OAAQ2N,oBACRzN,IAAKmO,iBACL6D,KAAM5D,mBACN1O,OAAQ8O,oBACRjL,OAAQsL,qBAEVU,MAAO,CACLzP,OAAQiP,oBACR/O,IAAKwP,iBACLyC,WAAYxC,yBACZ/P,OAAQmQ,oBACRtM,OAAQuM,qBAEVG,QAAS,CACP3M,IAAKyM,mBACLmC,WAAYhC,4BAEdc,MAAO,CACLpC,IAAK0B,kBACLtQ,IAAKiR,kBACLkB,IAAKjB,kBACL3N,OAAQ4N,sBAEVtJ,aAAc,CACZuK,OAAQhB,2BACRiB,WAAYf,iCAEdK,iBAAkB,CAChB5R,IAAKwR,6BACLvR,IAAK4R,8BAGX,CC9VO,MAAMU,EAAQP,8BCArB,SAASQ,OACP,IACE,MAAMC,EAAaC,WAAmBC,OACtC,GAAIF,GAA6C,mBAAzBA,EAAUG,WAChC,OAAOH,EAAUG,YAErB,OAAS,CAET,MAAO,MAAQxM,KAAKyM,SAASlK,SAAS,IAAI2H,MAAM,EAAG,GACrD,CAKO,SAASwC,uBAAuBnF,GACrC,MAAO,CACLG,OAAQ0E,OACR1Q,KAAM6L,EAAK3I,MACXX,YAAasJ,EAAKtJ,YAClB4J,KAAM,CACJvR,OAAQiR,EAAKjR,OACbqW,KAAMpF,EAAKoF,MAAQ,GACnBxO,SAAUoJ,EAAKpJ,UAAY,KAC3ByO,SAAUrF,EAAKqF,UAAY,KAC3BC,iBAAkBtF,EAAKsF,kBAAoB,KAC3CC,SAAUvF,EAAKuF,WAAY,GAGjC,CAMO,SAASC,uBAAuBnX,GAUrC,MACMoX,MADcC,IAAI,CAAC,MAAO,WAAY,SAAU,eAE5CjB,IAAIpW,EAAMmI,OACbnI,EAAMmI,MACP,MAEN,MAAO,CACL+K,OAAQsD,OACR1E,OAAQ9R,EAAM8R,OACdqB,OAAQ,CACNmE,MAAOtX,EAAMqQ,aACbkH,KAAMvX,EAAMsQ,aAGdE,WAAYxQ,EAAMwQ,WAAa,IAAI9N,IAAK8U,GAAMA,EAAE7W,IAAI4B,OAAOkV,SAC3DtP,MAAOiP,EACP9D,KAAMtT,EAAM0X,YAAc,IAC1BrE,SAAUrT,EAAM2X,cAAgB,EAChCvE,MAAO,KACPtC,OAAQ,EAEZ,CAKO,SAAS8G,qBAAqB5R,GACnC,MAAMvD,EAAqB,GACE,iBAAlBuD,EAAQgD,QAAoBvG,EAAOqD,KAAOE,EAAQgD,OAC1B,iBAAxBhD,EAAQqC,cAA0B5F,EAAO4F,YAAcrC,EAAQqC,aAC1E,MAAM4J,EAAgC,GAMtC,OALIjM,EAAQ+Q,OAAM9E,EAAK8E,KAAO/Q,EAAQ+Q,MAClC/Q,EAAQuC,WAAU0J,EAAK1J,SAAWvC,EAAQuC,UAC1CvC,EAAQgR,WAAU/E,EAAK+E,SAAWhR,EAAQgR,UAC1ChR,EAAQiR,mBAAkBhF,EAAKgF,iBAAmBjR,EAAQiR,kBAC1DpX,OAAOoG,KAAKgM,GAAM3T,WAAe2T,KAAOA,GACrCxP,CACT,CCvBA,MAAMoV,EAAoC,CACxCC,eAAgB,GAChBC,iBAAkB,IAClBC,UAAW,IACXC,iBAAkB,EAClBC,gBAAiB,MACjBC,gBAAiB,GAInB7X,eAAe8X,kBAAkBC,GAC/B,UACQ9B,EAAMpE,MAAMpO,OAAO+S,uBAAuBuB,GAClD,OAASC,GAEP1I,QAAQ/L,KAAK,qCAAsCyU,EACrD,CACF,CAEAhY,eAAeiY,eAAezG,EAAgBmB,GAC5C,UACQsD,EAAM/C,MAAMzP,OAChBoT,uBAAuB,CACrBrF,SACAzB,aAAc4C,EAAK5C,aACnBC,YAAa2C,EAAK3C,YAClBE,UAAWyC,EAAKzC,UAChBrI,MAAO8K,EAAK9K,MACZuP,WAAYzE,EAAKyE,WACjBC,aAAc1E,EAAK0E,eAGzB,OAASW,GACP1I,QAAQ/L,KAAK,kCAAmCyU,EAClD,CACF,CAGA,MAAME,kBAAqBC,GAClBA,EACJxY,QAAQ,WAAY,IACpBA,QAAQ,UAAW,KACnBA,QAAQ,QAAS,KACjBA,QAAQ,QAAS,KACjBA,QAAQ,SAAU,KAClBA,QAAQ,oBAAqB,IAC7B5B,OAICqa,2BAA8BC,IAClC,GAA4B,IAAxBA,EAAara,OACf,MAAO,CAAEsa,WAAY,EAAGC,UAAW,GAGrC,MAAMC,EAAaH,EAAa,GAAGra,OAC7Bya,EAAgF,GAGtF,QAASzB,EAAQ,EAAGA,EAAQwB,EAAYxB,IACtC,QAASC,EAAOD,EAAQ,EAAGC,EAAOuB,EAAYvB,IAAQ,CACpD,IAAI1N,EAAQ,EACRmP,EAAa,EAEjB,UAAW7F,KAAUwF,EAAc,CACjC,MAAMtI,EAAemI,kBAAkBrF,EAAOmE,IAAU,IAClDhH,EAAckI,kBAAkBrF,EAAOoE,IAAS,IAGlDlH,GAAgBC,IAClB0I,IAGI3I,EAAa/R,OAAS,GAAKgS,EAAYhS,OAAS,IAClDuL,GAAS,IAIPwG,IAAiBC,IACnBzG,GAAS,GAINwG,EAAa4I,MAAM,cAAiB3I,EAAY2I,MAAM,eACzDpP,GAAS,GAGNwG,EAAa4I,MAAM,UAAa3I,EAAY2I,MAAM,WACrDpP,GAAS,GAGf,CAGA,MAAMqP,EAAkBF,EAAa,EAAInP,EAAQmP,EAAa,EAC9DD,EAAazZ,KAAK,CAAEsZ,WAAYtB,EAAOuB,UAAWtB,EAAM1N,MAAOqP,GACjE,CAMF,OAFAH,EAAaI,KAAK,CAACC,EAAGC,IAAMA,EAAExP,MAAQuP,EAAEvP,OAEpCkP,EAAaza,OAAS,GAAKya,EAAa,GAAGlP,MAAQ,GACrD+F,QAAQnP,IAAI,2BAA2BsY,EAAa,GAAGH,iBAAiBG,EAAa,GAAGF,qBAAqBE,EAAa,GAAGlP,UACtH,CAAE+O,WAAYG,EAAa,GAAGH,WAAYC,UAAWE,EAAa,GAAGF,YAI1EC,GAAc,EACT,CAAEF,WAAY,EAAGC,UAAW,GAE9B,CAAED,WAAY,EAAGC,UAAW,IAI/BS,cAAgBhZ,MAAOiZ,IAC3B,IAEE,OAASC,QAASC,IAAWD,QAASE,UAAqBC,QAAQC,IAAI,CAAAC,EAAA,IACrEC,OAAO,4BAAOjT,KAAAkT,KAAAC,GAAAC,4BAAAJ,EAAA,IACdC,OAAO,4BAAQjT,KAAAkT,KAAAG,GAAAD,8BAIXE,QAAYT,EAAU,CAC1BU,WAAab,GACPA,EAAKc,SAAS,SACT,iBAEF,IAAId,MAKTe,QAAoBf,EAAKe,cAGzBC,EAAM,IAAId,EAIVe,SAHmBD,EAAIE,UAAUH,IAGbf,KAAK,oBAC/B,IAAKiB,EACH,MAAM,IAAItY,MAAM,kDAIlB,MAAMwY,QAAsBF,EAAOla,MAAM,eACnC4R,EAAK,IAAIiI,EAAIQ,SAAS,IAAIC,WAAWF,IAGrCG,EAAY3I,EAAG4I,KAAK,iCAC1B,IAAIC,EAAWxB,EAAKzT,KAAK7F,QAAQ,UAAW,IAC5C,GAAI4a,EAAUvc,OAAS,GAAKuc,EAAU,GAAGG,OAAO1c,OAAS,EACvD,IACE,MAAM2c,EAAYJ,EAAU,GAAGG,OAAO,GAAG,GACnC7I,EAAQ+I,KAAKC,MAAMF,GAEnBG,EAAUvb,OAAOoG,KAAKkM,GAAO5P,OAAO5B,GAAa,MAAPA,GAC5Cya,EAAQ9c,OAAS,IACnByc,EAAW5I,EAAMiJ,EAAQ,IAAItV,MAAQiV,EAEzC,OAAS/S,GACP4H,QAAQ/L,KAAK,6DACf,CAIF,MAAMwX,EAAanJ,EAAG4I,KAAK,qJAQrBtH,EAAgD,GAEtD,GAAI6H,EAAW/c,OAAS,EAAG,CAEzB,MAAMgd,EAAalR,KAAK5L,IAAI,GAAI6c,EAAW,GAAGL,OAAO1c,QAC/Cqa,EAA2B,GAEjC,QAAS4C,EAAI,EAAGA,EAAID,EAAYC,IAAK,CACnC,MAAMpI,EAAUkI,EAAW,GAAGL,OAAOO,GAAG,GAAc1a,MAAM,KAC5D8X,EAAarZ,KAAK6T,EACpB,CAGA,MAAMyF,WAAEA,EAAAC,UAAYA,GAAcH,2BAA2BC,GAC7D/I,QAAQnP,IAAI,4BAA4BmY,gBAAyBC,YAGjE,UAAWhH,KAAOwJ,EAAW,GAAGL,OAAQ,CACtC,MAAM7H,EAAUtB,EAAI,GAAchR,MAAM,KAExC,GAAIsS,EAAO7U,OAAS8L,KAAK1L,IAAIka,EAAYC,GAAY,CACnD,MAAMvB,EAAQkB,kBAAkBrF,EAAOyF,IAAe,IAChDrB,EAAOiB,kBAAkBrF,EAAO0F,IAAc,IAEhDvB,GAASC,GAAQD,IAAUC,GAC7B/D,EAAMlU,KAAK,CAAEgY,QAAOC,QAExB,CACF,CACF,CAIA,GAFArF,EAAGsJ,QAEkB,IAAjBhI,EAAMlV,OACR,MAAM,IAAI4D,MAAM,0CAIlB,OADA0N,QAAQnP,IAAI,uBAAuB+S,EAAMlV,gCAClC,CAAEwH,KAAMiV,EAAUvH,QAC3B,OAASxR,GAEP,MADA4N,QAAQ5N,MAAM,4BAA6BA,GACrC,IAAIE,MAAM,+BAA+BF,aAAiBE,MAAQF,EAAM9D,QAAU,kBAC1F,GAGWud,EAAe1X,IAC1BkD,EACE,CAACjD,EAAKC,KAAA,CACJkO,MAAO,GACPqB,MAAO,GACPkI,oBAAqB,KACrBrX,WAAW,EACXrC,MAAO,KACP2Z,eAAgB,EAChBC,aAAc,KAEdC,WAAYvb,MAAO+X,IACjBrU,EAAI,CAAEK,WAAW,EAAMrC,MAAO,OAC9B,IACE,MAAM2P,EAAa,IACd0G,EACH1X,GAAIgW,OAAOC,aACXzV,WAAA,IAAeE,MAAOC,cACtB0I,WAAA,IAAe3I,MAAOC,cACtB0V,SAAU,IAAKa,KAAwBQ,EAASrB,WAYlD,OATAhT,EAAImE,IAAA,CACFgK,MAAO,IAAIhK,EAAMgK,MAAOR,GACxB6B,MAAO,IAAKrL,EAAMqL,MAAO,CAAC7B,EAAKhR,IAAK,IACpC0D,WAAW,KAIR+T,kBAAkBC,GAEhB1G,CACT,OAAS3P,GAEP,MADAgC,EAAI,CAAEhC,MAAO,wBAAyBqC,WAAW,IAC3CrC,CACR,GAGF8Z,WAAYxb,MAAOK,EAAIqF,KACrBhC,EAAI,CAAEK,WAAW,EAAMrC,MAAO,OAC9B,IACEgC,EAAImE,IAAA,CACFgK,MAAOhK,EAAMgK,MAAMzP,IAAIiP,GACrBA,EAAKhR,KAAOA,EACR,IAAKgR,KAAS3L,EAASgE,eAAe3I,MAAOC,eAC7CqQ,GAENtN,WAAW,KAIb,IACOkS,EAAMpE,MAAMxO,OAAOhD,EAAIiX,qBAAqB5R,GACnD,OAASgC,GACP4H,QAAQ/L,KAAK,qCAAsCmE,EACrD,CACF,OAAShG,GAEP,MADAgC,EAAI,CAAEhC,MAAO,wBAAyBqC,WAAW,IAC3CrC,CACR,GAGF+Z,WAAYzb,MAAOK,IACjBqD,EAAI,CAAEK,WAAW,EAAMrC,MAAO,OAC9B,IACEgC,EAAImE,IAEF,MAAQxH,CAACA,GAAKqb,KAAkBC,GAAmB9T,EAAMqL,MACzD,MAAO,CACLrB,MAAOhK,EAAMgK,MAAM5P,OAAOoP,GAAQA,EAAKhR,KAAOA,GAC9C6S,MAAOyI,EACP5X,WAAW,KAIf,IACOkS,EAAMpE,MAAM3K,OAAO7G,EAC1B,OAASqH,GACP4H,QAAQ/L,KAAK,qCAAsCmE,EACrD,CACF,OAAShG,GAEP,MADAgC,EAAI,CAAEhC,MAAO,wBAAyBqC,WAAW,IAC3CrC,CACR,GAGFka,QAAUvb,GACDsD,IAAMkO,MAAM1F,KAAKkF,GAAQA,EAAKhR,KAAOA,GAG9Cwb,QAAS7b,MAAOwR,EAAQsK,KACtBpY,EAAI,CAAEK,WAAW,EAAMrC,MAAO,OAC9B,IACE,MAAMiR,EAAa,IACdmJ,EACHzb,GAAIgW,OAAOC,aACX9E,SACA3Q,WAAA,IAAeE,MAAOC,cACtBoW,WAAY,IACZC,aAAc,EACd0E,YAAA,IAAgBhb,MAAOC,cACvBgb,YAAa,EACbC,WAAY,GAqBd,OAlBAvY,EAAImE,IACF,MACMqU,EAAe,IADHrU,EAAMqL,MAAM1B,IAAW,GACLmB,GAEpC,MAAO,CACLO,MAAO,IAAKrL,EAAMqL,MAAO1B,CAACA,GAAS0K,GACnCrK,MAAOhK,EAAMgK,MAAMzP,OACjBiP,EAAKhR,KAAOmR,EACR,IAAKH,EAAMI,UAAWyK,EAAale,OAAQ0L,eAAe3I,MAAOC,eACjEqQ,GAENtN,WAAW,KAKVkU,eAAezG,EAAQmB,GAErBA,CACT,OAASjR,GAEP,MADAgC,EAAI,CAAEhC,MAAO,qBAAsBqC,WAAW,IACxCrC,CACR,GAGFya,YAAanc,MAAOwR,EAAQsK,KAC1B,IACE,MACMM,EADQzY,IACcuP,MAAM1B,IAAW,GAGvC6K,EAAU,GAAGP,EAAS/L,aAAahS,OAAOue,iBAAiBR,EAAS9L,YAAYjS,OAAOue,gBAK7F,GAJoBF,EAAc1d,KAAKiU,GACrC,GAAGA,EAAK5C,aAAahS,OAAOue,iBAAiB3J,EAAK3C,YAAYjS,OAAOue,kBAAoBD,GAMzF,OAFA/M,QAAQnP,IAAI,2BAA4B2b,EAAS/L,cAE1C,IACF+L,EACHzb,GAAI,oBACJmR,SACA3Q,WAAA,IAAeE,MAAOC,cACtBoW,WAAY,IACZC,aAAc,EACd0E,YAAA,IAAgBhb,MAAOC,cACvBgb,YAAa,EACbC,WAAY,GAIhB,MAAMtJ,EAAa,IACdmJ,EACHzb,GAAIgW,OAAOC,aACX9E,SACA3Q,WAAA,IAAeE,MAAOC,cACtBoW,WAAY,IACZC,aAAc,EACd0E,YAAA,IAAgBhb,MAAOC,cACvBgb,YAAa,EACbC,WAAY,GAsBd,OAnBAvY,EAAImE,IACF,MACMqU,EAAe,IADHrU,EAAMqL,MAAM1B,IAAW,GACLmB,GAEpC,MAAO,CACLO,MAAO,IAAKrL,EAAMqL,MAAO1B,CAACA,GAAS0K,GACnCrK,MAAOhK,EAAMgK,MAAMzP,OACjBiP,EAAKhR,KAAOmR,EACR,IAAKH,EAAMI,UAAWyK,EAAale,OAAQ0L,eAAe3I,MAAOC,eACjEqQ,MAMM,sBAAZsB,EAAKtS,IACF4X,eAAezG,EAAQmB,GAGvBA,CACT,OAASjR,GAEP,MADA4N,QAAQ5N,MAAM,yCAA0CA,GAClDA,CACR,GAGF6a,eAAgBvc,MAAO+X,IACrB,IACE,MAAM1G,EAAa,IACd0G,EACH1X,GAAIgW,OAAOC,aACXzV,WAAA,IAAeE,MAAOC,cACtB0I,WAAA,IAAe3I,MAAOC,cACtB0V,SAAU,IAAKa,KAAwBQ,EAASrB,WAWlD,OARAhT,EAAImE,IAAA,CACFgK,MAAO,IAAIhK,EAAMgK,MAAOR,GACxB6B,MAAO,IAAKrL,EAAMqL,MAAO,CAAC7B,EAAKhR,IAAK,OAIjCyX,kBAAkBC,GAEhB1G,CACT,OAAS3P,GAEP,MADA4N,QAAQ5N,MAAM,4CAA6CA,GACrDA,CACR,GAGF8a,cAAexc,MAAOwR,EAAQiL,KAC5B,IACE,MACML,EADQzY,IACcuP,MAAM1B,IAAW,GAGvCkL,EAAkB,IAAI3F,IAC1BqF,EAAcha,IAAIuQ,GAAQ,GAAGA,EAAK5C,aAAahS,OAAOue,iBAAiB3J,EAAK3C,YAAYjS,OAAOue,kBAI3FK,EAAkBF,EAAUxa,OAAO6Z,IACvC,MAAMO,EAAU,GAAGP,EAAS/L,aAAahS,OAAOue,iBAAiBR,EAAS9L,YAAYjS,OAAOue,gBAC7F,OAAQI,EAAgB5G,IAAIuG,KAK9B,GAFA/M,QAAQnP,IAAI,qBAAqBsc,EAAUze,2BAA2B2e,EAAgB3e,8BAEvD,IAA3B2e,EAAgB3e,OAElB,OADAsR,QAAQnP,IAAI,4CACL,GAGT,MAAM+S,EAAgByJ,EAAgBva,IAAI0Z,IAAA,IACrCA,EACHzb,GAAIgW,OAAOC,aACX9E,SACA3Q,WAAA,IAAeE,MAAOC,cACtBoW,WAAY,IACZC,aAAc,EACd0E,YAAA,IAAgBhb,MAAOC,cACvBgb,YAAa,EACbC,WAAY,KAGdvY,EAAImE,IACF,MACMqU,EAAe,IADHrU,EAAMqL,MAAM1B,IAAW,MACF0B,GAEvC,MAAO,CACLA,MAAO,IAAKrL,EAAMqL,MAAO1B,CAACA,GAAS0K,GACnCrK,MAAOhK,EAAMgK,MAAMzP,OACjBiP,EAAKhR,KAAOmR,EACR,IAAKH,EAAMI,UAAWyK,EAAale,OAAQ0L,eAAe3I,MAAOC,eACjEqQ,MAMV,UAAWhE,KAAK6F,EACT+E,eAAezG,EAAQnE,GAG9B,OAAO6F,CACT,OAASxR,GAEP,MADA4N,QAAQ5N,MAAM,2CAA4CA,GACpDA,CACR,GAGFkb,WAAY5c,MAAO4S,EAAQlN,KACzBhC,EAAI,CAAEK,WAAW,EAAMrC,MAAO,OAC9B,IACEgC,EAAImE,IACF,MAAMgV,EAAW,IAAKhV,EAAMqL,OAC5B,UAAW1B,KAAUqL,EACnBA,EAASrL,GAAUqL,EAASrL,GAAQpP,IAAIuQ,GACtCA,EAAKtS,KAAOuS,EAAS,IAAKD,KAASjN,GAAYiN,GAGnD,MAAO,CAAEO,MAAO2J,EAAU9Y,WAAW,IAEzC,OAASrC,GAEP,MADAgC,EAAI,CAAEhC,MAAO,wBAAyBqC,WAAW,IAC3CrC,CACR,GAGFob,WAAY9c,MAAO4S,IACjBlP,EAAI,CAAEK,WAAW,EAAMrC,MAAO,OAC9B,IACE,IAAIqb,EAAiB,GACrBrZ,EAAImE,IACF,MAAMgV,EAAW,IAAKhV,EAAMqL,OAC5B,UAAW1B,KAAUqL,EAAU,CAE7B,IAAkB,IADAA,EAASrL,GAAQwL,UAAUrK,GAAQA,EAAKtS,KAAOuS,GAC3C,CACpBiK,EAASrL,GAAUqL,EAASrL,GAAQvP,OAAO0Q,GAAQA,EAAKtS,KAAOuS,GAC/DmK,EAAiBvL,EACjB,KACF,CACF,CAEA,MAAO,CACL0B,MAAO2J,EACPhL,MAAOhK,EAAMgK,MAAMzP,OACjBiP,EAAKhR,KAAO0c,EACR,IAAK1L,EAAMI,UAAWoL,EAASE,GAAgB/e,OAAQ0L,WAAA,IAAe3I,MAAOC,eAC7EqQ,GAENtN,WAAW,KAIf,IACOkS,EAAM/C,MAAMhM,OAAO0L,EAC1B,OAASlL,GACP4H,QAAQ/L,KAAK,qCAAsCmE,EACrD,CACF,OAAShG,GAEP,MADAgC,EAAI,CAAEhC,MAAO,wBAAyBqC,WAAW,IAC3CrC,CACR,GAGFub,SAAWzL,GACF7N,IAAMuP,MAAM1B,IAAW,GAGhC0L,eAAgBld,MAAOiZ,IACrB,MAAMkE,kBAAEA,EAAAC,oBAAmBA,GAAwBzZ,IACnDD,EAAI,CAAEK,WAAW,EAAMrC,MAAO,OAC9B0b,IAEA,IACE,MAAMC,EAAWpE,EAAKzT,KAAK8W,cAG3B,GAAIe,EAAStD,SAAS,SAAU,CAC9BoD,EAAkB,GAAI,mBAGtB,MAAM3X,KAAEA,EAAA0N,MAAMA,SAAgB8F,cAAcC,GAI5C,GADqBtV,IAAMkO,MAAM1F,KAAKmR,GAAKA,EAAE5U,QAAUlD,GAErD,MAAM,IAAI5D,MAAM,iBAAiB4D,2EAGnC2X,EAAkB,GAAI,oBAGtB,MAAM9L,QAAa1N,IAAM4Y,eAAe,CACtCnc,OAAQ,eACRsI,MAAOlD,EACPuC,YAAa,2BAA2BmL,EAAMlV,eAC9CyT,UAAW,EACXmF,UAAU,EACVF,SAAUa,EACVtP,SAAU,aAGZkV,EAAkB,GAAI,aAAajK,EAAMlV,mBAGzC,MAAMuf,EAA4B,GAC5BC,MAAgBzG,IAEtB,UAAWpE,KAAQO,EAAO,CACxB,MAAMmJ,EAAU,GAAG1J,EAAKqE,MAAMjZ,OAAOue,iBAAiB3J,EAAKsE,KAAKlZ,OAAOue,gBAClEkB,EAAU1H,IAAIuG,KACjBmB,EAAUvW,IAAIoV,GACdkB,EAAYve,KAAK2T,GAErB,CAEArD,QAAQnP,IAAI,WAAW+S,EAAMlV,OAASuf,EAAYvf,iDAAiDuf,EAAYvf,wBAG/G,MAAMyf,EAAY,IAClB,IAAIC,EAAoB,EACxB,MAAMtT,EAAamT,EAAYvf,OAE/BsR,QAAQnP,IAAI,4BAA4BiK,kBAExC,QAAS6Q,EAAI,EAAGA,EAAI7Q,EAAY6Q,GAAKwC,EAAW,CAC9C,MAAME,EAAQJ,EAAYvJ,MAAMiH,EAAGA,EAAIwC,GACjCG,EAAaD,EAAMvb,IAAI0Z,GAAYhM,cACvCgM,EAAS9E,MACT8E,EAAS7E,KACT,CAAE9O,KAAM,SACR,KAGF,IACEmH,QAAQnP,IAAI,oBAAoB2J,KAAKC,MAAMkR,EAAIwC,GAAa,KAAK3T,KAAK+T,KAAKzT,EAAaqT,OAAeE,EAAM3f,uBACvG2F,IAAM6Y,cAAcnL,EAAKhR,GAAIud,GACnCF,GAAqBC,EAAM3f,OAG3B,MAAM8f,EAAe,GAAM,GAAKhU,KAAK5L,IAAI+c,EAAIwC,EAAWrT,GAAcA,EACtE+S,EAAkBW,EAAc,YAAYJ,KAAqBtT,cAEjEkF,QAAQnP,IAAI,8BAA8B2d,EAAaC,QAAQ,aAGzD,IAAI1E,QAAQ2E,GAAWxZ,WAAWwZ,EAAS,IACnD,OAASC,GACP3O,QAAQ5N,MAAM,0BAA2Buc,GAEzC,UAAWC,KAAgBP,EACzB,UACQha,IAAMwY,YAAY9K,EAAKhR,GAAIyP,cAC/BoO,EAAalH,MACbkH,EAAajH,KACb,CAAE9O,KAAM,SACR,KAEFuV,GACF,OAASS,GACP7O,QAAQ/L,KAAK,oCAAqC2a,EAAcC,EAClE,CAKFhB,EADqB,GAAM,GAAKrT,KAAK5L,IAAI+c,EAAIwC,EAAWrT,GAAcA,EACtC,YAAYsT,KAAqBtT,aACnE,CACF,CAmBA,OAjBAkF,QAAQnP,IAAI,6CAA6Cud,KAEzDP,EAAkB,GAAI,8BAGhBxZ,IAAM6X,WAAWnK,EAAKhR,GAAI,CAC9B0H,YAAa,2BAA2B2V,YAG1CP,EAAkB,IAAK,qBAGvB3Y,WAAW,KACT4Y,KACC,KAEH1Z,EAAI,CAAEK,WAAW,IACVsN,CACT,IAAWgM,EAAStD,SAAS,SAAWsD,EAAStD,SAAS,SAAWsD,EAAStD,SAAS,QAAS,CAC9FoD,EAAkB,GAAI,wBAGtB,MAAMiB,QAAanF,EAAKmF,OAGxB,IAAIC,EAAY,KACZhB,EAAStD,SAAS,UACpBsE,EAAY,KAGdlB,EAAkB,GAAI,8BAGtB,MAAMmB,EAAYF,EACfze,QAAQ,QAAS,MACjBA,QAAQ,MAAO,MACf5B,OAEGsT,QAAa1N,IAAM4a,eACvBtF,EAAKzT,KAAK7F,QAAQ,YAAa,IAC/B2e,EACAD,GAGF,OADA3a,EAAI,CAAEK,WAAW,IACVsN,CACT,CAAO,CACL8L,EAAkB,GAAI,2BAGtB,MAAMiB,QAAanF,EAAKmF,OAExBjB,EAAkB,GAAI,yBAEtB,MAAMmB,EAAYF,EACfze,QAAQ,QAAS,MACjBA,QAAQ,MAAO,MACf5B,OAEGsT,QAAa1N,IAAM4a,eACvBtF,EAAKzT,KAAK7F,QAAQ,YAAa,IAC/B2e,EACA,MAGF,OADA5a,EAAI,CAAEK,WAAW,IACVsN,CACT,CACF,OAAS3P,GACP,MAAMsD,EAAetD,aAAiBE,MAAQF,EAAM9D,QAAU,6BAG9D,MAFA8F,EAAI,CAAEhC,MAAOsD,EAAcjB,WAAW,IACtCqZ,IACM1b,CACR,GAGF6c,eAAgBve,MAAOya,EAAU2D,EAAMC,EAAY,QACjD,MAAMlB,kBAAEA,EAAAC,oBAAmBA,GAAwBzZ,IACnDD,EAAI,CAAEK,WAAW,EAAMrC,MAAO,OAE9B,IACEyb,EAAkB,GAAI,8BAGtB,MAOMqB,EAPYJ,EACfze,QAAQ,QAAS,MACjBA,QAAQ,MAAO,MACfA,QAAQ,WAAY,IACpBA,QAAQ,yDAA0D,IAClE5B,OAGAwC,MAAM,MACN6B,IAAIqc,GAAQA,EAAK1gB,QACjBkE,OAAOwc,GAAQA,EAAKzgB,OAAS,GAEhC,GAAqB,IAAjBwgB,EAAMxgB,OACR,MAAM,IAAI4D,MAAM,sCAGlBub,EAAkB,GAAI,oBAEtB,MAAM9L,QAAa1N,IAAM4Y,eAAe,CACtCnc,OAAQ,eACRsI,MAAO+R,EACP1S,YAAa,sBAAsByW,EAAMxgB,eACzCyT,UAAW,EACXmF,UAAU,EACVF,SAAUa,EACVtP,SAAU,aAGZkV,EAAkB,GAAI,aAAaqB,EAAMxgB,mBAGzC,MAAM0gB,EAA6I,GACnJ,IAAIC,EAAe,EAGnB,QAAS1D,EAAI,EAAGA,EAAIuD,EAAMxgB,OAAQid,IAAK,CACrC,MAAMwD,EAAOD,EAAMvD,GACnB,IAEE,IAAI2D,EAUJ,GAPEA,EAFgB,MAAdP,GAAqBI,EAAK/b,SAAS,KAE7B+b,EAAKle,MAAM,KAAK6B,OACtByc,EAAKlf,QAAQ,WAAY,MAAM5B,QAGzB0gB,EAAKle,MAAM8d,GAGjBO,EAAM5gB,QAAU,EAAG,CACrB,MAAMgZ,EAAQ4H,EAAM,GAAG7gB,OACjBkZ,EAAO2H,EAAM,GAAG7gB,OAGlBiZ,GAASC,EACXyH,EAAW1f,KAAK8Q,cACdkH,EACAC,EACA,CAAE9O,KAAM,SACR,KAGFwW,GAEJ,MACEA,GAEJ,OAASV,GACP3O,QAAQ/L,KAAK,wBAAyBkb,EAAMR,GAC5CU,GACF,CACF,CAGA,MAAMG,EAAsC,GACtCtB,MAAgBzG,IAEtB,UAAWpE,KAAQ+L,EAAY,CAC7B,MAAMrC,EAAU,GAAG1J,EAAK5C,aAAahS,OAAOue,iBAAiB3J,EAAK3C,YAAYjS,OAAOue,gBAChFkB,EAAU1H,IAAIuG,KACjBmB,EAAUvW,IAAIoV,GACdyC,EAAiB9f,KAAK2T,GAE1B,CAEArD,QAAQnP,IAAI,WAAWue,EAAW1gB,OAAS8gB,EAAiB9gB,mDAAmD8gB,EAAiB9gB,wBAGhI,MAAMyf,EAAY,IAClB,IAAIC,EAAoB,EAExBpO,QAAQnP,IAAI,4CAA4C2e,EAAiB9gB,uBAEzE,QAASid,EAAI,EAAGA,EAAI6D,EAAiB9gB,OAAQid,GAAKwC,EAAW,CAC3D,MAAME,EAAQmB,EAAiB9K,MAAMiH,EAAGA,EAAIwC,GAE5C,IACEnO,QAAQnP,IAAI,yBAAyB2J,KAAKC,MAAMkR,EAAIwC,GAAa,KAAK3T,KAAK+T,KAAKiB,EAAiB9gB,OAASyf,OAAeE,EAAM3f,iBAC/H,MAAM+gB,QAAmBpb,IAAM6Y,cAAcnL,EAAKhR,GAAIsd,GACtDD,GAAqBqB,EAAW/gB,OAGhC,MAAM8f,EAAe,GAAM,GAAKhU,KAAK5L,IAAI+c,EAAIwC,EAAWqB,EAAiB9gB,QAAU8gB,EAAiB9gB,OACpGmf,EAAkBW,EAAc,YAAYJ,KAAqBoB,EAAiB9gB,mBAElFsR,QAAQnP,IAAI,mCAAmC2d,EAAaC,QAAQ,eAAegB,EAAW/gB,sBAGxF,IAAIqb,QAAQ2E,GAAWxZ,WAAWwZ,EAAS,IACnD,OAASC,GACP3O,QAAQ5N,MAAM,+BAAgCuc,GAE9C,UAAWnC,KAAY6B,EACrB,IAEuB,6BADGha,IAAMwY,YAAY9K,EAAKhR,GAAIyb,IACrCzb,IACZqd,GAEJ,OAASS,GACP7O,QAAQ/L,KAAK,yCAA0CuY,EAAUqC,EACnE,CAKFhB,EADqB,GAAM,GAAKrT,KAAK5L,IAAI+c,EAAIwC,EAAWqB,EAAiB9gB,QAAU8gB,EAAiB9gB,OACpE,YAAY0f,KAAqBoB,EAAiB9gB,kBACpF,CACF,CAWA,GATAsR,QAAQnP,IAAI,6DAA6Dud,KAEzEP,EAAkB,GAAI,8BAGhBxZ,IAAM6X,WAAWnK,EAAKhR,GAAI,CAC9B0H,YAAa,sBAAsB2V,UAA0BiB,EAAe,EAAI,KAAKA,mBAAgC,OAG7F,IAAtBjB,EACF,MAAM,IAAI9b,MAAM,mEAWlB,OARAub,EAAkB,IAAK,qBAGvB3Y,WAAW,KACT4Y,KACC,KAEH1Z,EAAI,CAAEK,WAAW,IACVsN,CACT,OAAS3P,GAGP,MAFAgC,EAAI,CAAEhC,MAAO,6BAA8BqC,WAAW,IACtDqZ,IACM1b,CACR,GAGFsd,iBAAkBhf,UAChB0D,EAAI,CAAEK,WAAW,EAAMrC,MAAO,OAC9B,IACE,MAAMmG,EAAQlE,IAGRsb,EAAiB,IAAIlI,IAAIlP,EAAMgK,MAAMzP,IAAIiP,GAAQA,EAAK3I,QAI5D,GAHsB,CAAC,qBAAsB,sBAAuB,kBAGlDhK,KAAKgK,GAASuW,EAAenJ,IAAIpN,IAGjD,OAFA4G,QAAQnP,IAAI,mDACZuD,EAAI,CAAEK,WAAW,IAInB,MAAMmb,EAAe,CACnB,CACExW,MAAO,qBACPX,YAAa,wCACbE,SAAU,WACViL,MAAO,CACL,CAAE8D,MAAO,QAASC,KAAM,QACxB,CAAED,MAAO,UAAWC,KAAM,SAC1B,CAAED,MAAO,YAAaC,KAAM,WAC5B,CAAED,MAAO,SAAUC,KAAM,aACzB,CAAED,MAAO,MAAOC,KAAM,MACtB,CAAED,MAAO,KAAMC,KAAM,MACrB,CAAED,MAAO,QAASC,KAAM,QACxB,CAAED,MAAO,OAAQC,KAAM,UACvB,CAAED,MAAO,QAASC,KAAM,QACxB,CAAED,MAAO,MAAOC,KAAM,WAG1B,CACEvO,MAAO,sBACPX,YAAa,4CACbE,SAAU,cACViL,MAAO,CACL,CAAE8D,MAAO,qBAAsBC,KAAM,mIACrC,CAAED,MAAO,oBAAqBC,KAAM,+FACpC,CAAED,MAAO,8CAA+CC,KAAM,qGAC9D,CAAED,MAAO,qBAAsBC,KAAM,wGACrC,CAAED,MAAO,uBAAwBC,KAAM,yHAG3C,CACEvO,MAAO,iBACPX,YAAa,+CACbE,SAAU,YACViL,MAAO,CACL,CAAE8D,MAAO,SAAUC,KAAM,SACzB,CAAED,MAAO,UAAWC,KAAM,UAC1B,CAAED,MAAO,QAASC,KAAM,QACxB,CAAED,MAAO,QAASC,KAAM,UACxB,CAAED,MAAO,iBAAkBC,KAAM,UACjC,CAAED,MAAO,QAASC,KAAM,SACxB,CAAED,MAAO,QAASC,KAAM,WACxB,CAAED,MAAO,YAAaC,KAAM,YAC5B,CAAED,MAAO,SAAUC,KAAM,YACzB,CAAED,MAAO,SAAUC,KAAM,aAK/B3H,QAAQnP,IAAI,4BACZ,UAAW4X,KAAYmH,EAAc,CACnC,MAAM7N,QAAa1N,IAAM4X,WAAW,CAClCnb,OAAQ,eACRsI,MAAOqP,EAASrP,MAChBX,YAAagQ,EAAShQ,YACtB0J,UAAW,EACXmF,UAAU,EACVF,SAAUa,EACVtP,SAAU8P,EAAS9P,SACnBwO,KAAM,CAACsB,EAAS9P,YAGlB,UAAW6T,KAAY/D,EAAS7E,YACxBvP,IAAMkY,QAAQxK,EAAKhR,GAAIyP,cAC3BgM,EAAS9E,MACT8E,EAAS7E,KACT,CAAE9O,KAAM,SACR,IAGN,CAEAmH,QAAQnP,IAAI,qCACZuD,EAAI,CAAEK,WAAW,GACnB,OAASrC,GAEP,MADAgC,EAAI,CAAEhC,MAAO,+BAAgCqC,WAAW,IAClDrC,CACR,GAGFmE,WAAY,IAAMnC,EAAI,CAAEhC,MAAO,OAC/Byd,WAAaC,GAAY1b,EAAI,CAAEK,UAAWqb,IAC1CC,qBAAsBrf,MAAOwR,IAC3B,IACE,MACM8N,EADQ3b,IACUuP,MAAM1B,IAAW,GAEzC,GAAyB,IAArB8N,EAAUthB,OACZ,OAAO,EAIT,MAAMuhB,MAAqBC,IAC3B,IAAIC,EAAoB,EAExB,UAAW9M,KAAQ2M,EAAW,CAC5B,MAAMjD,EAAU,GAAG1J,EAAK5C,aAAahS,OAAOue,iBAAiB3J,EAAK3C,YAAYjS,OAAOue,gBAEhFiD,EAAezJ,IAAIuG,IAGtBoD,IACAnQ,QAAQnP,IAAI,4BAA4BwS,EAAK5C,iBAH7CwP,EAAe7b,IAAI2Y,EAAS1J,EAKhC,CAEA,MAAM4K,EAAcmC,MAAMC,KAAKJ,EAAe7E,UAe9C,OAbI+E,EAAoB,IACtB/b,EAAImE,KACFqL,MAAO,IAAKrL,EAAMqL,MAAO1B,CAACA,GAAS+L,GACnC1L,MAAOhK,EAAMgK,MAAMzP,OACjBiP,EAAKhR,KAAOmR,EACR,IAAKH,EAAMI,UAAW8L,EAAYvf,OAAQ0L,eAAe3I,MAAOC,eAChEqQ,MAIR/B,QAAQnP,IAAI,WAAWsf,gCAAgDlC,EAAYvf,mCAG9EyhB,CACT,OAAS/d,GAEP,MADA4N,QAAQ5N,MAAM,oCAAqCA,GAC7CA,CACR,GAGFyb,kBAAmB,CAACvQ,EAAUgT,IAAWlc,EAAI,CAAE2X,eAAgBzO,EAAU0O,aAAcsE,IACvFxC,oBAAqB,IAAM1Z,EAAI,CAAE2X,eAAgB,EAAGC,aAAc,OAG5DuE,kBAAmB,CAACrO,EAAQsO,KAChC,MAAMC,EAAeD,EAAW1d,IAAIiL,GAAKA,EAAEhN,IAC3CqD,EAAI,CACF0X,oBAAqB,CACnB5J,SACAwO,iBAAkB,EAClBF,aACAC,eACAE,aAAc,CACZC,MAAOJ,EAAW9hB,OAClBmiB,QAAS,EACTC,UAAW,GAEbC,WAAA,IAAetf,MAAOC,kBAK5Bsf,mBAAoB,CAACN,EAAkBC,KACrCvc,EAAImE,IAAA,CACFuT,oBAAqBvT,EAAMuT,oBAAsB,IAC5CvT,EAAMuT,oBACT4E,mBACAC,gBACE,SAIRM,kBAAmB,KACjB7c,EAAI,CAAE0X,oBAAqB,QAG7BoF,gBAAkBhP,IAChB,MAAM3J,EAAQlE,IACd,OAAOkE,EAAMuT,qBAAqB5J,SAAWA,EAAS3J,EAAMuT,oBAAsB,MAGpFqF,kBAAmB,KAEjB/c,EAAImE,IAEF,MAAM6Y,EAAqC,GAE3C,UAAYlP,EAAQ0B,KAAU3T,OAAOC,QAAQqI,EAAMqL,OACjDwN,EAAWlP,GAAU0B,EAAM9Q,IAAIuQ,IAAA,IAC1BA,EACHyE,WAAY,IACZC,aAAc,EACd0E,YAAA,IAAgBhb,MAAOC,cACvBgb,YAAa,EACbC,WAAY,KAIhB,MAAO,CACL/I,MAAOwN,EACPtF,oBAAqB,WAK7B,CACE5V,KAAM,eAENoC,WAAaC,IAGX,MAAMqL,MAAEA,EAAAkI,oBAAOA,KAAwBuF,GAAgB9Y,EAcvD,MAAO,IAAK8Y,EAAavF,oBAZAA,EACrB,CACE5J,OAAQ4J,EAAoB5J,OAC5BwO,iBAAkB5E,EAAoB4E,iBACtCD,aAAc3E,EAAoB2E,aAClCE,aAAc7E,EAAoB6E,aAClCI,UAAWjF,EAAoBiF,WAEjC,UAUCO,eAAiB,KAC5B,MAAMC,EAAQ1F,IACRtX,EAAUgd,EAAMzF,oBAEtB,IAAKvX,IAAYA,EAAQkc,cAAgD,IAAhClc,EAAQkc,aAAa/hB,OAC5D,OAAO,KAGT,MAAM8iB,EAAgBjd,EAAQkc,aAAalc,EAAQmc,kBACnD,IAAKc,EACH,OAAO,KAKT,OADkBD,EAAM3N,MAAMrP,EAAQ2N,SAAW,IAChCrF,KAAKwG,GAAQA,EAAKtS,KAAOygB,IAAkB","names":["validationRules","required","message","test","value","trim","length","minLength","min","maxLength","max","email","password","username","noXSS","noSQLInjection","some","pattern","validateField","rules","errors","rule","push","isValid","validateForm","data","results","field","fieldRules","Object","entries","sanitizeInput","input","replace","validationSchemas","signUp","signIn","convertPocketbaseUser","async","pocketbaseUser","debugLogger","log","userId","id","convertedUser","split","level","totalXp","total_xp","coins","gems","createdAt","created","Date","toISOString","lastActive","last_active","preferences","theme","language","notifications","soundEffects","dailyGoal","timezone","error","stack","Error","fallbackUser","validateSignUpInputs","validationResults","validationErrors","filter","_","result","map","join","validateSignInInputs","createPocketBaseUserData","passwordConfirm","handleSignUpError","includes","handleSignInError","isDemoLogin","undefined","performPocketBaseAuth","sanitizedEmail","pb","collection","authWithPassword","emailError","updateUserLastActive","update","updateError","warn","useAuthStore","create","set","get","user","session","isAuthenticated","isLoading","passwordLength","userData","newUser","authData","record","hasToken","token","timeoutId","setTimeout","hasRecord","clearTimeout","signOut","authStore","clear","resetPassword","requestPasswordReset","errorMessage","updatePassword","newPassword","currentState","hasUser","hasSession","errorType","constructor","name","updateProfile","updates","keys","updateData","clearError","initializeAuth","model","info","login","register","logout","updateUser","onChange","timestamp","then","setState","catch","useThemeStore","persist","systemTheme","setTheme","document","documentElement","classList","add","remove","toggleTheme","newTheme","initializeTheme","window","matchMedia","matches","addEventListener","e","newSystemTheme","partialize","state","mockAchievements","description","icon","category","requirements","type","operator","xpReward","coinReward","isSecret","rarity","mockChallenges","title","target","rewards","amount","startDate","endDate","now","isActive","participantCount","itemId","mockLeaderboards","xp_weekly","period","score","rank","change","updatedAt","streak_all_time","calculateLevel","xp","Math","floor","sqrt","calculateXPToNextLevel","pow","getInitialUserStats","totalCards","cardsStudiedToday","cardsStudiedThisWeek","cardsStudiedThisMonth","averageAccuracy","totalStudyTime","studyTimeToday","studyTimeThisWeek","decksCreated","decksCompleted","longestStreak","currentStreak","gold","diamonds","xpToNextLevel","getDemoUserStats","useGamificationStore","userStats","isFirstTimeUser","isInitialized","achievements","userAchievements","userStreak","activeChallenges","userChallengeParticipations","leaderboards","updateUserStats","stats","newStats","addUserAchievement","achievementId","find","ua","toString","earnedAt","updateStreak","streak","joinChallenge","challengeId","p","progress","completed","joinedAt","milestoneProgress","weeklyProgress","bestWeek","updateChallengeProgress","claimChallengeReward","challenge","c","participation","xpGained","_coinsGained","forEach","reward","initializeMockData","lastStudyDate","freezeCount","cards_studied_today","completedAt","milestone_1","cards_studied_week","milestone_2","week","storyUnlocked","initializeNewUser","resetAllUserData","addCurrency","spendCurrency","initializeUserData","isDemo","updateMilestoneProgress","milestoneId","updateWeeklyProgress","weekData","w","updateChallengeStreak","unlockStoryChapter","claimMilestoneReward","contributeToCommunityGoal","goalId","contribution","console","awardStudyXP","cardsStudied","correctAnswers","milestoneBonus","newXP","newLevel","newXPToNextLevel","createNewCard","frontContent","backContent","cardType","mediaRefs","queue","due","ivl","factor","reps","lapses","left","learningStep","graduationInterval","easyInterval","averageAnswerTime","flags","originalDue","originalDeck","xpAwarded","difficultyRating","nowTs","createDeckIndexedDB","deck","ensureDBOpen","row","deckId","cardCount","mediaCount","meta","db","decks","getDeckIndexedDB","listDecksIndexedDB","orderBy","reverse","toArray","updateDeckIndexedDB","patch","existing","updated","put","removeDeckIndexedDB","delete","createCardIndexedDB","card","cardId","fields","dueAt","interval","ease","transaction","cards","getCardIndexedDB","listCardsByDeckIndexedDB","where","equals","sortBy","updateCardIndexedDB","removeCardIndexedDB","addReviewIndexedDB","review","reviews","listReviewsByCardIndexedDB","limit","arr","slice","putMediaIndexedDB","options","mediaHash","blob","opfsPointer","mimeType","byteLength","size","validationMeta","securityFlags","media","getMediaIndexedDB","hasMediaIndexedDB","removeMediaIndexedDB","upsertAchievementIndexedDB","unlockedAt","listAchievementsByUserIndexedDB","setLeaderboardCacheIndexedDB","scope","fetchedAt","ttlMs","leaderboardCache","getLeaderboardCacheIndexedDB","opts","ignoreTTL","createIndexedDBRepositories","list","listByDeck","listByCard","has","upsert","listByUser","repos","uuid","anyCrypto","globalThis","crypto","randomUUID","random","buildNewDeckFromDomain","tags","settings","advancedSettings","isPublic","buildNewCardFromDomain","normalizedState","Set","front","back","m","Boolean","easeFactor","intervalDays","mapDeckUpdatesToRepo","defaultDeckSettings","newCardsPerDay","maxReviewsPerDay","easyBonus","intervalModifier","maximumInterval","minimumInterval","persistCreateDeck","deckData","err","persistAddCard","cleanFieldContent","content","detectBestFieldCombination","sampleFields","frontIndex","backIndex","fieldCount","combinations","validPairs","match","normalizedScore","sort","a","b","parseApkgFile","file","default","JSZip","initSqlJs","Promise","all","__vitePreload","import","n","j","__VITE_PRELOAD__","s","SQL","locateFile","endsWith","arrayBuffer","zip","dbFile","loadAsync","dbArrayBuffer","Database","Uint8Array","deckQuery","exec","deckName","values","decksJson","JSON","parse","deckIds","notesQuery","sampleSize","i","close","useDeckStore","currentStudySession","importProgress","importStatus","createDeck","updateDeck","deleteDeck","_deletedCards","remainingCards","getDeck","addCard","cardData","nextReview","reviewCount","lapseCount","updatedCards","addCardBulk","existingCards","cardKey","toLowerCase","createDeckBulk","addCardsBatch","cardsData","existingCardSet","uniqueCardsData","updateCard","newCards","deleteCard","affectedDeckId","findIndex","getCards","importAnkiDeck","setImportProgress","resetImportProgress","fileName","d","uniqueCards","seenCards","batchSize","successfulImports","batch","batchCards","ceil","cardProgress","toFixed","resolve","cardError","originalCard","individualError","text","separator","cleanText","importFromText","lines","line","validCards","skippedLines","parts","part","uniqueValidCards","addedCards","loadExampleDecks","existingTitles","exampleDecks","setLoading","loading","removeDuplicateCards","deckCards","uniqueCardsMap","Map","duplicatesRemoved","Array","from","status","startStudySession","studyCards","studyCardIds","currentCardIndex","sessionStats","total","correct","incorrect","startedAt","updateStudySession","clearStudySession","getStudySession","resetAllStudyData","resetCards","restOfState","useCurrentCard","store","currentCardId"],"ignoreList":[],"sources":["../../src/utils/validation.ts","../../src/stores/authStore.ts","../../src/stores/themeStore.ts","../../src/stores/gamificationStore.ts","../../src/utils/cardDefaults.ts","../../src/data/repositories/index.ts","../../src/data/index.ts","../../src/data/mappers/domainMappers.ts","../../src/stores/deckStore.ts"],"sourcesContent":["// Input validation utilities\r\n\r\nexport interface ValidationResult {\r\n  isValid: boolean\r\n  errors: string[]\r\n}\r\n\r\nexport interface ValidationRule {\r\n  test: (value: string) => boolean\r\n  message: string\r\n}\r\n\r\n// Common validation rules\r\nexport const validationRules = {\r\n  required: (message = 'This field is required'): ValidationRule => ({\r\n    test: (value: string) => value.trim().length > 0,\r\n    message\r\n  }),\r\n  \r\n  minLength: (min: number, message?: string): ValidationRule => ({\r\n    test: (value: string) => value.length >= min,\r\n    message: message || `Must be at least ${min} characters long`\r\n  }),\r\n  \r\n  maxLength: (max: number, message?: string): ValidationRule => ({\r\n    test: (value: string) => value.length <= max,\r\n    message: message || `Must be no more than ${max} characters long`\r\n  }),\r\n  \r\n  email: (message = 'Please enter a valid email address'): ValidationRule => ({\r\n    test: (value: string) => {\r\n      const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/\r\n      return emailRegex.test(value)\r\n    },\r\n    message\r\n  }),\r\n  \r\n  password: (message = 'Password must be at least 8 characters with uppercase, lowercase, number, and special character'): ValidationRule => ({\r\n    test: (value: string) => {\r\n      // At least 8 characters, one uppercase, one lowercase, one number, one special character\r\n      const passwordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&])[A-Za-z\\d@$!%*?&]{8,}$/\r\n      return passwordRegex.test(value)\r\n    },\r\n    message\r\n  }),\r\n  \r\n  username: (message = 'Username must be 3-50 characters and contain only letters, numbers, and underscores'): ValidationRule => ({\r\n    test: (value: string) => {\r\n      const usernameRegex = /^[a-zA-Z0-9_]{3,50}$/\r\n      return usernameRegex.test(value)\r\n    },\r\n    message\r\n  }),\r\n  \r\n  noXSS: (message = 'Invalid characters detected'): ValidationRule => ({\r\n    test: (value: string) => {\r\n      // Basic XSS prevention - reject common script tags and javascript protocols\r\n      const xssRegex = /<script|javascript:|data:|vbscript:|onload=|onerror=/i\r\n      return !xssRegex.test(value)\r\n    },\r\n    message\r\n  }),\r\n  \r\n  noSQLInjection: (message = 'Invalid characters detected'): ValidationRule => ({\r\n    test: (value: string) => {\r\n      // Basic SQL injection prevention\r\n      const patterns = [\r\n        /'/, // single quotes\r\n        /\\\\'/, // escaped quotes\r\n        /;/, // semicolons\r\n        /--/, // SQL comments\r\n        /\\/\\*/, // block comments start\r\n        /(union|select|insert|delete|update|drop|create|alter|exec|execute)\\s/i // SQL keywords\r\n      ]\r\n      const hasSQLInjection = patterns.some(pattern => pattern.test(value))\r\n      return !hasSQLInjection\r\n    },\r\n    message\r\n  })\r\n}\r\n\r\n// Validate a single field\r\nexport function validateField(value: string, rules: ValidationRule[]): ValidationResult {\r\n  const errors: string[] = []\r\n  \r\n  for (const rule of rules) {\r\n    if (!rule.test(value)) {\r\n      errors.push(rule.message)\r\n    }\r\n  }\r\n  \r\n  return {\r\n    isValid: errors.length === 0,\r\n    errors\r\n  }\r\n}\r\n\r\n// Validate multiple fields\r\nexport function validateForm(data: Record<string, string>, rules: Record<string, ValidationRule[]>): Record<string, ValidationResult> {\r\n  const results: Record<string, ValidationResult> = {}\r\n  \r\n  for (const [field, fieldRules] of Object.entries(rules)) {\r\n    const value = data[field] || ''\r\n    results[field] = validateField(value, fieldRules)\r\n  }\r\n  \r\n  return results\r\n}\r\n\r\n// Check if all validation results are valid\r\nexport function isFormValid(results: Record<string, ValidationResult>): boolean {\r\n  return Object.values(results).every(result => result.isValid)\r\n}\r\n\r\n// Sanitize input to prevent XSS\r\nexport function sanitizeInput(input: string): string {\r\n  return input\r\n    .replace(/</g, '&lt;')\r\n    .replace(/>/g, '&gt;')\r\n    .replace(/\"/g, '&quot;')\r\n    .replace(/'/g, '&#x27;')\r\n    .replace(/\\//g, '&#x2F;')\r\n    .trim()\r\n}\r\n\r\n// Validate and sanitize text content\r\nexport function validateAndSanitizeText(text: string, maxLength = 5000): { isValid: boolean; sanitized: string; errors: string[] } {\r\n  const validation = validateField(text, [\r\n    validationRules.required(),\r\n    validationRules.maxLength(maxLength),\r\n    validationRules.noXSS(),\r\n    validationRules.noSQLInjection()\r\n  ])\r\n  \r\n  return {\r\n    isValid: validation.isValid,\r\n    sanitized: sanitizeInput(text),\r\n    errors: validation.errors\r\n  }\r\n}\r\n\r\n// Pre-defined validation schemas for common forms\r\nexport const validationSchemas = {\r\n  signUp: {\r\n    email: [validationRules.required(), validationRules.email()],\r\n    password: [validationRules.required(), validationRules.password()],\r\n    username: [validationRules.required(), validationRules.username()]\r\n  },\r\n  \r\n  signIn: {\r\n    email: [validationRules.required()],\r\n    password: [validationRules.required(), validationRules.minLength(6)]\r\n  },\r\n  \r\n  profile: {\r\n    username: [validationRules.required(), validationRules.username()],\r\n    email: [validationRules.required(), validationRules.email()]\r\n  },\r\n  \r\n  card: {\r\n    front_content: [validationRules.required(), validationRules.maxLength(5000), validationRules.noXSS()],\r\n    back_content: [validationRules.required(), validationRules.maxLength(5000), validationRules.noXSS()]\r\n  },\r\n  \r\n  deck: {\r\n    title: [validationRules.required(), validationRules.maxLength(200), validationRules.noXSS()],\r\n    description: [validationRules.maxLength(1000), validationRules.noXSS()]\r\n  }\r\n}","import { create } from 'zustand'\r\nimport { pb } from '../lib/pocketbase'\r\nimport type { User } from '../types'\r\nimport { debugLogger } from '../utils/debugLogger'\r\nimport { validateForm, validationSchemas, sanitizeInput } from '../utils/validation'\r\n\r\ninterface AuthState {\r\n  user: User | null\r\n  session: { record: Record<string, unknown>; token: string } | null // PocketBase auth record\r\n  isAuthenticated: boolean\r\n  isLoading: boolean\r\n  error: string | null\r\n  \r\n  // Primary Actions (unified interface for components)\r\n  login: (email: string, password: string) => Promise<void>\r\n  register: (email: string, username: string, password: string) => Promise<void>\r\n  logout: () => void\r\n  updateUser: (updates: Partial<User>) => void\r\n  \r\n  // PocketBase-specific Actions\r\n  signUp: (email: string, password: string, username: string) => Promise<void>\r\n  signIn: (email: string, password: string) => Promise<void>\r\n  signOut: () => Promise<void>\r\n  resetPassword: (email: string) => Promise<void>\r\n  updatePassword: (newPassword: string) => Promise<void>\r\n  updateProfile: (updates: Partial<User>) => Promise<void>\r\n  clearError: () => void\r\n  initializeAuth: () => Promise<void>\r\n}\r\n\r\n// Helper function to convert PocketBase user to our User type\r\nconst convertPocketbaseUser = async (pocketbaseUser: Record<string, unknown>): Promise<User> => {\r\n  debugLogger.log('[POCKETBASE_AUTH_STORE]', 'START - convertPocketbaseUser', {\r\n    userId: pocketbaseUser.id,\r\n    email: pocketbaseUser.email,\r\n    username: pocketbaseUser.username\r\n  });\r\n\r\n  try {\r\n    const convertedUser = {\r\n      id: pocketbaseUser.id,\r\n      email: pocketbaseUser.email,\r\n      username: pocketbaseUser.username || pocketbaseUser.email?.split('@')[0] || 'User',\r\n      level: pocketbaseUser.level || 1,\r\n      totalXp: pocketbaseUser.total_xp || 0,\r\n      coins: pocketbaseUser.coins || 100,\r\n      gems: pocketbaseUser.gems || 10,\r\n      createdAt: pocketbaseUser.created || new Date().toISOString(),\r\n      lastActive: pocketbaseUser.last_active || new Date().toISOString(),\r\n      preferences: pocketbaseUser.preferences || {\r\n        theme: 'system' as const,\r\n        language: 'en',\r\n        notifications: true,\r\n        soundEffects: true,\r\n        dailyGoal: 50,\r\n        timezone: 'UTC'\r\n      }\r\n    };\r\n\r\n    debugLogger.log('[POCKETBASE_AUTH_STORE]', 'END - convertPocketbaseUser', convertedUser);\r\n    return convertedUser;\r\n  } catch (error) {\r\n    debugLogger.error('[POCKETBASE_AUTH_STORE]', 'Error in convertPocketbaseUser', {\r\n      error,\r\n      stack: error instanceof Error ? error.stack : undefined,\r\n      userId: pocketbaseUser.id\r\n    });\r\n    \r\n    // Fallback: create a basic user object\r\n    const fallbackUser = {\r\n      id: pocketbaseUser.id,\r\n      email: pocketbaseUser.email || 'unknown@example.com',\r\n      username: pocketbaseUser.username || pocketbaseUser.email?.split('@')[0] || 'User',\r\n      level: 1,\r\n      totalXp: 0,\r\n      coins: 100,\r\n      gems: 10,\r\n      createdAt: pocketbaseUser.created || new Date().toISOString(),\r\n      lastActive: new Date().toISOString(),\r\n      preferences: {\r\n        theme: 'system' as const,\r\n        language: 'en',\r\n        notifications: true,\r\n        soundEffects: true,\r\n        dailyGoal: 50,\r\n        timezone: 'UTC'\r\n      }\r\n    };\r\n\r\n    debugLogger.log('[POCKETBASE_AUTH_STORE]', 'END - convertPocketbaseUser (fallback)', fallbackUser);\r\n    return fallbackUser;\r\n  }\r\n}\r\n\r\n// Helper functions for authentication operations\r\nconst validateSignUpInputs = (email: string, password: string, username: string) => {\r\n  const validationResults = validateForm(\r\n    { email, password, username },\r\n    validationSchemas.signUp\r\n  )\r\n  \r\n  const validationErrors = Object.entries(validationResults)\r\n    .filter(([_, result]) => !result.isValid)\r\n    .map(([field, result]) => `${field}: ${result.errors.join(', ')}`)\r\n  \r\n  if (validationErrors.length > 0) {\r\n    throw new Error(validationErrors.join('; '))\r\n  }\r\n}\r\n\r\nconst validateSignInInputs = (email: string, password: string) => {\r\n  const validationResults = validateForm(\r\n    { email, password },\r\n    validationSchemas.signIn\r\n  )\r\n  \r\n  const validationErrors = Object.entries(validationResults)\r\n    .filter(([_, result]) => !result.isValid)\r\n    .map(([field, result]) => `${field}: ${result.errors.join(', ')}`)\r\n  \r\n  if (validationErrors.length > 0) {\r\n    throw new Error(validationErrors.join('; '))\r\n  }\r\n}\r\n\r\nconst createPocketBaseUserData = (email: string, username: string, password: string) => ({\r\n  username: sanitizeInput(username),\r\n  email: sanitizeInput(email),\r\n  password,\r\n  passwordConfirm: password,\r\n  level: 1,\r\n  total_xp: 0,\r\n  coins: 100,\r\n  gems: 10,\r\n  last_active: new Date().toISOString(),\r\n  preferences: {\r\n    theme: 'system',\r\n    language: 'en',\r\n    notifications: true,\r\n    soundEffects: true,\r\n    dailyGoal: 50,\r\n    timezone: 'UTC'\r\n  }\r\n})\r\n\r\nconst createDemoUser = (): User => ({\r\n  id: 'demo-user',\r\n  email: 'demo@studymaster.app',\r\n  username: 'DemoUser',\r\n  level: 5,\r\n  totalXp: 2500,\r\n  coins: 150,\r\n  gems: 25,\r\n  createdAt: new Date().toISOString(),\r\n  lastActive: new Date().toISOString(),\r\n  preferences: {\r\n    theme: 'system',\r\n    language: 'en',\r\n    notifications: true,\r\n    soundEffects: true,\r\n    dailyGoal: 50,\r\n    timezone: 'UTC'\r\n  }\r\n})\r\n\r\nconst handleSignUpError = (error: unknown): string => {\r\n  if (!(error instanceof Error)) return 'Registration failed'\r\n  \r\n  if (error.message.includes('username')) {\r\n    return 'Username already exists or is invalid'\r\n  } else if (error.message.includes('email')) {\r\n    return 'Email already exists or is invalid'\r\n  } else {\r\n    return error.message\r\n  }\r\n}\r\n\r\nconst handleSignInError = (error: unknown): string => {\r\n  if (!(error instanceof Error)) return 'Login failed'\r\n  \r\n  if (error.message.includes('Failed to authenticate')) {\r\n    return 'Invalid email/username or password. Please check your credentials and try again.'\r\n  } else if (error.message.includes('Too many requests')) {\r\n    return 'Too many login attempts. Please wait a moment and try again.'\r\n  } else {\r\n    return error.message\r\n  }\r\n}\r\n\r\nconst isDemoLogin = (email: string, password: string): boolean => {\r\n  const isDevelopment = import.meta.env.NODE_ENV === 'development' || import.meta.env.VITE_ENABLE_DEBUG_LOGGING === 'true'\r\n  const demoPassword = import.meta.env.VITE_DEMO_PASSWORD || 'demo123456'\r\n  return isDevelopment && email === 'demo' && password === demoPassword\r\n}\r\n\r\nconst performPocketBaseAuth = async (email: string, password: string) => {\r\n  const sanitizedEmail = sanitizeInput(email)\r\n  \r\n  // Try email first, then username fallback\r\n  try {\r\n    return await pb.collection('users').authWithPassword(sanitizedEmail, password)\r\n  } catch (emailError) {\r\n    debugLogger.log('[POCKETBASE_AUTH_STORE]', 'Email login failed, trying username');\r\n    return await pb.collection('users').authWithPassword(sanitizedEmail, password)\r\n  }\r\n}\r\n\r\nconst updateUserLastActive = async (userId: string) => {\r\n  try {\r\n    await pb.collection('users').update(userId, {\r\n      last_active: new Date().toISOString()\r\n    })\r\n    debugLogger.log('[POCKETBASE_AUTH_STORE]', 'Updated last active time');\r\n  } catch (updateError) {\r\n    debugLogger.warn('[POCKETBASE_AUTH_STORE]', 'Could not update last active time', {\r\n      error: updateError\r\n    });\r\n  }\r\n}\r\n\r\n// Consolidated authentication store - combines PocketBase + local fallback\r\n// This replaces the dual authStore/pocketbaseAuthStore pattern\r\nexport const useAuthStore = create<AuthState>()((set, get) => ({\r\n  user: null,\r\n  session: null,\r\n  isAuthenticated: false,\r\n  isLoading: false,\r\n  error: null,\r\n\r\n  signUp: async (email: string, password: string, username: string) => {\r\n    debugLogger.log('[POCKETBASE_AUTH_STORE]', 'START - signUp', {\r\n      email,\r\n      username,\r\n      passwordLength: password.length\r\n    });\r\n\r\n    set({ isLoading: true, error: null })\r\n    \r\n    try {\r\n      validateSignUpInputs(email, password, username)\r\n      \r\n      const userData = createPocketBaseUserData(email, username, password)\r\n      debugLogger.log('[POCKETBASE_AUTH_STORE]', 'Creating user in PocketBase', {\r\n        email: userData.email,\r\n        username: userData.username\r\n      });\r\n\r\n      const newUser = await pb.collection('users').create(userData)\r\n      debugLogger.log('[POCKETBASE_AUTH_STORE]', 'User created successfully', {\r\n        userId: newUser.id\r\n      });\r\n\r\n      // Authenticate the newly created user\r\n      const authData = await pb.collection('users').authWithPassword(userData.email, password)\r\n      debugLogger.log('[POCKETBASE_AUTH_STORE]', 'SignUp with auth successful', {\r\n        userId: authData.record.id,\r\n        hasToken: !!authData.token\r\n      });\r\n\r\n      const user = await convertPocketbaseUser(authData.record)\r\n      \r\n      set({\r\n        user,\r\n        session: authData,\r\n        isAuthenticated: true,\r\n        isLoading: false,\r\n        error: null\r\n      })\r\n\r\n    } catch (error) {\r\n      debugLogger.error('[POCKETBASE_AUTH_STORE]', 'SignUp error', {\r\n        error,\r\n        stack: error instanceof Error ? error.stack : undefined\r\n      });\r\n\r\n      set({\r\n        error: handleSignUpError(error),\r\n        isLoading: false\r\n      })\r\n    }\r\n\r\n    debugLogger.log('[POCKETBASE_AUTH_STORE]', 'END - signUp');\r\n  },\r\n\r\n  signIn: async (email: string, password: string) => {\r\n    debugLogger.log('[POCKETBASE_AUTH_STORE]', 'START - signIn', {\r\n      email,\r\n      passwordLength: password.length,\r\n      isDemoLogin: email === 'demo'\r\n    });\r\n\r\n    set({ isLoading: true, error: null })\r\n    \r\n    const timeoutId = setTimeout(() => {\r\n      debugLogger.warn('[POCKETBASE_AUTH_STORE]', 'SignIn timeout reached');\r\n      set({ isLoading: false, error: 'Login timed out. Please try again.' })\r\n    }, 10000)\r\n    \r\n    try {\r\n      // Handle demo login in development\r\n      if (isDemoLogin(email, password)) {\r\n        debugLogger.info('[POCKETBASE_AUTH_STORE]', 'Demo login detected (development mode)');\r\n        const demoUser = createDemoUser()\r\n        \r\n        clearTimeout(timeoutId)\r\n        set({\r\n          user: demoUser,\r\n          session: null,\r\n          isAuthenticated: true,\r\n          isLoading: false,\r\n          error: null\r\n        })\r\n        \r\n        debugLogger.log('[POCKETBASE_AUTH_STORE]', 'END - signIn (demo user)');\r\n        return\r\n      }\r\n\r\n      // Validate inputs for regular login\r\n      validateSignInInputs(email, password)\r\n      \r\n      // Perform PocketBase authentication\r\n      debugLogger.log('[POCKETBASE_AUTH_STORE]', 'Attempting PocketBase authentication');\r\n      const authData = await performPocketBaseAuth(email, password)\r\n\r\n      debugLogger.log('[POCKETBASE_AUTH_STORE]', 'SignIn response', {\r\n        hasRecord: !!authData.record,\r\n        hasToken: !!authData.token,\r\n        userId: authData.record?.id\r\n      });\r\n\r\n      if (authData.record && authData.token) {\r\n        debugLogger.log('[POCKETBASE_AUTH_STORE]', 'SignIn successful, converting user profile');\r\n        \r\n        const user = await convertPocketbaseUser(authData.record)\r\n        await updateUserLastActive(authData.record.id)\r\n        \r\n        clearTimeout(timeoutId)\r\n        \r\n        set({\r\n          user,\r\n          session: authData,\r\n          isAuthenticated: true,\r\n          isLoading: false,\r\n          error: null\r\n        })\r\n        \r\n        debugLogger.log('[POCKETBASE_AUTH_STORE]', 'END - signIn (success)');\r\n      } else {\r\n        debugLogger.warn('[POCKETBASE_AUTH_STORE]', 'No user or token in response');\r\n        clearTimeout(timeoutId)\r\n        set({\r\n          error: 'Invalid login response - no user or token',\r\n          isLoading: false\r\n        })\r\n      }\r\n    } catch (error) {\r\n      debugLogger.error('[POCKETBASE_AUTH_STORE]', 'SignIn error', {\r\n        error,\r\n        stack: error instanceof Error ? error.stack : undefined\r\n      });\r\n      \r\n      clearTimeout(timeoutId)\r\n      set({\r\n        error: handleSignInError(error),\r\n        isLoading: false\r\n      })\r\n    }\r\n\r\n    debugLogger.log('[POCKETBASE_AUTH_STORE]', 'END - signIn');\r\n  },\r\n\r\n  signOut: async () => {\r\n    debugLogger.log('[POCKETBASE_AUTH_STORE]', 'START - signOut');\r\n    \r\n    try {\r\n      debugLogger.log('[POCKETBASE_AUTH_STORE]', 'Calling PocketBase authStore.clear');\r\n      pb.authStore.clear()\r\n      \r\n      debugLogger.log('[POCKETBASE_AUTH_STORE]', 'Clearing auth state');\r\n      set({ \r\n        user: null,\r\n        session: null,\r\n        isAuthenticated: false, \r\n        error: null \r\n      })\r\n      \r\n      debugLogger.log('[POCKETBASE_AUTH_STORE]', 'END - signOut (success)');\r\n    } catch (error) {\r\n      debugLogger.error('[POCKETBASE_AUTH_STORE]', 'SignOut error', {\r\n        error,\r\n        stack: error instanceof Error ? error.stack : undefined\r\n      });\r\n      \r\n      set({\r\n        error: error instanceof Error ? error.message : 'Logout failed'\r\n      })\r\n    }\r\n  },\r\n\r\n  resetPassword: async (email: string) => {\r\n    debugLogger.log('[POCKETBASE_AUTH_STORE]', 'START - resetPassword', { email });\r\n    \r\n    set({ isLoading: true, error: null })\r\n    \r\n    try {\r\n      await pb.collection('users').requestPasswordReset(email)\r\n      \r\n      set({\r\n        isLoading: false,\r\n        error: null\r\n      })\r\n      \r\n      debugLogger.log('[POCKETBASE_AUTH_STORE]', 'END - resetPassword (success)');\r\n    } catch (error) {\r\n      debugLogger.error('[POCKETBASE_AUTH_STORE]', 'Reset password error', {\r\n        error,\r\n        stack: error instanceof Error ? error.stack : undefined\r\n      });\r\n      \r\n      let errorMessage = 'Password reset failed'\r\n      if (error instanceof Error) {\r\n        if (error.message.includes('Invalid email')) {\r\n          errorMessage = 'Please enter a valid email address.'\r\n        } else if (error.message.includes('not found')) {\r\n          errorMessage = 'No account found with this email address.'\r\n        } else {\r\n          errorMessage = error.message\r\n        }\r\n      }\r\n      \r\n      set({\r\n        error: errorMessage,\r\n        isLoading: false\r\n      })\r\n    }\r\n  },\r\n\r\n  updatePassword: async (newPassword: string) => {\r\n    debugLogger.log('[POCKETBASE_AUTH_STORE]', 'START - updatePassword', {\r\n      passwordLength: newPassword.length\r\n    });\r\n    \r\n    const currentState = get();\r\n    debugLogger.log('[POCKETBASE_AUTH_STORE]', 'Current auth state', {\r\n      hasUser: !!currentState.user,\r\n      hasSession: !!currentState.session,\r\n      isAuthenticated: currentState.isAuthenticated\r\n    });\r\n    \r\n    set({ isLoading: true, error: null });\r\n    \r\n    try {\r\n      // Validate password\r\n      if (!newPassword || newPassword.length < 6) {\r\n        throw new Error(\"Password must be at least 6 characters long.\");\r\n      }\r\n\r\n      if (!currentState.user?.id) {\r\n        throw new Error('No authenticated user found');\r\n      }\r\n\r\n      debugLogger.log('[POCKETBASE_AUTH_STORE]', 'Calling pb.collection.update');\r\n\r\n      await pb.collection('users').update(currentState.user.id, {\r\n        password: newPassword,\r\n        passwordConfirm: newPassword\r\n      });\r\n\r\n      debugLogger.log('[POCKETBASE_AUTH_STORE]', 'Password update successful');\r\n\r\n      set({ isLoading: false, error: null });\r\n      \r\n      debugLogger.log('[POCKETBASE_AUTH_STORE]', 'END - updatePassword (success)');\r\n    } catch (error) {\r\n      const errorMessage =\r\n        error instanceof Error\r\n          ? error.message\r\n          : \"An unknown error occurred during password update.\";\r\n      \r\n      debugLogger.error('[POCKETBASE_AUTH_STORE]', 'UpdatePassword failed', {\r\n        error: errorMessage,\r\n        errorType: error?.constructor?.name,\r\n        stack: error instanceof Error ? error.stack : undefined\r\n      });\r\n      \r\n      set({ isLoading: false, error: errorMessage });\r\n      \r\n      throw new Error(errorMessage);\r\n    }\r\n  },\r\n\r\n  updateProfile: async (updates: Partial<User>) => {\r\n    const { user } = get()\r\n    \r\n    debugLogger.log('[POCKETBASE_AUTH_STORE]', 'START - updateProfile', {\r\n      userId: user?.id,\r\n      updates: Object.keys(updates)\r\n    });\r\n    \r\n    if (!user) {\r\n      debugLogger.warn('[POCKETBASE_AUTH_STORE]', 'No user found for profile update');\r\n      return\r\n    }\r\n    \r\n    try {\r\n      const updateData = {\r\n        username: updates.username,\r\n        level: updates.level,\r\n        total_xp: updates.totalXp,\r\n        coins: updates.coins,\r\n        gems: updates.gems,\r\n        preferences: updates.preferences,\r\n        last_active: new Date().toISOString()\r\n      };\r\n      \r\n      debugLogger.log('[POCKETBASE_AUTH_STORE]', 'Updating profile in database', updateData);\r\n      \r\n      await pb.collection('users').update(user.id, updateData)\r\n      \r\n      debugLogger.log('[POCKETBASE_AUTH_STORE]', 'Updating local user state');\r\n      set({ user: { ...user, ...updates } })\r\n      \r\n      debugLogger.log('[POCKETBASE_AUTH_STORE]', 'END - updateProfile (success)');\r\n    } catch (error) {\r\n      debugLogger.error('[POCKETBASE_AUTH_STORE]', 'Profile update error', {\r\n        error,\r\n        stack: error instanceof Error ? error.stack : undefined\r\n      });\r\n      \r\n      set({\r\n        error: error instanceof Error ? error.message : 'Profile update failed'\r\n      })\r\n    }\r\n  },\r\n\r\n  clearError: () => {\r\n    debugLogger.log('[POCKETBASE_AUTH_STORE]', 'Clearing error state');\r\n    set({ error: null })\r\n  },\r\n\r\n  initializeAuth: async () => {\r\n    debugLogger.log('[POCKETBASE_AUTH_STORE]', 'START - initializeAuth');\r\n    \r\n    try {\r\n      if (pb.authStore.isValid && pb.authStore.model) {\r\n        debugLogger.log('[POCKETBASE_AUTH_STORE]', 'Valid auth store found, converting user', {\r\n          userId: pb.authStore.model.id,\r\n          email: pb.authStore.model.email\r\n        });\r\n        \r\n        const user = await convertPocketbaseUser(pb.authStore.model)\r\n        \r\n        debugLogger.log('[POCKETBASE_AUTH_STORE]', 'Setting authenticated state from initialization');\r\n        set({\r\n          user,\r\n          session: {\r\n            record: pb.authStore.model,\r\n            token: pb.authStore.token\r\n          },\r\n          isAuthenticated: true\r\n        })\r\n      } else {\r\n        debugLogger.info('[POCKETBASE_AUTH_STORE]', 'No valid auth store found during initialization');\r\n      }\r\n      \r\n      debugLogger.log('[POCKETBASE_AUTH_STORE]', 'END - initializeAuth');\r\n    } catch (error) {\r\n      debugLogger.error('[POCKETBASE_AUTH_STORE]', 'Auth initialization error', {\r\n        error,\r\n        stack: error instanceof Error ? error.stack : undefined\r\n      });\r\n      \r\n      set({ \r\n        user: null,\r\n        session: null,\r\n        isAuthenticated: false \r\n      })\r\n    }\r\n  },\r\n\r\n  // Unified methods for backward compatibility with existing components\r\n  login: async (email: string, password: string) => {\r\n    const { signIn } = get()\r\n    await signIn(email, password)\r\n  },\r\n\r\n  register: async (email: string, username: string, password: string) => {\r\n    const { signUp } = get()\r\n    await signUp(email, password, username)\r\n  },\r\n\r\n  logout: () => {\r\n    const { signOut } = get()\r\n    signOut()\r\n  },\r\n\r\n  updateUser: (updates: Partial<User>) => {\r\n    const { user } = get()\r\n    if (user) {\r\n      set({ user: { ...user, ...updates } })\r\n    }\r\n  }\r\n}))\r\n\r\n// Set up auth state change listener\r\npb.authStore.onChange((token, record) => {\r\n  debugLogger.info('[POCKETBASE_AUTH_STORE]', 'Auth state change detected', {\r\n    hasToken: !!token,\r\n    hasRecord: !!record,\r\n    userId: record?.id,\r\n    timestamp: new Date().toISOString()\r\n  });\r\n  \r\n  if (token && record) {\r\n    debugLogger.log('[POCKETBASE_AUTH_STORE]', 'Processing auth state change - user logged in');\r\n    \r\n    convertPocketbaseUser(record).then(user => {\r\n      debugLogger.log('[POCKETBASE_AUTH_STORE]', 'Updating auth store for logged in user');\r\n      useAuthStore.setState({\r\n        user,\r\n        session: { record, token },\r\n        isAuthenticated: true\r\n      })\r\n    }).catch(error => {\r\n      debugLogger.error('[POCKETBASE_AUTH_STORE]', 'Failed to convert user during auth change', {\r\n        error,\r\n        userId: record.id\r\n      });\r\n    });\r\n  } else {\r\n    debugLogger.log('[POCKETBASE_AUTH_STORE]', 'Processing auth state change - user logged out');\r\n    \r\n    useAuthStore.setState({\r\n      user: null,\r\n      session: null,\r\n      isAuthenticated: false\r\n    })\r\n  }\r\n})","import { create } from 'zustand'\r\nimport { persist } from 'zustand/middleware'\r\n\r\ntype Theme = 'light' | 'dark' | 'system'\r\n\r\ninterface ThemeState {\r\n  theme: Theme\r\n  systemTheme: 'light' | 'dark'\r\n  \r\n  // Actions\r\n  setTheme: (theme: Theme) => void\r\n  toggleTheme: () => void\r\n  initializeTheme: () => void\r\n}\r\n\r\nexport const useThemeStore = create<ThemeState>()(\r\n  persist(\r\n    (set, get) => ({\r\n      theme: 'system',\r\n      systemTheme: 'light',\r\n\r\n      setTheme: (theme: Theme) => {\r\n        set({ theme })\r\n        \r\n        // Apply theme immediately\r\n        const { systemTheme } = get()\r\n        const effectiveTheme = theme === 'system' ? systemTheme : theme\r\n        \r\n        if (effectiveTheme === 'dark') {\r\n          document.documentElement.classList.add('dark')\r\n        } else {\r\n          document.documentElement.classList.remove('dark')\r\n        }\r\n      },\r\n\r\n      toggleTheme: () => {\r\n        const { theme } = get()\r\n        const newTheme = theme === 'light' ? 'dark' : 'light'\r\n        get().setTheme(newTheme)\r\n      },\r\n\r\n      initializeTheme: () => {\r\n        // Detect system theme preference\r\n        const systemTheme = window.matchMedia('(prefers-color-scheme: dark)').matches \r\n          ? 'dark' \r\n          : 'light'\r\n        \r\n        set({ systemTheme })\r\n        \r\n        // Listen for system theme changes\r\n        window.matchMedia('(prefers-color-scheme: dark)')\r\n          .addEventListener('change', (e) => {\r\n            const newSystemTheme = e.matches ? 'dark' : 'light'\r\n            set({ systemTheme: newSystemTheme })\r\n            \r\n            // If using system theme, update the applied theme\r\n            const { theme } = get()\r\n            if (theme === 'system') {\r\n              if (newSystemTheme === 'dark') {\r\n                document.documentElement.classList.add('dark')\r\n              } else {\r\n                document.documentElement.classList.remove('dark')\r\n              }\r\n            }\r\n          })\r\n        \r\n        // Apply initial theme\r\n        const { theme } = get()\r\n        const effectiveTheme = theme === 'system' ? systemTheme : theme\r\n        \r\n        if (effectiveTheme === 'dark') {\r\n          document.documentElement.classList.add('dark')\r\n        } else {\r\n          document.documentElement.classList.remove('dark')\r\n        }\r\n      }\r\n    }),\r\n    {\r\n      name: 'theme-storage',\r\n      partialize: (state) => ({ theme: state.theme })\r\n    }\r\n  )\r\n)","import { create } from 'zustand'\r\nimport { persist } from 'zustand/middleware'\r\nimport type {\r\n  Achievement,\r\n  UserAchievement,\r\n  UserStreak,\r\n  Challenge,\r\n  ChallengeParticipation,\r\n  Leaderboard,\r\n  WeeklyProgress\r\n} from '@shared/types'\r\n\r\ninterface UserStats {\r\n  totalCards: number\r\n  cardsStudiedToday: number\r\n  cardsStudiedThisWeek: number\r\n  cardsStudiedThisMonth: number\r\n  averageAccuracy: number\r\n  totalStudyTime: number // in minutes\r\n  studyTimeToday: number // in minutes\r\n  studyTimeThisWeek: number // in minutes\r\n  decksCreated: number\r\n  decksCompleted: number\r\n  longestStreak: number\r\n  currentStreak: number\r\n  // Currency system\r\n  gold: number\r\n  diamonds: number\r\n  // User level and XP\r\n  level: number\r\n  xp: number\r\n  xpToNextLevel: number\r\n}\r\n\r\ninterface GamificationState {\r\n  // User stats\r\n  userStats: UserStats\r\n  \r\n  // Achievements\r\n  achievements: Achievement[]\r\n  userAchievements: UserAchievement[]\r\n  \r\n  // Streaks\r\n  userStreak: UserStreak | null\r\n  \r\n  // Challenges\r\n  activeChallenges: Challenge[]\r\n  userChallengeParticipations: ChallengeParticipation[]\r\n  \r\n  // Leaderboards\r\n  leaderboards: Record<string, Leaderboard>\r\n  \r\n  // User state tracking\r\n  isFirstTimeUser: boolean\r\n  isInitialized: boolean\r\n  \r\n  // Actions\r\n  updateUserStats: (stats: Partial<UserStats>) => void\r\n  addUserAchievement: (achievementId: string) => void\r\n  updateStreak: (streak: Partial<UserStreak>) => void\r\n  joinChallenge: (challengeId: string) => void\r\n  updateChallengeProgress: (challengeId: string, progress: Record<string, number>) => void\r\n  claimChallengeReward: (challengeId: string) => void\r\n  initializeMockData: () => void\r\n  initializeNewUser: () => void\r\n  initializeUserData: (isDemo?: boolean) => void\r\n  resetAllUserData: () => void\r\n  addCurrency: (gold: number, diamonds: number) => void\r\n  spendCurrency: (gold: number, diamonds: number) => boolean\r\n  awardStudyXP: (cardsStudied: number, correctAnswers: number) => void\r\n  \r\n  // Monthly Challenge Management\r\n  updateMilestoneProgress: (challengeId: string, milestoneId: string, completed: boolean) => void\r\n  updateWeeklyProgress: (challengeId: string, weekData: WeeklyProgress) => void\r\n  updateChallengeStreak: (challengeId: string, streak: number) => void\r\n  unlockStoryChapter: (challengeId: string, week: number) => void\r\n  claimMilestoneReward: (challengeId: string, milestoneId: string) => void\r\n  contributeToCommunityGoal: (goalId: string, contribution: number) => void\r\n}\r\n\r\n// Mock data\r\nconst mockAchievements: Achievement[] = [\r\n  {\r\n    id: '1',\r\n    name: 'First Steps',\r\n    description: 'Complete your first study session',\r\n    icon: '',\r\n    category: 'study_milestones',\r\n    requirements: [{ type: 'sessions_completed', value: 1, operator: 'gte' }],\r\n    xpReward: 50,\r\n    coinReward: 10,\r\n    isSecret: false,\r\n    rarity: 'common'\r\n  },\r\n  {\r\n    id: '2',\r\n    name: 'Streak Master',\r\n    description: 'Maintain a 7-day study streak',\r\n    icon: '',\r\n    category: 'streaks',\r\n    requirements: [{ type: 'current_streak', value: 7, operator: 'gte' }],\r\n    xpReward: 200,\r\n    coinReward: 50,\r\n    isSecret: false,\r\n    rarity: 'rare'\r\n  },\r\n  {\r\n    id: '3',\r\n    name: 'Perfect Score',\r\n    description: 'Get 100% accuracy in a 20+ card session',\r\n    icon: '',\r\n    category: 'accuracy',\r\n    requirements: [\r\n      { type: 'session_accuracy', value: 100, operator: 'eq' },\r\n      { type: 'session_cards', value: 20, operator: 'gte' }\r\n    ],\r\n    xpReward: 150,\r\n    coinReward: 30,\r\n    isSecret: false,\r\n    rarity: 'rare'\r\n  },\r\n  {\r\n    id: '4',\r\n    name: 'Speed Demon',\r\n    description: 'Complete 50 cards in under 10 minutes',\r\n    icon: '',\r\n    category: 'special',\r\n    requirements: [\r\n      { type: 'cards_in_session', value: 50, operator: 'gte' },\r\n      { type: 'session_time', value: 600, operator: 'lte' }\r\n    ],\r\n    xpReward: 300,\r\n    coinReward: 75,\r\n    isSecret: false,\r\n    rarity: 'epic'\r\n  },\r\n  {\r\n    id: '5',\r\n    name: 'Scholar',\r\n    description: 'Study 1000 cards total',\r\n    icon: '',\r\n    category: 'study_milestones',\r\n    requirements: [{ type: 'total_cards', value: 1000, operator: 'gte' }],\r\n    xpReward: 500,\r\n    coinReward: 100,\r\n    isSecret: false,\r\n    rarity: 'epic'\r\n  },\r\n  {\r\n    id: '6',\r\n    name: 'Legend',\r\n    description: 'Reach level 20',\r\n    icon: '',\r\n    category: 'special',\r\n    requirements: [{ type: 'user_level', value: 20, operator: 'gte' }],\r\n    xpReward: 1000,\r\n    coinReward: 500,\r\n    isSecret: false,\r\n    rarity: 'legendary'\r\n  }\r\n]\r\n\r\nconst mockChallenges: Challenge[] = [\r\n  {\r\n    id: '1',\r\n    title: 'Daily Grind',\r\n    description: 'Study 25 cards today',\r\n    type: 'daily',\r\n    requirements: [{ type: 'cards_studied_today', target: 25, description: 'Study 25 cards' }],\r\n    rewards: [\r\n      { type: 'xp', amount: 50 },\r\n      { type: 'coins', amount: 10 }\r\n    ],\r\n    startDate: new Date().toISOString(),\r\n    endDate: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString(),\r\n    isActive: true,\r\n    participantCount: 1247\r\n  },\r\n  {\r\n    id: '2',\r\n    title: 'Weekly Warrior',\r\n    description: 'Complete 200 cards this week',\r\n    type: 'weekly',\r\n    requirements: [{ type: 'cards_studied_week', target: 200, description: 'Study 200 cards this week' }],\r\n    rewards: [\r\n      { type: 'xp', amount: 200 },\r\n      { type: 'coins', amount: 50 },\r\n      { type: 'gems', amount: 5 }\r\n    ],\r\n    startDate: new Date(Date.now() - 3 * 24 * 60 * 60 * 1000).toISOString(),\r\n    endDate: new Date(Date.now() + 4 * 24 * 60 * 60 * 1000).toISOString(),\r\n    isActive: true,\r\n    participantCount: 892\r\n  },\r\n  {\r\n    id: '3',\r\n    title: 'Accuracy Master',\r\n    description: 'Maintain 90%+ accuracy for 5 sessions',\r\n    type: 'weekly',\r\n    requirements: [{ type: 'accuracy_sessions', target: 5, description: 'Complete 5 sessions with 90%+ accuracy' }],\r\n    rewards: [\r\n      { type: 'xp', amount: 300 },\r\n      { type: 'coins', amount: 75 },\r\n      { type: 'badge', itemId: 'accuracy_master' }\r\n    ],\r\n    startDate: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000).toISOString(),\r\n    endDate: new Date(Date.now() + 5 * 24 * 60 * 60 * 1000).toISOString(),\r\n    isActive: true,\r\n    participantCount: 456\r\n  }\r\n]\r\n\r\nconst mockLeaderboards: Record<string, Leaderboard> = {\r\n  'xp_weekly': {\r\n    id: 'xp_weekly',\r\n    type: 'xp',\r\n    period: 'weekly',\r\n    entries: [\r\n      { userId: '1', username: 'DemoUser', score: 2500, rank: 1, change: 0 },\r\n      { userId: '2', username: 'StudyMaster', score: 2350, rank: 2, change: 1 },\r\n      { userId: '3', username: 'FlashcardPro', score: 2200, rank: 3, change: -1 },\r\n      { userId: '4', username: 'LearnFast', score: 2100, rank: 4, change: 2 },\r\n      { userId: '5', username: 'MemoryKing', score: 2050, rank: 5, change: -1 },\r\n      { userId: '6', username: 'QuizWhiz', score: 1980, rank: 6, change: 0 },\r\n      { userId: '7', username: 'CardShark', score: 1920, rank: 7, change: 3 },\r\n      { userId: '8', username: 'BrainBoost', score: 1850, rank: 8, change: -2 },\r\n      { userId: '9', username: 'StudyBuddy', score: 1800, rank: 9, change: 1 },\r\n      { userId: '10', username: 'FlashGenius', score: 1750, rank: 10, change: -1 }\r\n    ],\r\n    updatedAt: new Date().toISOString()\r\n  },\r\n  'streak_all_time': {\r\n    id: 'streak_all_time',\r\n    type: 'streak',\r\n    period: 'all_time',\r\n    entries: [\r\n      { userId: '2', username: 'StudyMaster', score: 45, rank: 1, change: 0 },\r\n      { userId: '3', username: 'FlashcardPro', score: 38, rank: 2, change: 0 },\r\n      { userId: '4', username: 'LearnFast', score: 32, rank: 3, change: 1 },\r\n      { userId: '1', username: 'DemoUser', score: 28, rank: 4, change: -1 },\r\n      { userId: '5', username: 'MemoryKing', score: 25, rank: 5, change: 0 },\r\n      { userId: '6', username: 'QuizWhiz', score: 22, rank: 6, change: 2 },\r\n      { userId: '7', username: 'CardShark', score: 20, rank: 7, change: -1 },\r\n      { userId: '8', username: 'BrainBoost', score: 18, rank: 8, change: -1 },\r\n      { userId: '9', username: 'StudyBuddy', score: 15, rank: 9, change: 0 },\r\n      { userId: '10', username: 'FlashGenius', score: 12, rank: 10, change: 0 }\r\n    ],\r\n    updatedAt: new Date().toISOString()\r\n  }\r\n}\r\n\r\n// Helper function to calculate level from XP\r\nconst calculateLevel = (xp: number): number => {\r\n  return Math.floor(Math.sqrt(xp / 100)) + 1\r\n}\r\n\r\n// Helper function to calculate XP needed for next level\r\nconst calculateXPToNextLevel = (level: number): number => {\r\n  const nextLevelXP = Math.pow(level, 2) * 100\r\n  return nextLevelXP\r\n}\r\n\r\n// Initial clean state for new users\r\nconst getInitialUserStats = (): UserStats => ({\r\n  totalCards: 0,\r\n  cardsStudiedToday: 0,\r\n  cardsStudiedThisWeek: 0,\r\n  cardsStudiedThisMonth: 0,\r\n  averageAccuracy: 0,\r\n  totalStudyTime: 0,\r\n  studyTimeToday: 0,\r\n  studyTimeThisWeek: 0,\r\n  decksCreated: 0,\r\n  decksCompleted: 0,\r\n  longestStreak: 0,\r\n  currentStreak: 0,\r\n  gold: 0,\r\n  diamonds: 0,\r\n  level: 1,\r\n  xp: 0,\r\n  xpToNextLevel: 100\r\n})\r\n\r\n// Demo data for demonstration purposes\r\nconst getDemoUserStats = (): UserStats => ({\r\n  totalCards: 1250,\r\n  cardsStudiedToday: 45,\r\n  cardsStudiedThisWeek: 180,\r\n  cardsStudiedThisMonth: 720,\r\n  averageAccuracy: 87.5,\r\n  totalStudyTime: 2400, // 40 hours\r\n  studyTimeToday: 35,\r\n  studyTimeThisWeek: 240, // 4 hours\r\n  decksCreated: 8,\r\n  decksCompleted: 3,\r\n  longestStreak: 28,\r\n  currentStreak: 12,\r\n  gold: 100,\r\n  diamonds: 10,\r\n  level: 8,\r\n  xp: 6400,\r\n  xpToNextLevel: 8100\r\n})\r\n\r\nexport const useGamificationStore = create<GamificationState>()(\r\n  persist(\r\n    (set, get) => ({\r\n      userStats: getInitialUserStats(),\r\n      isFirstTimeUser: true,\r\n      isInitialized: false,\r\n      \r\n      achievements: mockAchievements,\r\n      userAchievements: [],\r\n      \r\n      userStreak: null,\r\n      \r\n      activeChallenges: mockChallenges,\r\n      userChallengeParticipations: [],\r\n      \r\n      leaderboards: mockLeaderboards,\r\n      \r\n      updateUserStats: (stats) => {\r\n        set((state) => {\r\n          const newStats = { ...state.userStats, ...stats }\r\n          \r\n          // Recalculate level and XP if XP changed\r\n          if (stats.xp !== undefined) {\r\n            newStats.level = calculateLevel(newStats.xp)\r\n            newStats.xpToNextLevel = calculateXPToNextLevel(newStats.level)\r\n          }\r\n          \r\n          return {\r\n            userStats: newStats,\r\n            isFirstTimeUser: false,\r\n            isInitialized: true\r\n          }\r\n        })\r\n      },\r\n      \r\n      addUserAchievement: (achievementId) => {\r\n        const { userAchievements } = get()\r\n        if (!userAchievements.find(ua => ua.achievementId === achievementId)) {\r\n          set((state) => ({\r\n            userAchievements: [\r\n              ...state.userAchievements,\r\n              {\r\n                id: Date.now().toString(),\r\n                userId: '1',\r\n                achievementId,\r\n                earnedAt: new Date().toISOString()\r\n              }\r\n            ]\r\n          }))\r\n        }\r\n      },\r\n      \r\n      updateStreak: (streak) => {\r\n        set((state) => ({\r\n          userStreak: state.userStreak ? { ...state.userStreak, ...streak } : null\r\n        }))\r\n      },\r\n      \r\n      joinChallenge: (challengeId) => {\r\n        const { userChallengeParticipations } = get()\r\n        if (!userChallengeParticipations.find(p => p.challengeId === challengeId)) {\r\n          set((state) => ({\r\n            userChallengeParticipations: [\r\n              ...state.userChallengeParticipations,\r\n              {\r\n                id: Date.now().toString(),\r\n                userId: '1',\r\n                challengeId,\r\n                progress: {},\r\n                completed: false,\r\n                joinedAt: new Date().toISOString(),\r\n                milestoneProgress: {},\r\n                weeklyProgress: [],\r\n                currentStreak: 0,\r\n                bestWeek: 0\r\n              }\r\n            ]\r\n          }))\r\n        }\r\n      },\r\n      \r\n      updateChallengeProgress: (challengeId, progress) => {\r\n        set((state) => ({\r\n          userChallengeParticipations: state.userChallengeParticipations.map(p =>\r\n            p.challengeId === challengeId\r\n              ? { ...p, progress: { ...p.progress, ...progress } }\r\n              : p\r\n          )\r\n        }))\r\n      },\r\n      \r\n      claimChallengeReward: (challengeId) => {\r\n        const { activeChallenges, userChallengeParticipations } = get()\r\n        const challenge = activeChallenges.find(c => c.id === challengeId)\r\n        const participation = userChallengeParticipations.find(p => p.challengeId === challengeId)\r\n        \r\n        if (challenge && participation && participation.completed) {\r\n          // Calculate total XP and coins from rewards\r\n          let xpGained = 0\r\n          // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n          let _coinsGained = 0\r\n          \r\n          challenge.rewards.forEach(reward => {\r\n            if (reward.type === 'xp' && reward.amount) {\r\n              xpGained += reward.amount\r\n            } else if (reward.type === 'coins' && reward.amount) {\r\n              _coinsGained += reward.amount\r\n            }\r\n          })\r\n          \r\n          // Update user stats with rewards\r\n          set((state) => ({\r\n            userStats: {\r\n              ...state.userStats,\r\n              totalCards: state.userStats.totalCards + xpGained / 10 // Rough conversion\r\n            },\r\n            // Remove the participation since reward is claimed\r\n            userChallengeParticipations: state.userChallengeParticipations.filter(\r\n              p => p.challengeId !== challengeId\r\n            )\r\n          }))\r\n        }\r\n      },\r\n      \r\n      initializeMockData: () => {\r\n        // This function can be called to load demo data\r\n        set({\r\n          userStats: getDemoUserStats(),\r\n          achievements: mockAchievements,\r\n          activeChallenges: mockChallenges,\r\n          leaderboards: mockLeaderboards,\r\n          userAchievements: [\r\n            {\r\n              id: '1',\r\n              userId: '1',\r\n              achievementId: '1',\r\n              earnedAt: new Date(Date.now() - 10 * 24 * 60 * 60 * 1000).toISOString()\r\n            },\r\n            {\r\n              id: '2',\r\n              userId: '1',\r\n              achievementId: '2',\r\n              earnedAt: new Date(Date.now() - 5 * 24 * 60 * 60 * 1000).toISOString()\r\n            }\r\n          ],\r\n          userStreak: {\r\n            id: '1',\r\n            userId: '1',\r\n            currentStreak: 12,\r\n            longestStreak: 28,\r\n            lastStudyDate: new Date().toISOString(),\r\n            freezeCount: 2,\r\n            createdAt: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString()\r\n          },\r\n          userChallengeParticipations: [\r\n            {\r\n              id: '1',\r\n              userId: '1',\r\n              challengeId: '1',\r\n              progress: { cards_studied_today: 45 } as Record<string, number>,\r\n              completed: true,\r\n              joinedAt: new Date().toISOString(),\r\n              completedAt: new Date().toISOString(),\r\n              milestoneProgress: { 'milestone_1': true },\r\n              weeklyProgress: [],\r\n              currentStreak: 5,\r\n              bestWeek: 1\r\n            },\r\n            {\r\n              id: '2',\r\n              userId: '1',\r\n              challengeId: '2',\r\n              progress: { cards_studied_week: 180 } as Record<string, number>,\r\n              completed: false,\r\n              joinedAt: new Date(Date.now() - 3 * 24 * 60 * 60 * 1000).toISOString(),\r\n              milestoneProgress: { 'milestone_1': true, 'milestone_2': false },\r\n              weeklyProgress: [\r\n                {\r\n                  week: 1,\r\n                  startDate: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString(),\r\n                  endDate: new Date().toISOString(),\r\n                  progress: { cards_studied_week: 180 },\r\n                  completed: true,\r\n                  completedAt: new Date().toISOString(),\r\n                  storyUnlocked: true\r\n                }\r\n              ],\r\n              currentStreak: 3,\r\n              bestWeek: 1\r\n            }\r\n          ] as ChallengeParticipation[],\r\n          isFirstTimeUser: false,\r\n          isInitialized: true\r\n        })\r\n      },\r\n\r\n      initializeNewUser: () => {\r\n        // Initialize a completely fresh user\r\n        set({\r\n          userStats: getInitialUserStats(),\r\n          userAchievements: [],\r\n          userStreak: null,\r\n          userChallengeParticipations: [],\r\n          isFirstTimeUser: false,\r\n          isInitialized: true\r\n        })\r\n      },\r\n\r\n      resetAllUserData: () => {\r\n        // Reset all user-specific data to initial state\r\n        set({\r\n          userStats: getInitialUserStats(),\r\n          userAchievements: [],\r\n          userStreak: null,\r\n          userChallengeParticipations: [],\r\n          isFirstTimeUser: true,\r\n          isInitialized: true\r\n        })\r\n      },\r\n\r\n      addCurrency: (gold, diamonds) => {\r\n        set((state) => ({\r\n          userStats: {\r\n            ...state.userStats,\r\n            gold: state.userStats.gold + gold,\r\n            diamonds: state.userStats.diamonds + diamonds\r\n          }\r\n        }))\r\n      },\r\n\r\n      spendCurrency: (gold, diamonds) => {\r\n        const { userStats } = get()\r\n        if (userStats.gold >= gold && userStats.diamonds >= diamonds) {\r\n          set((state) => ({\r\n            userStats: {\r\n              ...state.userStats,\r\n              gold: state.userStats.gold - gold,\r\n              diamonds: state.userStats.diamonds - diamonds\r\n            }\r\n          }))\r\n          return true\r\n        }\r\n        return false\r\n      },\r\n\r\n      // Initialize user data based on authentication status\r\n      initializeUserData: (isDemo: boolean = false) => {\r\n        const state = get()\r\n        \r\n        // Only initialize if not already done\r\n        if (!state.isInitialized) {\r\n          if (isDemo) {\r\n            // Load demo data for demo users\r\n            set({\r\n              userStats: getDemoUserStats(),\r\n              achievements: mockAchievements,\r\n              activeChallenges: mockChallenges,\r\n              leaderboards: mockLeaderboards,\r\n              userAchievements: [\r\n                {\r\n                  id: '1',\r\n                  userId: '1',\r\n                  achievementId: '1',\r\n                  earnedAt: new Date(Date.now() - 10 * 24 * 60 * 60 * 1000).toISOString()\r\n                },\r\n                {\r\n                  id: '2',\r\n                  userId: '1',\r\n                  achievementId: '2',\r\n                  earnedAt: new Date(Date.now() - 5 * 24 * 60 * 60 * 1000).toISOString()\r\n                }\r\n              ],\r\n              userStreak: {\r\n                id: '1',\r\n                userId: '1',\r\n                currentStreak: 12,\r\n                longestStreak: 28,\r\n                lastStudyDate: new Date().toISOString(),\r\n                freezeCount: 2,\r\n                createdAt: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString()\r\n              },\r\n              userChallengeParticipations: [\r\n                {\r\n                  id: '1',\r\n                  userId: '1',\r\n                  challengeId: '1',\r\n                  progress: { cards_studied_today: 45 } as Record<string, number>,\r\n                  completed: true,\r\n                  joinedAt: new Date().toISOString(),\r\n                  completedAt: new Date().toISOString()\r\n                },\r\n                {\r\n                  id: '2',\r\n                  userId: '1',\r\n                  challengeId: '2',\r\n                  progress: { cards_studied_week: 180 } as Record<string, number>,\r\n                  completed: false,\r\n                  joinedAt: new Date(Date.now() - 3 * 24 * 60 * 60 * 1000).toISOString()\r\n                }\r\n              ] as ChallengeParticipation[],\r\n              isFirstTimeUser: false,\r\n              isInitialized: true\r\n            })\r\n          } else {\r\n            // Initialize fresh user data for new authenticated users\r\n            set({\r\n              userStats: getInitialUserStats(),\r\n              userAchievements: [],\r\n              userStreak: null,\r\n              userChallengeParticipations: [],\r\n              isFirstTimeUser: false,\r\n              isInitialized: true\r\n            })\r\n          }\r\n        }\r\n      },\r\n\r\n      // Monthly Challenge Management Methods\r\n      updateMilestoneProgress: (challengeId, milestoneId, completed) => {\r\n        set((state) => ({\r\n          userChallengeParticipations: state.userChallengeParticipations.map(p =>\r\n            p.challengeId === challengeId\r\n              ? {\r\n                  ...p,\r\n                  milestoneProgress: {\r\n                    ...p.milestoneProgress,\r\n                    [milestoneId]: completed\r\n                  }\r\n                }\r\n              : p\r\n          )\r\n        }))\r\n      },\r\n\r\n      updateWeeklyProgress: (challengeId, weekData) => {\r\n        set((state) => ({\r\n          userChallengeParticipations: state.userChallengeParticipations.map(p =>\r\n            p.challengeId === challengeId\r\n              ? {\r\n                  ...p,\r\n                  weeklyProgress: p.weeklyProgress\r\n                    ? [...p.weeklyProgress.filter(w => w.week !== weekData.week), weekData]\r\n                    : [weekData]\r\n                }\r\n              : p\r\n          )\r\n        }))\r\n      },\r\n\r\n      updateChallengeStreak: (challengeId, streak) => {\r\n        set((state) => ({\r\n          userChallengeParticipations: state.userChallengeParticipations.map(p =>\r\n            p.challengeId === challengeId\r\n              ? { ...p, currentStreak: streak }\r\n              : p\r\n          )\r\n        }))\r\n      },\r\n\r\n      unlockStoryChapter: (challengeId, week) => {\r\n        set((state) => ({\r\n          userChallengeParticipations: state.userChallengeParticipations.map(p =>\r\n            p.challengeId === challengeId\r\n              ? {\r\n                  ...p,\r\n                  weeklyProgress: p.weeklyProgress?.map(w =>\r\n                    w.week === week\r\n                      ? { ...w, storyUnlocked: true }\r\n                      : w\r\n                  ) || []\r\n                }\r\n              : p\r\n          )\r\n        }))\r\n      },\r\n\r\n      claimMilestoneReward: (challengeId, milestoneId) => {\r\n        // Find the challenge and milestone to get reward details\r\n        const { activeChallenges } = get()\r\n        const challenge = activeChallenges.find(c => c.id === challengeId)\r\n        \r\n        if (challenge) {\r\n          // Add milestone reward logic here\r\n          // For now, just mark milestone as claimed\r\n          set((state) => ({\r\n            userChallengeParticipations: state.userChallengeParticipations.map(p =>\r\n              p.challengeId === challengeId\r\n                ? {\r\n                    ...p,\r\n                    milestoneProgress: {\r\n                      ...p.milestoneProgress,\r\n                      [`${milestoneId}_claimed`]: true\r\n                    }\r\n                  }\r\n                : p\r\n            )\r\n          }))\r\n        }\r\n      },\r\n\r\n      contributeToCommunityGoal: (goalId, contribution) => {\r\n        // Update community goal progress\r\n        // This would typically involve API calls to update server-side data\r\n        // For now, we'll just update local state\r\n        console.log(`Contributing ${contribution} to community goal ${goalId}`)\r\n        \r\n        // Update user stats to reflect contribution\r\n        set((state) => ({\r\n          userStats: {\r\n            ...state.userStats,\r\n            // Add contribution tracking if needed\r\n          }\r\n        }))\r\n      },\r\n\r\n      awardStudyXP: (cardsStudied, correctAnswers) => {\r\n        // Award XP based on study performance\r\n        // Base XP: 1 XP per card studied\r\n        // Bonus XP: 1 additional XP per correct answer (rating higher than \"Again\")\r\n        // Milestone bonus: 10 XP for every 10 cards studied with good performance\r\n        \r\n        let xpGained = cardsStudied // Base XP\r\n        xpGained += correctAnswers // Bonus for correct answers\r\n        \r\n        // Milestone bonus: 10 XP for every 10 cards with good performance\r\n        const milestoneBonus = Math.floor(correctAnswers / 10) * 10\r\n        xpGained += milestoneBonus\r\n        \r\n        if (xpGained > 0) {\r\n          set((state) => {\r\n            const newXP = state.userStats.xp + xpGained\r\n            const newLevel = calculateLevel(newXP)\r\n            const newXPToNextLevel = calculateXPToNextLevel(newLevel)\r\n            \r\n            console.log(` XP Awarded: +${xpGained} XP (${cardsStudied} cards, ${correctAnswers} correct, ${milestoneBonus} milestone bonus)`)\r\n            console.log(` Total XP: ${state.userStats.xp}  ${newXP} (Level ${state.userStats.level}  ${newLevel})`)\r\n            \r\n            return {\r\n              userStats: {\r\n                ...state.userStats,\r\n                xp: newXP,\r\n                level: newLevel,\r\n                xpToNextLevel: newXPToNextLevel,\r\n                totalCards: state.userStats.totalCards + cardsStudied,\r\n                cardsStudiedToday: state.userStats.cardsStudiedToday + cardsStudied\r\n              }\r\n            }\r\n          })\r\n        }\r\n      }\r\n    }),\r\n    {\r\n      name: 'gamification-storage',\r\n      partialize: (state) => ({\r\n        userStats: state.userStats,\r\n        userAchievements: state.userAchievements,\r\n        userStreak: state.userStreak,\r\n        userChallengeParticipations: state.userChallengeParticipations,\r\n        isFirstTimeUser: state.isFirstTimeUser,\r\n        isInitialized: state.isInitialized\r\n      })\r\n    }\r\n  )\r\n)","import { Card, CardType, MediaReference } from '../../../shared/types'\r\n\r\n/**\r\n * Create a new card with all required Anki-style fields populated with defaults\r\n */\r\nexport function createNewCard(\r\n  frontContent: string,\r\n  backContent: string,\r\n  cardType: CardType = { type: 'basic' },\r\n  mediaRefs: MediaReference[] = []\r\n): Omit<Card, 'id' | 'createdAt' | 'deckId' | 'easeFactor' | 'intervalDays' | 'nextReview' | 'reviewCount' | 'lapseCount'> {\r\n  return {\r\n    frontContent,\r\n    backContent,\r\n    cardType,\r\n    mediaRefs,\r\n    \r\n    // Enhanced Anki-style fields with defaults\r\n    state: 'new',\r\n    queue: 0, // 0 = new\r\n    due: 0, // New cards have no due date\r\n    ivl: 0, // No interval yet\r\n    factor: 2500, // Default ease factor (250%)\r\n    reps: 0, // No repetitions yet\r\n    lapses: 0, // No lapses yet\r\n    left: 0, // No learning time left\r\n    \r\n    // Learning state defaults\r\n    learningStep: 0,\r\n    graduationInterval: 1, // Default 1 day\r\n    easyInterval: 4, // Default 4 days\r\n    \r\n    // Timing and performance defaults\r\n    totalStudyTime: 0,\r\n    averageAnswerTime: 0,\r\n    \r\n    // Metadata defaults\r\n    flags: 0,\r\n    originalDue: 0,\r\n    originalDeck: '', // Will be set when card is created\r\n    \r\n    // Gamification defaults\r\n    xpAwarded: 0,\r\n    difficultyRating: 3 // Default medium difficulty\r\n  }\r\n}\r\n\r\n/**\r\n * Create a complete card object for SVG map cards\r\n */\r\nexport function createSvgMapCard(\r\n  id: string,\r\n  deckId: string,\r\n  frontContent: string,\r\n  backContent: string,\r\n  cardType: CardType,\r\n  mediaRefs: MediaReference[] = []\r\n): Card {\r\n  const baseCard = createNewCard(frontContent, backContent, cardType, mediaRefs)\r\n  \r\n  return {\r\n    ...baseCard,\r\n    id,\r\n    deckId,\r\n    createdAt: new Date().toISOString(),\r\n    \r\n    // Legacy fields for backward compatibility\r\n    easeFactor: 2.5,\r\n    intervalDays: 0,\r\n    nextReview: new Date().toISOString(),\r\n    reviewCount: 0,\r\n    lapseCount: 0,\r\n    \r\n    // Set original deck\r\n    originalDeck: deckId\r\n  }\r\n}","/**\r\n * Repositories: IndexedDB-backed data access layer for StudyMaster\r\n *\r\n * Exposes typed repository interfaces with a default IndexedDB implementation (Dexie).\r\n * UI stores and services should use these repositories instead of accessing Dexie directly.\r\n *\r\n * Minimal methods provided to start Phase 0. Extend incrementally as flows are refactored.\r\n */\r\n\r\nimport db, { ensureDBOpen, type DeckRow, type CardRow, type ReviewRow, type MediaRow, type AchievementRow, type LeaderboardCacheRow } from '../db';\r\n\r\n/* =========================\r\n * Shared helpers / DTO types\r\n * ========================= */\r\n\r\nconst nowTs = () => Date.now();\r\n\r\nexport type NewDeck = {\r\n  deckId: string;\r\n  name: string;\r\n  description?: string;\r\n  meta?: Record<string, unknown>;\r\n};\r\n\r\nexport type UpdateDeck = Partial<Pick<DeckRow, 'name' | 'description' | 'meta'>>;\r\n\r\nexport type NewCard = {\r\n  cardId: string;\r\n  deckId: string;\r\n  fields: { [k: string]: unknown; front: string; back: string };\r\n  mediaRefs?: string[];\r\n  dueAt?: number | null;\r\n  interval?: number;\r\n  ease?: number;\r\n  lapses?: number;\r\n  state?: CardRow['state'];\r\n};\r\n\r\nexport type UpdateCard = Partial<Omit<CardRow, 'cardId' | 'deckId' | 'createdAt' | 'updatedAt'>>;\r\n\r\nexport type NewReview = {\r\n  reviewId: string;\r\n  cardId: string;\r\n  rating: 1 | 2 | 3 | 4;\r\n  interval: number;\r\n  ease: number;\r\n  lapses: number;\r\n  elapsedSeconds?: number;\r\n  reviewedAt: number;\r\n};\r\n\r\nexport type MediaWriteOptions = {\r\n  mediaHash: string;\r\n  blob?: Blob;\r\n  opfsPointer?: string;\r\n  mimeType: string;\r\n  byteLength?: number;\r\n  validationMeta?: Record<string, unknown>;\r\n  securityFlags?: MediaRow['securityFlags'];\r\n};\r\n\r\nexport type AchievementUpsert = {\r\n  achievementId: string;\r\n  userId: string;\r\n  unlockedAt?: number;\r\n  progress?: number;\r\n  meta?: Record<string, unknown>;\r\n};\r\n\r\nexport type LeaderboardCacheWrite = {\r\n  scope: string;\r\n  entries: LeaderboardCacheRow['entries'];\r\n  ttlMs: number;\r\n  fetchedAt?: number;\r\n};\r\n\r\n/* =========================\r\n * Repository interfaces\r\n * ========================= */\r\n\r\nexport interface DeckRepository {\r\n  create(deck: NewDeck): Promise<DeckRow>;\r\n  get(deckId: string): Promise<DeckRow | null>;\r\n  list(): Promise<DeckRow[]>;\r\n  update(deckId: string, patch: UpdateDeck): Promise<DeckRow>;\r\n  remove(deckId: string): Promise<void>;\r\n}\r\n\r\nexport interface CardRepository {\r\n  create(card: NewCard): Promise<CardRow>;\r\n  get(cardId: string): Promise<CardRow | null>;\r\n  listByDeck(deckId: string): Promise<CardRow[]>;\r\n  update(cardId: string, patch: UpdateCard): Promise<CardRow>;\r\n  remove(cardId: string): Promise<void>;\r\n}\r\n\r\nexport interface ReviewRepository {\r\n  add(review: NewReview): Promise<ReviewRow>;\r\n  listByCard(cardId: string, limit?: number): Promise<ReviewRow[]>;\r\n}\r\n\r\nexport interface MediaRepository {\r\n  put(options: MediaWriteOptions): Promise<MediaRow>;\r\n  get(mediaHash: string): Promise<MediaRow | null>;\r\n  has(mediaHash: string): Promise<boolean>;\r\n  remove(mediaHash: string): Promise<void>;\r\n}\r\n\r\nexport interface AchievementRepository {\r\n  upsert(input: AchievementUpsert): Promise<AchievementRow>;\r\n  listByUser(userId: string): Promise<AchievementRow[]>;\r\n}\r\n\r\nexport interface LeaderboardCacheRepository {\r\n  set(input: LeaderboardCacheWrite): Promise<LeaderboardCacheRow>;\r\n  get(scope: string, { ignoreTTL }?: { ignoreTTL?: boolean }): Promise<LeaderboardCacheRow | null>;\r\n}\r\n\r\n/* =========================\r\n * IndexedDB implementations\r\n * ========================= */\r\n\r\nasync function createDeckIndexedDB(deck: NewDeck): Promise<DeckRow> {\r\n  await ensureDBOpen();\r\n  const now = nowTs();\r\n  const row: DeckRow = {\r\n    deckId: deck.deckId,\r\n    name: deck.name,\r\n    description: deck.description,\r\n    cardCount: 0,\r\n    mediaCount: 0,\r\n    meta: deck.meta,\r\n    createdAt: now,\r\n    updatedAt: now,\r\n  };\r\n  await db.decks.add(row);\r\n  return row;\r\n}\r\n\r\nasync function getDeckIndexedDB(deckId: string): Promise<DeckRow | null> {\r\n  await ensureDBOpen();\r\n  return (await db.decks.get(deckId)) ?? null;\r\n}\r\n\r\nasync function listDecksIndexedDB(): Promise<DeckRow[]> {\r\n  await ensureDBOpen();\r\n  return db.decks.orderBy('updatedAt').reverse().toArray();\r\n}\r\n\r\nasync function updateDeckIndexedDB(deckId: string, patch: UpdateDeck): Promise<DeckRow> {\r\n  await ensureDBOpen();\r\n  const existing = await db.decks.get(deckId);\r\n  if (!existing) throw new Error(`Deck not found: ${deckId}`);\r\n  const updated: DeckRow = { ...existing, ...patch, updatedAt: nowTs() };\r\n  await db.decks.put(updated);\r\n  return updated;\r\n}\r\n\r\nasync function removeDeckIndexedDB(deckId: string): Promise<void> {\r\n  await ensureDBOpen();\r\n  // Consider cascading deletes at higher level; here only deck is removed.\r\n  await db.decks.delete(deckId);\r\n}\r\n\r\nasync function createCardIndexedDB(card: NewCard): Promise<CardRow> {\r\n  await ensureDBOpen();\r\n  const now = nowTs();\r\n  const row: CardRow = {\r\n    cardId: card.cardId,\r\n    deckId: card.deckId,\r\n    fields: card.fields,\r\n    mediaRefs: card.mediaRefs ?? [],\r\n    dueAt: card.dueAt ?? null,\r\n    interval: card.interval ?? 0,\r\n    ease: card.ease ?? 250,\r\n    lapses: card.lapses ?? 0,\r\n    state: card.state ?? 'new',\r\n    createdAt: now,\r\n    updatedAt: now,\r\n  };\r\n  await db.transaction('rw', db.cards, db.decks, async () => {\r\n    await db.cards.add(row);\r\n    const deck = await db.decks.get(row.deckId);\r\n    if (deck) {\r\n      await db.decks.put({ ...deck, cardCount: (deck.cardCount ?? 0) + 1, updatedAt: nowTs() });\r\n    }\r\n  });\r\n  return row;\r\n}\r\n\r\nasync function getCardIndexedDB(cardId: string): Promise<CardRow | null> {\r\n  await ensureDBOpen();\r\n  return (await db.cards.get(cardId)) ?? null;\r\n}\r\n\r\nasync function listCardsByDeckIndexedDB(deckId: string): Promise<CardRow[]> {\r\n  await ensureDBOpen();\r\n  return db.cards.where('deckId').equals(deckId).sortBy('updatedAt');\r\n}\r\n\r\nasync function updateCardIndexedDB(cardId: string, patch: UpdateCard): Promise<CardRow> {\r\n  await ensureDBOpen();\r\n  const existing = await db.cards.get(cardId);\r\n  if (!existing) throw new Error(`Card not found: ${cardId}`);\r\n  const updated: CardRow = { ...existing, ...patch, updatedAt: nowTs() };\r\n  await db.cards.put(updated);\r\n  return updated;\r\n}\r\n\r\nasync function removeCardIndexedDB(cardId: string): Promise<void> {\r\n  await ensureDBOpen();\r\n  const existing = await db.cards.get(cardId);\r\n  await db.transaction('rw', db.cards, db.decks, async () => {\r\n    await db.cards.delete(cardId);\r\n    if (existing) {\r\n      const deck = await db.decks.get(existing.deckId);\r\n      if (deck) {\r\n        await db.decks.put({ ...deck, cardCount: Math.max(0, (deck.cardCount ?? 0) - 1), updatedAt: nowTs() });\r\n      }\r\n    }\r\n  });\r\n}\r\n\r\nasync function addReviewIndexedDB(review: NewReview): Promise<ReviewRow> {\r\n  await ensureDBOpen();\r\n  const row: ReviewRow = { ...review };\r\n  await db.reviews.add(row);\r\n  return row;\r\n}\r\n\r\nasync function listReviewsByCardIndexedDB(cardId: string, limit = 50): Promise<ReviewRow[]> {\r\n  await ensureDBOpen();\r\n  return db.reviews.where('cardId').equals(cardId).reverse().sortBy('reviewedAt').then((arr) => arr.slice(0, limit));\r\n}\r\n\r\nasync function putMediaIndexedDB(options: MediaWriteOptions): Promise<MediaRow> {\r\n  await ensureDBOpen();\r\n  const now = nowTs();\r\n  const row: MediaRow = {\r\n    mediaHash: options.mediaHash,\r\n    blob: options.blob,\r\n    opfsPointer: options.opfsPointer,\r\n    mimeType: options.mimeType,\r\n    byteLength: options.byteLength ?? (options.blob ? options.blob.size : 0),\r\n    validationMeta: options.validationMeta,\r\n    securityFlags: options.securityFlags,\r\n    createdAt: now,\r\n    updatedAt: now,\r\n  };\r\n  await db.media.put(row);\r\n  return row;\r\n}\r\n\r\nasync function getMediaIndexedDB(mediaHash: string): Promise<MediaRow | null> {\r\n  await ensureDBOpen();\r\n  return (await db.media.get(mediaHash)) ?? null;\r\n}\r\n\r\nasync function hasMediaIndexedDB(mediaHash: string): Promise<boolean> {\r\n  await ensureDBOpen();\r\n  const found = await db.media.get(mediaHash);\r\n  return !!found;\r\n}\r\n\r\nasync function removeMediaIndexedDB(mediaHash: string): Promise<void> {\r\n  await ensureDBOpen();\r\n  await db.media.delete(mediaHash);\r\n}\r\n\r\nasync function upsertAchievementIndexedDB(input: AchievementUpsert): Promise<AchievementRow> {\r\n  await ensureDBOpen();\r\n  const existing = await db.achievements.get(input.achievementId);\r\n  const row: AchievementRow = {\r\n    achievementId: input.achievementId,\r\n    userId: input.userId,\r\n    unlockedAt: input.unlockedAt ?? existing?.unlockedAt,\r\n    progress: input.progress ?? existing?.progress ?? 0,\r\n    meta: { ...(existing?.meta ?? {}), ...(input.meta ?? {}) },\r\n  };\r\n  await db.achievements.put(row);\r\n  return row;\r\n}\r\n\r\nasync function listAchievementsByUserIndexedDB(userId: string): Promise<AchievementRow[]> {\r\n  await ensureDBOpen();\r\n  return db.achievements.where('userId').equals(userId).toArray();\r\n}\r\n\r\nasync function setLeaderboardCacheIndexedDB(input: LeaderboardCacheWrite): Promise<LeaderboardCacheRow> {\r\n  await ensureDBOpen();\r\n  const row: LeaderboardCacheRow = {\r\n    scope: input.scope,\r\n    entries: input.entries,\r\n    fetchedAt: input.fetchedAt ?? nowTs(),\r\n    ttlMs: input.ttlMs,\r\n  };\r\n  await db.leaderboardCache.put(row);\r\n  return row;\r\n}\r\n\r\nasync function getLeaderboardCacheIndexedDB(scope: string, opts?: { ignoreTTL?: boolean }): Promise<LeaderboardCacheRow | null> {\r\n  await ensureDBOpen();\r\n  const row = await db.leaderboardCache.get(scope);\r\n  if (!row) return null;\r\n  if (opts?.ignoreTTL) return row;\r\n  const age = nowTs() - row.fetchedAt;\r\n  if (age > row.ttlMs) return null;\r\n  return row;\r\n}\r\n\r\n/* =========================\r\n * Factory\r\n * ========================= */\r\n\r\nexport type Repositories = {\r\n  decks: DeckRepository;\r\n  cards: CardRepository;\r\n  reviews: ReviewRepository;\r\n  media: MediaRepository;\r\n  achievements: AchievementRepository;\r\n  leaderboardCache: LeaderboardCacheRepository;\r\n};\r\n\r\nexport function createIndexedDBRepositories(): Repositories {\r\n  return {\r\n    decks: {\r\n      create: createDeckIndexedDB,\r\n      get: getDeckIndexedDB,\r\n      list: listDecksIndexedDB,\r\n      update: updateDeckIndexedDB,\r\n      remove: removeDeckIndexedDB,\r\n    },\r\n    cards: {\r\n      create: createCardIndexedDB,\r\n      get: getCardIndexedDB,\r\n      listByDeck: listCardsByDeckIndexedDB,\r\n      update: updateCardIndexedDB,\r\n      remove: removeCardIndexedDB,\r\n    },\r\n    reviews: {\r\n      add: addReviewIndexedDB,\r\n      listByCard: listReviewsByCardIndexedDB,\r\n    },\r\n    media: {\r\n      put: putMediaIndexedDB,\r\n      get: getMediaIndexedDB,\r\n      has: hasMediaIndexedDB,\r\n      remove: removeMediaIndexedDB,\r\n    },\r\n    achievements: {\r\n      upsert: upsertAchievementIndexedDB,\r\n      listByUser: listAchievementsByUserIndexedDB,\r\n    },\r\n    leaderboardCache: {\r\n      set: setLeaderboardCacheIndexedDB,\r\n      get: getLeaderboardCacheIndexedDB,\r\n    },\r\n  };\r\n}","/**\r\n * Data layer entrypoint\r\n * - Exports a singleton set of repositories backed by IndexedDB (Dexie)\r\n * - Keep this the only import point for repos from UI/stores\r\n */\r\n\r\nimport { createIndexedDBRepositories } from './repositories';\r\n\r\nexport const repos = createIndexedDBRepositories();\r\n\r\nexport type { Repositories } from './repositories';","/**\r\n * Domain <-> Repository mappers\r\n * Map shared domain types (Deck/Card) to repository DTOs and vice versa.\r\n */\r\n\r\nimport type { Deck, Card } from '@shared/types';\r\nimport type { NewDeck, NewCard, UpdateDeck } from '../repositories';\r\n\r\nfunction uuid(): string {\r\n  try {\r\n    const anyCrypto = (globalThis as any).crypto;\r\n    if (anyCrypto && typeof anyCrypto.randomUUID === 'function') {\r\n      return anyCrypto.randomUUID();\r\n    }\r\n  } catch {}\r\n  // Fallback\r\n  return 'id_' + Math.random().toString(36).slice(2, 10);\r\n}\r\n\r\n/**\r\n * Build repository NewDeck payload from domain Deck inputs (without id/timestamps).\r\n */\r\nexport function buildNewDeckFromDomain(deck: Omit<Deck, 'id' | 'createdAt' | 'updatedAt'>): NewDeck {\r\n  return {\r\n    deckId: uuid(),\r\n    name: deck.title,\r\n    description: deck.description,\r\n    meta: {\r\n      userId: deck.userId,\r\n      tags: deck.tags ?? [],\r\n      category: deck.category ?? null,\r\n      settings: deck.settings ?? null,\r\n      advancedSettings: deck.advancedSettings ?? null,\r\n      isPublic: deck.isPublic ?? false,\r\n    },\r\n  };\r\n}\r\n\r\n/**\r\n * Build repository NewCard payload from a domain Card-like shape.\r\n * Note: media hashing/dedup is handled elsewhere; we only propagate known references.\r\n */\r\nexport function buildNewCardFromDomain(input: {\r\n  deckId: string;\r\n  frontContent: string;\r\n  backContent: string;\r\n  // Optional hints to carry over to repo layer:\r\n  mediaRefs?: Card['mediaRefs'];\r\n  state?: Card['state'];\r\n  easeFactor?: number;\r\n  intervalDays?: number;\r\n}): NewCard {\r\n  const allowed = new Set(['new', 'learning', 'review', 'relearning'] as const);\r\n  const normalizedState =\r\n    allowed.has(input.state as any)\r\n      ? (input.state as 'new' | 'learning' | 'review' | 'relearning')\r\n      : 'new';\r\n\r\n  return {\r\n    cardId: uuid(),\r\n    deckId: input.deckId,\r\n    fields: {\r\n      front: input.frontContent,\r\n      back: input.backContent,\r\n    },\r\n    // If we don't have media hashes yet, we leave refs empty; upstream pipeline can attach later.\r\n    mediaRefs: (input.mediaRefs ?? []).map((m) => m.id).filter(Boolean),\r\n    state: normalizedState,\r\n    ease: input.easeFactor ?? 250,\r\n    interval: input.intervalDays ?? 0,\r\n    dueAt: null,\r\n    lapses: 0,\r\n  };\r\n}\r\n\r\n/**\r\n * Map domain Deck partial updates to repository UpdateDeck.\r\n */\r\nexport function mapDeckUpdatesToRepo(updates: Partial<Deck>): UpdateDeck {\r\n  const result: UpdateDeck = {};\r\n  if (typeof updates.title === 'string') result.name = updates.title;\r\n  if (typeof updates.description === 'string') result.description = updates.description;\r\n  const meta: Record<string, unknown> = {};\r\n  if (updates.tags) meta.tags = updates.tags;\r\n  if (updates.category) meta.category = updates.category;\r\n  if (updates.settings) meta.settings = updates.settings;\r\n  if (updates.advancedSettings) meta.advancedSettings = updates.advancedSettings;\r\n  if (Object.keys(meta).length) result.meta = meta;\r\n  return result;\r\n}","import { create } from 'zustand'\nimport { persist } from 'zustand/middleware'\nimport type { Deck, Card, DeckSettings } from '../../../shared/types'\nimport { createNewCard } from '../utils/cardDefaults'\n\nimport { repos } from '../data'\nimport { buildNewDeckFromDomain, buildNewCardFromDomain, mapDeckUpdatesToRepo } from '../data/mappers/domainMappers'\ninterface StudySession {\n  deckId: string\n  currentCardIndex: number\n  studyCards: Card[] // For in-memory access during a session\n  studyCardIds: string[] // For persistence\n  sessionStats: {\n    total: number\n    correct: number\n    incorrect: number\n  }\n  startedAt: string\n}\n\ninterface DeckStore {\n  decks: Deck[]\n  cards: Record<string, Card[]> // deckId -> cards\n  currentStudySession: StudySession | null\n  isLoading: boolean\n  error: string | null\n  importProgress: number // 0-100\n  importStatus: string | null\n  \n  // Deck operations\n  createDeck: (deck: Omit<Deck, 'id' | 'createdAt' | 'updatedAt'>) => Promise<Deck>\n  updateDeck: (id: string, updates: Partial<Deck>) => Promise<void>\n  deleteDeck: (id: string) => Promise<void>\n  getDeck: (id: string) => Deck | undefined\n  \n  // Card operations\n  addCard: (deckId: string, card: Omit<Card, 'id' | 'deckId' | 'createdAt' | 'easeFactor' | 'intervalDays' | 'nextReview' | 'reviewCount' | 'lapseCount'>) => Promise<Card>\n  addCardBulk: (deckId: string, card: Omit<Card, 'id' | 'deckId' | 'createdAt' | 'easeFactor' | 'intervalDays' | 'nextReview' | 'reviewCount' | 'lapseCount'>) => Promise<Card>\n  addCardsBatch: (deckId: string, cards: Array<Omit<Card, 'id' | 'deckId' | 'createdAt' | 'easeFactor' | 'intervalDays' | 'nextReview' | 'reviewCount' | 'lapseCount'>>) => Promise<Card[]>\n  createDeckBulk: (deck: Omit<Deck, 'id' | 'createdAt' | 'updatedAt'>) => Promise<Deck>\n  updateCard: (cardId: string, updates: Partial<Card>) => Promise<void>\n  deleteCard: (cardId: string) => Promise<void>\n  getCards: (deckId: string) => Card[]\n  \n  // Import operations\n  importAnkiDeck: (file: File) => Promise<Deck>\n  importFromText: (deckName: string, text: string, separator?: string) => Promise<Deck>\n  \n  // Example data\n  loadExampleDecks: () => Promise<void>\n  \n  // Utility\n  clearError: () => void\n  setLoading: (loading: boolean) => void\n  setImportProgress: (progress: number, status?: string) => void\n  resetImportProgress: () => void\n  removeDuplicateCards: (deckId: string) => Promise<number>\n  \n  // Study session functions\n  startStudySession: (deckId: string, studyCards: Card[]) => void\n  updateStudySession: (currentCardIndex: number, sessionStats: StudySession['sessionStats']) => void\n  clearStudySession: () => void\n  getStudySession: (deckId: string) => StudySession | null\n  resetAllStudyData: () => void\n}\n\nconst defaultDeckSettings: DeckSettings = {\n  newCardsPerDay: 20,\n  maxReviewsPerDay: 100,\n  easyBonus: 1.3,\n  intervalModifier: 1.0,\n  maximumInterval: 36500, // 100 years\n  minimumInterval: 1\n};\n\n// Offline-first persistence helpers (IndexedDB via repositories)\nasync function persistCreateDeck(deckData: Omit<Deck, 'id' | 'createdAt' | 'updatedAt'>) {\n  try {\n    await repos.decks.create(buildNewDeckFromDomain(deckData));\n  } catch (err) {\n    // Non-blocking persistence; UI state remains responsive\n    console.warn('[deckStore] repo createDeck failed', err);\n  }\n}\n\nasync function persistAddCard(deckId: string, card: Card) {\n  try {\n    await repos.cards.create(\n      buildNewCardFromDomain({\n        deckId,\n        frontContent: card.frontContent,\n        backContent: card.backContent,\n        mediaRefs: card.mediaRefs,\n        state: card.state,\n        easeFactor: card.easeFactor,\n        intervalDays: card.intervalDays,\n      })\n    );\n  } catch (err) {\n    console.warn('[deckStore] repo addCard failed', err);\n  }\n}\n\n// Helper function to clean field content\nconst cleanFieldContent = (content: string): string => {\n  return content\n    .replace(/<[^>]*>/g, '') // Remove HTML tags\n    .replace(/&nbsp;/g, ' ')\n    .replace(/&lt;/g, '<')\n    .replace(/&gt;/g, '>')\n    .replace(/&amp;/g, '&')\n    .replace(/\\[sound:[^\\]]*\\]/g, '') // Remove sound references\n    .trim()\n}\n\n// Helper function to detect the best field combination for front/back\nconst detectBestFieldCombination = (sampleFields: string[][]): { frontIndex: number; backIndex: number } => {\n  if (sampleFields.length === 0) {\n    return { frontIndex: 0, backIndex: 1 }\n  }\n  \n  const fieldCount = sampleFields[0].length\n  const combinations: Array<{ frontIndex: number; backIndex: number; score: number }> = []\n  \n  // Try different field combinations\n  for (let front = 0; front < fieldCount; front++) {\n    for (let back = front + 1; back < fieldCount; back++) {\n      let score = 0\n      let validPairs = 0\n      \n      for (const fields of sampleFields) {\n        const frontContent = cleanFieldContent(fields[front] || '')\n        const backContent = cleanFieldContent(fields[back] || '')\n        \n        // Score based on content quality\n        if (frontContent && backContent) {\n          validPairs++\n          \n          // Prefer combinations where both fields have substantial content\n          if (frontContent.length > 2 && backContent.length > 2) {\n            score += 10\n          }\n          \n          // Prefer combinations where fields are different\n          if (frontContent !== backContent) {\n            score += 5\n          }\n          \n          // Avoid fields that look like audio references or numbers only\n          if (!frontContent.match(/^\\[sound:/) && !backContent.match(/^\\[sound:/)) {\n            score += 3\n          }\n          \n          if (!frontContent.match(/^\\d+$/) && !backContent.match(/^\\d+$/)) {\n            score += 2\n          }\n        }\n      }\n      \n      // Normalize score by number of valid pairs\n      const normalizedScore = validPairs > 0 ? score / validPairs : 0\n      combinations.push({ frontIndex: front, backIndex: back, score: normalizedScore })\n    }\n  }\n  \n  // Sort by score and return the best combination\n  combinations.sort((a, b) => b.score - a.score)\n  \n  if (combinations.length > 0 && combinations[0].score > 0) {\n    console.log(`Best field combination: ${combinations[0].frontIndex} -> ${combinations[0].backIndex} (score: ${combinations[0].score})`)\n    return { frontIndex: combinations[0].frontIndex, backIndex: combinations[0].backIndex }\n  }\n  \n  // Fallback to 0->1 or 0->2 if available\n  if (fieldCount >= 3) {\n    return { frontIndex: 0, backIndex: 2 }\n  }\n  return { frontIndex: 0, backIndex: 1 }\n}\n\n// Helper function to parse .apkg files (with dynamic imports for bundle optimization)\nconst parseApkgFile = async (file: File): Promise<{ name: string; cards: Array<{ front: string; back: string }> }> => {\n  try {\n    // Dynamic imports to reduce initial bundle size\n    const [{ default: JSZip }, { default: initSqlJs }] = await Promise.all([\n      import('jszip'),\n      import('sql.js')\n    ])\n\n    // Initialize SQL.js\n    const SQL = await initSqlJs({\n      locateFile: (file) => {\n        if (file.endsWith('.wasm')) {\n          return '/sql-wasm.wasm'\n        }\n        return `/${file}`\n      }\n    })\n\n    // Read the .apkg file as array buffer\n    const arrayBuffer = await file.arrayBuffer()\n    \n    // Extract the ZIP file\n    const zip = new JSZip()\n    const zipContent = await zip.loadAsync(arrayBuffer)\n    \n    // Get the collection.anki2 file (SQLite database)\n    const dbFile = zipContent.file('collection.anki2')\n    if (!dbFile) {\n      throw new Error('Invalid .apkg file: collection.anki2 not found')\n    }\n    \n    // Read the database file\n    const dbArrayBuffer = await dbFile.async('arraybuffer')\n    const db = new SQL.Database(new Uint8Array(dbArrayBuffer))\n    \n    // Query to get deck name from the col table\n    const deckQuery = db.exec(\"SELECT decks FROM col LIMIT 1\")\n    let deckName = file.name.replace(/\\.apkg$/, '')\n    if (deckQuery.length > 0 && deckQuery[0].values.length > 0) {\n      try {\n        const decksJson = deckQuery[0].values[0][0] as string\n        const decks = JSON.parse(decksJson)\n        // Find the first non-default deck (id != 1)\n        const deckIds = Object.keys(decks).filter(id => id !== '1')\n        if (deckIds.length > 0) {\n          deckName = decks[deckIds[0]].name || deckName\n        }\n      } catch (e) {\n        console.warn('Could not parse deck names from .apkg file, using filename')\n      }\n    }\n    \n    // Query to get notes and cards\n    const notesQuery = db.exec(`\n      SELECT n.flds, n.tags, c.type\n      FROM notes n\n      JOIN cards c ON n.id = c.nid\n      WHERE c.type >= 0\n      ORDER BY n.id\n    `)\n    \n    const cards: Array<{ front: string; back: string }> = []\n    \n    if (notesQuery.length > 0) {\n      // First, analyze a sample of fields to determine the best field combination\n      const sampleSize = Math.min(10, notesQuery[0].values.length)\n      const sampleFields: string[][] = []\n      \n      for (let i = 0; i < sampleSize; i++) {\n        const fields = (notesQuery[0].values[i][0] as string).split('\\x1f')\n        sampleFields.push(fields)\n      }\n      \n      // Detect the best field combination\n      const { frontIndex, backIndex } = detectBestFieldCombination(sampleFields)\n      console.log(`Using field combination: ${frontIndex} (front) -> ${backIndex} (back)`)\n      \n      // Process all cards using the detected field combination\n      for (const row of notesQuery[0].values) {\n        const fields = (row[0] as string).split('\\x1f') // Anki uses \\x1f as field separator\n        \n        if (fields.length > Math.max(frontIndex, backIndex)) {\n          const front = cleanFieldContent(fields[frontIndex] || '')\n          const back = cleanFieldContent(fields[backIndex] || '')\n          \n          if (front && back && front !== back) {\n            cards.push({ front, back })\n          }\n        }\n      }\n    }\n    \n    db.close()\n    \n    if (cards.length === 0) {\n      throw new Error('No valid cards found in the .apkg file')\n    }\n    \n    console.log(`Successfully parsed ${cards.length} cards from .apkg file`)\n    return { name: deckName, cards }\n  } catch (error) {\n    console.error('Error parsing .apkg file:', error)\n    throw new Error(`Failed to parse .apkg file: ${error instanceof Error ? error.message : 'Unknown error'}`)\n  }\n}\n\nexport const useDeckStore = create<DeckStore>()(\n  persist(\n    (set, get) => ({\n      decks: [],\n      cards: {},\n      currentStudySession: null,\n      isLoading: false,\n      error: null,\n      importProgress: 0,\n      importStatus: null,\n\n      createDeck: async (deckData) => {\n        set({ isLoading: true, error: null })\n        try {\n          const deck: Deck = {\n            ...deckData,\n            id: crypto.randomUUID(),\n            createdAt: new Date().toISOString(),\n            updatedAt: new Date().toISOString(),\n            settings: { ...defaultDeckSettings, ...deckData.settings }\n          }\n          \n          set(state => ({\n            decks: [...state.decks, deck],\n            cards: { ...state.cards, [deck.id]: [] },\n            isLoading: false\n          }))\n\n          // Persist to IndexedDB (non-blocking)\n          void persistCreateDeck(deckData);\n          \n          return deck\n        } catch (error) {\n          set({ error: 'Failed to create deck', isLoading: false })\n          throw error\n        }\n      },\n\n      updateDeck: async (id, updates) => {\n        set({ isLoading: true, error: null })\n        try {\n          set(state => ({\n            decks: state.decks.map(deck =>\n              deck.id === id\n                ? { ...deck, ...updates, updatedAt: new Date().toISOString() }\n                : deck\n            ),\n            isLoading: false\n          }))\n\n          // Persist deck updates (non-blocking)\n          try {\n            void repos.decks.update(id, mapDeckUpdatesToRepo(updates));\n          } catch (e) {\n            console.warn('[deckStore] repo updateDeck failed', e);\n          }\n        } catch (error) {\n          set({ error: 'Failed to update deck', isLoading: false })\n          throw error\n        }\n      },\n\n      deleteDeck: async (id) => {\n        set({ isLoading: true, error: null })\n        try {\n          set(state => {\n            // eslint-disable-next-line @typescript-eslint/no-unused-vars\n            const { [id]: _deletedCards, ...remainingCards } = state.cards\n            return {\n              decks: state.decks.filter(deck => deck.id !== id),\n              cards: remainingCards,\n              isLoading: false\n            }\n          })\n          // Persist delete (non-blocking)\n          try {\n            void repos.decks.remove(id)\n          } catch (e) {\n            console.warn('[deckStore] repo deleteDeck failed', e)\n          }\n        } catch (error) {\n          set({ error: 'Failed to delete deck', isLoading: false })\n          throw error\n        }\n      },\n\n      getDeck: (id) => {\n        return get().decks.find(deck => deck.id === id)\n      },\n\n      addCard: async (deckId, cardData) => {\n        set({ isLoading: true, error: null })\n        try {\n          const card: Card = {\n            ...cardData,\n            id: crypto.randomUUID(),\n            deckId,\n            createdAt: new Date().toISOString(),\n            easeFactor: 2.5,\n            intervalDays: 0,\n            nextReview: new Date().toISOString(),\n            reviewCount: 0,\n            lapseCount: 0\n          }\n          \n          set(state => {\n            const deckCards = state.cards[deckId] || []\n            const updatedCards = [...deckCards, card]\n            \n            return {\n              cards: { ...state.cards, [deckId]: updatedCards },\n              decks: state.decks.map(deck =>\n                deck.id === deckId\n                  ? { ...deck, cardCount: updatedCards.length, updatedAt: new Date().toISOString() }\n                  : deck\n              ),\n              isLoading: false\n            }\n          })\n\n          // Persist to IndexedDB (non-blocking)\n          void persistAddCard(deckId, card);\n          \n          return card\n        } catch (error) {\n          set({ error: 'Failed to add card', isLoading: false })\n          throw error\n        }\n      },\n\n      addCardBulk: async (deckId, cardData) => {\n        try {\n          const state = get()\n          const existingCards = state.cards[deckId] || []\n          \n          // Check if this card already exists\n          const cardKey = `${cardData.frontContent.trim().toLowerCase()}|${cardData.backContent.trim().toLowerCase()}`\n          const isDuplicate = existingCards.some(card =>\n            `${card.frontContent.trim().toLowerCase()}|${card.backContent.trim().toLowerCase()}` === cardKey\n          )\n          \n          if (isDuplicate) {\n            console.log('Skipping duplicate card:', cardData.frontContent)\n            // Return a dummy card to maintain the interface, but don't add it\n            return {\n              ...cardData,\n              id: 'duplicate-skipped',\n              deckId,\n              createdAt: new Date().toISOString(),\n              easeFactor: 2.5,\n              intervalDays: 0,\n              nextReview: new Date().toISOString(),\n              reviewCount: 0,\n              lapseCount: 0\n            }\n          }\n          \n          const card: Card = {\n            ...cardData,\n            id: crypto.randomUUID(),\n            deckId,\n            createdAt: new Date().toISOString(),\n            easeFactor: 2.5,\n            intervalDays: 0,\n            nextReview: new Date().toISOString(),\n            reviewCount: 0,\n            lapseCount: 0\n          }\n          \n          set(state => {\n            const deckCards = state.cards[deckId] || []\n            const updatedCards = [...deckCards, card]\n            \n            return {\n              cards: { ...state.cards, [deckId]: updatedCards },\n              decks: state.decks.map(deck =>\n                deck.id === deckId\n                  ? { ...deck, cardCount: updatedCards.length, updatedAt: new Date().toISOString() }\n                  : deck\n              )\n            }\n          })\n\n          // Persist to IndexedDB (non-blocking) if not a skipped duplicate\n          if (card.id !== 'duplicate-skipped') {\n            void persistAddCard(deckId, card)\n          }\n          \n          return card\n        } catch (error) {\n          console.error('Failed to add card during bulk import:', error)\n          throw error\n        }\n      },\n\n      createDeckBulk: async (deckData) => {\n        try {\n          const deck: Deck = {\n            ...deckData,\n            id: crypto.randomUUID(),\n            createdAt: new Date().toISOString(),\n            updatedAt: new Date().toISOString(),\n            settings: { ...defaultDeckSettings, ...deckData.settings }\n          }\n          \n          set(state => ({\n            decks: [...state.decks, deck],\n            cards: { ...state.cards, [deck.id]: [] }\n          }))\n\n          // Persist to IndexedDB (non-blocking)\n          void persistCreateDeck(deckData);\n          \n          return deck\n        } catch (error) {\n          console.error('Failed to create deck during bulk import:', error)\n          throw error\n        }\n      },\n\n      addCardsBatch: async (deckId, cardsData) => {\n        try {\n          const state = get()\n          const existingCards = state.cards[deckId] || []\n          \n          // Create a Set of existing card content for fast lookup\n          const existingCardSet = new Set(\n            existingCards.map(card => `${card.frontContent.trim().toLowerCase()}|${card.backContent.trim().toLowerCase()}`)\n          )\n          \n          // Filter out duplicates and create new cards\n          const uniqueCardsData = cardsData.filter(cardData => {\n            const cardKey = `${cardData.frontContent.trim().toLowerCase()}|${cardData.backContent.trim().toLowerCase()}`\n            return !existingCardSet.has(cardKey)\n          })\n          \n          console.log(`Batch processing: ${cardsData.length} cards submitted, ${uniqueCardsData.length} unique cards to add`)\n          \n          if (uniqueCardsData.length === 0) {\n            console.log('No new unique cards to add in this batch')\n            return []\n          }\n          \n          const cards: Card[] = uniqueCardsData.map(cardData => ({\n            ...cardData,\n            id: crypto.randomUUID(),\n            deckId,\n            createdAt: new Date().toISOString(),\n            easeFactor: 2.5,\n            intervalDays: 0,\n            nextReview: new Date().toISOString(),\n            reviewCount: 0,\n            lapseCount: 0\n          }))\n          \n          set(state => {\n            const deckCards = state.cards[deckId] || []\n            const updatedCards = [...deckCards, ...cards]\n            \n            return {\n              cards: { ...state.cards, [deckId]: updatedCards },\n              decks: state.decks.map(deck =>\n                deck.id === deckId\n                  ? { ...deck, cardCount: updatedCards.length, updatedAt: new Date().toISOString() }\n                  : deck\n              )\n            }\n          })\n          \n          // Persist each card (non-blocking)\n          for (const c of cards) {\n            void persistAddCard(deckId, c)\n          }\n\n          return cards\n        } catch (error) {\n          console.error('Failed to add cards during batch import:', error)\n          throw error\n        }\n      },\n\n      updateCard: async (cardId, updates) => {\n        set({ isLoading: true, error: null })\n        try {\n          set(state => {\n            const newCards = { ...state.cards }\n            for (const deckId in newCards) {\n              newCards[deckId] = newCards[deckId].map(card =>\n                card.id === cardId ? { ...card, ...updates } : card\n              )\n            }\n            return { cards: newCards, isLoading: false }\n          })\n        } catch (error) {\n          set({ error: 'Failed to update card', isLoading: false })\n          throw error\n        }\n      },\n\n      deleteCard: async (cardId) => {\n        set({ isLoading: true, error: null })\n        try {\n          let affectedDeckId = ''\n          set(state => {\n            const newCards = { ...state.cards }\n            for (const deckId in newCards) {\n              const cardIndex = newCards[deckId].findIndex(card => card.id === cardId)\n              if (cardIndex !== -1) {\n                newCards[deckId] = newCards[deckId].filter(card => card.id !== cardId)\n                affectedDeckId = deckId\n                break\n              }\n            }\n            \n            return {\n              cards: newCards,\n              decks: state.decks.map(deck =>\n                deck.id === affectedDeckId\n                  ? { ...deck, cardCount: newCards[affectedDeckId].length, updatedAt: new Date().toISOString() }\n                  : deck\n              ),\n              isLoading: false\n            }\n          })\n          // Persist delete (non-blocking)\n          try {\n            void repos.cards.remove(cardId)\n          } catch (e) {\n            console.warn('[deckStore] repo deleteCard failed', e)\n          }\n        } catch (error) {\n          set({ error: 'Failed to delete card', isLoading: false })\n          throw error\n        }\n      },\n\n      getCards: (deckId) => {\n        return get().cards[deckId] || []\n      },\n\n      importAnkiDeck: async (file) => {\n        const { setImportProgress, resetImportProgress } = get()\n        set({ isLoading: true, error: null })\n        resetImportProgress()\n        \n        try {\n          const fileName = file.name.toLowerCase()\n          \n          // Handle different file types\n          if (fileName.endsWith('.apkg')) {\n            setImportProgress(10, 'Reading file...')\n            \n            // Parse .apkg file using the new parser\n            const { name, cards } = await parseApkgFile(file)\n\n            // Check if deck with the same name already exists\n            const existingDeck = get().decks.find(d => d.title === name);\n            if (existingDeck) {\n              throw new Error(`A deck named \"${name}\" already exists. Please rename the deck or the file before importing.`);\n            }\n            \n            setImportProgress(30, 'Creating deck...')\n            \n            // Create deck\n            const deck = await get().createDeckBulk({\n              userId: 'current-user',\n              title: name,\n              description: `Imported Anki deck with ${cards.length} cards`,\n              cardCount: 0,\n              isPublic: false,\n              settings: defaultDeckSettings,\n              category: 'imported'\n            })\n            \n            setImportProgress(40, `Importing ${cards.length} cards...`)\n            \n            // Remove duplicates from cards before batch processing\n            const uniqueCards: typeof cards = []\n            const seenCards = new Set<string>()\n            \n            for (const card of cards) {\n              const cardKey = `${card.front.trim().toLowerCase()}|${card.back.trim().toLowerCase()}`\n              if (!seenCards.has(cardKey)) {\n                seenCards.add(cardKey)\n                uniqueCards.push(card)\n              }\n            }\n            \n            console.log(`Removed ${cards.length - uniqueCards.length} duplicates from Anki cards. Processing ${uniqueCards.length} unique cards.`)\n            \n            // Process unique cards in smaller batches for better performance and reliability\n            const batchSize = 100\n            let successfulImports = 0\n            const totalCards = uniqueCards.length\n            \n            console.log(`Starting batch import of ${totalCards} unique cards`)\n            \n            for (let i = 0; i < totalCards; i += batchSize) {\n              const batch = uniqueCards.slice(i, i + batchSize)\n              const batchCards = batch.map(cardData => createNewCard(\n                cardData.front,\n                cardData.back,\n                { type: 'basic' as const },\n                []\n              ))\n              \n              try {\n                console.log(`Processing batch ${Math.floor(i / batchSize) + 1}/${Math.ceil(totalCards / batchSize)} (${batch.length} cards)`)\n                await get().addCardsBatch(deck.id, batchCards)\n                successfulImports += batch.length\n                \n                // Update progress (40% to 90% for card import)\n                const cardProgress = 40 + (50 * Math.min(i + batchSize, totalCards) / totalCards)\n                setImportProgress(cardProgress, `Imported ${successfulImports}/${totalCards} cards...`)\n                \n                console.log(`Batch completed. Progress: ${cardProgress.toFixed(1)}%`)\n                \n                // Add small delay to allow UI updates\n                await new Promise(resolve => setTimeout(resolve, 50))\n              } catch (cardError) {\n                console.error('Failed to import batch:', cardError)\n                // Try individual cards in this batch as fallback\n                for (const originalCard of batch) {\n                  try {\n                    await get().addCardBulk(deck.id, createNewCard(\n                      originalCard.front,\n                      originalCard.back,\n                      { type: 'basic' as const },\n                      []\n                    ))\n                    successfulImports++\n                  } catch (individualError) {\n                    console.warn('Failed to import individual card:', originalCard, individualError)\n                  }\n                }\n                \n                // Update progress even after fallback\n                const cardProgress = 40 + (50 * Math.min(i + batchSize, totalCards) / totalCards)\n                setImportProgress(cardProgress, `Imported ${successfulImports}/${totalCards} cards...`)\n              }\n            }\n            \n            console.log(`Batch import completed. Total successful: ${successfulImports}`)\n            \n            setImportProgress(95, 'Finalizing import...')\n            \n            // Update deck description with final count\n            await get().updateDeck(deck.id, {\n              description: `Imported Anki deck with ${successfulImports} cards`\n            })\n            \n            setImportProgress(100, 'Import completed!')\n            \n            // Clear progress after a short delay\n            setTimeout(() => {\n              resetImportProgress()\n            }, 1000)\n            \n            set({ isLoading: false })\n            return deck\n          } else if (fileName.endsWith('.txt') || fileName.endsWith('.tsv') || fileName.endsWith('.csv')) {\n            setImportProgress(10, 'Reading text file...')\n            \n            // Handle text-based imports\n            const text = await file.text()\n            \n            // Detect separator\n            let separator = '\\t' // Corrected: \t is a tab character\n            if (fileName.endsWith('.csv')) {\n              separator = ','\n            }\n            \n            setImportProgress(20, 'Processing text content...')\n            \n            // Clean the text and handle encoding issues\n            const cleanText = text\n              .replace(/\\r\\n/g, '\\n')  // Normalize line endings\n              .replace(/\\r/g, '\\n')    // Handle old Mac line endings\n              .trim()\n            \n            const deck = await get().importFromText(\n              file.name.replace(/\\.[^/.]+$/, \"\"),\n              cleanText,\n              separator\n            )\n            set({ isLoading: false })\n            return deck\n          } else {\n            setImportProgress(10, 'Reading file as text...')\n            \n            // Try to parse as text anyway\n            const text = await file.text()\n            \n            setImportProgress(20, 'Processing content...')\n            \n            const cleanText = text\n              .replace(/\\r\\n/g, '\\n')\n              .replace(/\\r/g, '\\n')\n              .trim()\n            \n            const deck = await get().importFromText(\n              file.name.replace(/\\.[^/.]+$/, \"\"),\n              cleanText,\n              '\\t'\n            )\n            set({ isLoading: false })\n            return deck\n          }\n        } catch (error) {\n          const errorMessage = error instanceof Error ? error.message : 'Failed to import Anki deck'\n          set({ error: errorMessage, isLoading: false })\n          resetImportProgress()\n          throw error\n        }\n      },\n\n      importFromText: async (deckName, text, separator = '\\t') => {\n        const { setImportProgress, resetImportProgress } = get()\n        set({ isLoading: true, error: null })\n        \n        try {\n          setImportProgress(30, 'Processing text content...')\n          \n          // Clean and normalize the text\n          const cleanText = text\n            .replace(/\\r\\n/g, '\\n')  // Normalize Windows line endings\n            .replace(/\\r/g, '\\n')    // Handle old Mac line endings\n            .replace(/\\\\u0000/g, '')  // Remove null characters\n            .replace(/[\\\\u0001-\\\\u0008\\\\u000B\\\\u000C\\\\u000E-\\\\u001F\\\\u007F]/g, '') // Remove control characters\n            .trim()\n          \n          const lines = cleanText\n            .split('\\n')\n            .map(line => line.trim())\n            .filter(line => line.length > 0)\n          \n          if (lines.length === 0) {\n            throw new Error('No valid content found in the file')\n          }\n          \n          setImportProgress(40, 'Creating deck...')\n          \n          const deck = await get().createDeckBulk({\n            userId: 'current-user', // This would come from auth store\n            title: deckName,\n            description: `Imported deck with ${lines.length} cards`,\n            cardCount: 0,\n            isPublic: false,\n            settings: defaultDeckSettings,\n            category: 'imported'\n          })\n          \n          setImportProgress(50, `Importing ${lines.length} cards...`)\n          \n          // Process lines and prepare cards for batch import\n          const validCards: Array<Omit<Card, 'id' | 'createdAt' | 'deckId' | 'easeFactor' | 'intervalDays' | 'nextReview' | 'reviewCount' | 'lapseCount'>> = []\n          let skippedLines = 0\n          \n          // First pass: parse and validate all lines\n          for (let i = 0; i < lines.length; i++) {\n            const line = lines[i]\n            try {\n              // Handle quoted fields (CSV style)\n              let parts: string[]\n              if (separator === ',' && line.includes('\"')) {\n                // Simple CSV parsing for quoted fields\n                parts = line.split(',').map(part =>\n                  part.replace(/^\"(.*)\"$/, '$1').trim()\n                )\n              } else {\n                parts = line.split(separator)\n              }\n              \n              if (parts.length >= 2) {\n                const front = parts[0].trim()\n                const back = parts[1].trim()\n                \n                // Skip empty cards\n                if (front && back) {\n                  validCards.push(createNewCard(\n                    front,\n                    back,\n                    { type: 'basic' as const },\n                    []\n                  ))\n                } else {\n                  skippedLines++\n                }\n              } else {\n                skippedLines++\n              }\n            } catch (cardError) {\n              console.warn('Failed to parse line:', line, cardError)\n              skippedLines++\n            }\n          }\n          \n          // Remove duplicates from validCards before batch processing\n          const uniqueValidCards: typeof validCards = []\n          const seenCards = new Set<string>()\n          \n          for (const card of validCards) {\n            const cardKey = `${card.frontContent.trim().toLowerCase()}|${card.backContent.trim().toLowerCase()}`\n            if (!seenCards.has(cardKey)) {\n              seenCards.add(cardKey)\n              uniqueValidCards.push(card)\n            }\n          }\n          \n          console.log(`Removed ${validCards.length - uniqueValidCards.length} duplicates from parsed cards. Processing ${uniqueValidCards.length} unique cards.`)\n          \n          // Second pass: batch import unique cards\n          const batchSize = 100\n          let successfulImports = 0\n          \n          console.log(`Starting text import batch processing of ${uniqueValidCards.length} unique cards`)\n          \n          for (let i = 0; i < uniqueValidCards.length; i += batchSize) {\n            const batch = uniqueValidCards.slice(i, i + batchSize)\n            \n            try {\n              console.log(`Processing text batch ${Math.floor(i / batchSize) + 1}/${Math.ceil(uniqueValidCards.length / batchSize)} (${batch.length} cards)`)\n              const addedCards = await get().addCardsBatch(deck.id, batch)\n              successfulImports += addedCards.length\n              \n              // Update progress (50% to 90% for card import)\n              const cardProgress = 50 + (40 * Math.min(i + batchSize, uniqueValidCards.length) / uniqueValidCards.length)\n              setImportProgress(cardProgress, `Imported ${successfulImports}/${uniqueValidCards.length} cards...`)\n              \n              console.log(`Text batch completed. Progress: ${cardProgress.toFixed(1)}%, Added: ${addedCards.length} cards`)\n              \n              // Add small delay to allow UI updates\n              await new Promise(resolve => setTimeout(resolve, 50))\n            } catch (cardError) {\n              console.error('Failed to import text batch:', cardError)\n              // Try individual cards in this batch as fallback\n              for (const cardData of batch) {\n                try {\n                  const addedCard = await get().addCardBulk(deck.id, cardData)\n                  if (addedCard.id !== 'duplicate-skipped') {\n                    successfulImports++\n                  }\n                } catch (individualError) {\n                  console.warn('Failed to import individual text card:', cardData, individualError)\n                }\n              }\n              \n              // Update progress even after fallback\n              const cardProgress = 50 + (40 * Math.min(i + batchSize, uniqueValidCards.length) / uniqueValidCards.length)\n              setImportProgress(cardProgress, `Imported ${successfulImports}/${uniqueValidCards.length} cards...`)\n            }\n          }\n          \n          console.log(`Text import batch processing completed. Total successful: ${successfulImports}`)\n          \n          setImportProgress(95, 'Finalizing import...')\n          \n          // Update deck description with import results\n          await get().updateDeck(deck.id, {\n            description: `Imported deck with ${successfulImports} cards${skippedLines > 0 ? ` (${skippedLines} lines skipped)` : ''}`\n          })\n          \n          if (successfulImports === 0) {\n            throw new Error('No valid cards could be imported. Please check the file format.')\n          }\n          \n          setImportProgress(100, 'Import completed!')\n          \n          // Clear progress after a short delay\n          setTimeout(() => {\n            resetImportProgress()\n          }, 1000)\n          \n          set({ isLoading: false })\n          return deck\n        } catch (error) {\n          set({ error: 'Failed to import from text', isLoading: false })\n          resetImportProgress()\n          throw error\n        }\n      },\n\n      loadExampleDecks: async () => {\n        set({ isLoading: true, error: null })\n        try {\n          const state = get()\n          \n          // Check if example decks already exist to prevent duplicates\n          const existingTitles = new Set(state.decks.map(deck => deck.title))\n          const exampleTitles = ['Spanish Vocabulary', 'JavaScript Concepts', 'World Capitals']\n          \n          // If any example deck already exists, don't load any\n          if (exampleTitles.some(title => existingTitles.has(title))) {\n            console.log('Example decks already exist, skipping load')\n            set({ isLoading: false })\n            return\n          }\n\n          const exampleDecks = [\n            {\n              title: 'Spanish Vocabulary',\n              description: 'Essential Spanish words for beginners',\n              category: 'language',\n              cards: [\n                { front: 'Hello', back: 'Hola' },\n                { front: 'Goodbye', back: 'Adis' },\n                { front: 'Thank you', back: 'Gracias' },\n                { front: 'Please', back: 'Por favor' },\n                { front: 'Yes', back: 'S' },\n                { front: 'No', back: 'No' },\n                { front: 'Water', back: 'Agua' },\n                { front: 'Food', back: 'Comida' },\n                { front: 'House', back: 'Casa' },\n                { front: 'Car', back: 'Coche' }\n              ]\n            },\n            {\n              title: 'JavaScript Concepts',\n              description: 'Important JavaScript programming concepts',\n              category: 'programming',\n              cards: [\n                { front: 'What is a closure?', back: 'A closure is a function that has access to variables in its outer (enclosing) scope even after the outer function has returned.' },\n                { front: 'What is hoisting?', back: 'Hoisting is JavaScript\\'s default behavior of moving declarations to the top of their scope.' },\n                { front: 'What is the difference between let and var?', back: 'let has block scope and cannot be redeclared, while var has function scope and can be redeclared.' },\n                { front: 'What is a Promise?', back: 'A Promise is an object representing the eventual completion or failure of an asynchronous operation.' },\n                { front: 'What is async/await?', back: 'async/await is syntactic sugar for working with Promises, making asynchronous code look more like synchronous code.' }\n              ]\n            },\n            {\n              title: 'World Capitals',\n              description: 'Capital cities of countries around the world',\n              category: 'geography',\n              cards: [\n                { front: 'France', back: 'Paris' },\n                { front: 'Germany', back: 'Berlin' },\n                { front: 'Italy', back: 'Rome' },\n                { front: 'Spain', back: 'Madrid' },\n                { front: 'United Kingdom', back: 'London' },\n                { front: 'Japan', back: 'Tokyo' },\n                { front: 'China', back: 'Beijing' },\n                { front: 'Australia', back: 'Canberra' },\n                { front: 'Brazil', back: 'Braslia' },\n                { front: 'Canada', back: 'Ottawa' }\n              ]\n            }\n          ]\n\n          console.log('Loading example decks...')\n          for (const deckData of exampleDecks) {\n            const deck = await get().createDeck({\n              userId: 'current-user',\n              title: deckData.title,\n              description: deckData.description,\n              cardCount: 0,\n              isPublic: false,\n              settings: defaultDeckSettings,\n              category: deckData.category,\n              tags: [deckData.category]\n            })\n\n            for (const cardData of deckData.cards) {\n              await get().addCard(deck.id, createNewCard(\n                cardData.front,\n                cardData.back,\n                { type: 'basic' },\n                []\n              ))\n            }\n          }\n\n          console.log('Example decks loaded successfully')\n          set({ isLoading: false })\n        } catch (error) {\n          set({ error: 'Failed to load example decks', isLoading: false })\n          throw error\n        }\n      },\n\n      clearError: () => set({ error: null }),\n      setLoading: (loading) => set({ isLoading: loading }),\n      removeDuplicateCards: async (deckId) => {\n        try {\n          const state = get()\n          const deckCards = state.cards[deckId] || []\n          \n          if (deckCards.length === 0) {\n            return 0\n          }\n          \n          // Create a Map to track unique cards (first occurrence wins)\n          const uniqueCardsMap = new Map<string, Card>()\n          let duplicatesRemoved = 0\n          \n          for (const card of deckCards) {\n            const cardKey = `${card.frontContent.trim().toLowerCase()}|${card.backContent.trim().toLowerCase()}`\n            \n            if (!uniqueCardsMap.has(cardKey)) {\n              uniqueCardsMap.set(cardKey, card)\n            } else {\n              duplicatesRemoved++\n              console.log(`Removing duplicate card: ${card.frontContent}`)\n            }\n          }\n          \n          const uniqueCards = Array.from(uniqueCardsMap.values())\n          \n          if (duplicatesRemoved > 0) {\n            set(state => ({\n              cards: { ...state.cards, [deckId]: uniqueCards },\n              decks: state.decks.map(deck =>\n                deck.id === deckId\n                  ? { ...deck, cardCount: uniqueCards.length, updatedAt: new Date().toISOString() }\n                  : deck\n              )\n            }))\n            \n            console.log(`Removed ${duplicatesRemoved} duplicate cards from deck. ${uniqueCards.length} unique cards remaining.`)\n          }\n          \n          return duplicatesRemoved\n        } catch (error) {\n          console.error('Failed to remove duplicate cards:', error)\n          throw error\n        }\n      },\n\n      setImportProgress: (progress, status) => set({ importProgress: progress, importStatus: status }),\n      resetImportProgress: () => set({ importProgress: 0, importStatus: null }),\n\n      // Study session functions\n            startStudySession: (deckId, studyCards) => {\n        const studyCardIds = studyCards.map(c => c.id);\n        set({\n          currentStudySession: {\n            deckId,\n            currentCardIndex: 0,\n            studyCards, // Keep full cards for in-memory access\n            studyCardIds, // Add the IDs for persistence\n            sessionStats: {\n              total: studyCards.length,\n              correct: 0,\n              incorrect: 0\n            },\n            startedAt: new Date().toISOString()\n          }\n        })\n      },\n\n      updateStudySession: (currentCardIndex, sessionStats) => {\n        set(state => ({\n          currentStudySession: state.currentStudySession ? {\n            ...state.currentStudySession,\n            currentCardIndex,\n            sessionStats\n          } : null\n        }))\n      },\n\n      clearStudySession: () => {\n        set({ currentStudySession: null })\n      },\n\n      getStudySession: (deckId) => {\n        const state = get()\n        return state.currentStudySession?.deckId === deckId ? state.currentStudySession : null\n      },\n\n      resetAllStudyData: () => {\n        // Reset all study-related data but keep decks and cards\n        set(state => {\n          // Reset all card progress data\n          const resetCards: Record<string, Card[]> = {}\n          \n          for (const [deckId, cards] of Object.entries(state.cards)) {\n            resetCards[deckId] = cards.map(card => ({\n              ...card,\n              easeFactor: 2.5,\n              intervalDays: 0,\n              nextReview: new Date().toISOString(),\n              reviewCount: 0,\n              lapseCount: 0\n            }))\n          }\n          \n          return {\n            cards: resetCards,\n            currentStudySession: null\n          }\n        })\n      }\n    }),\n    {\n      name: 'deck-storage',\n      // This function selects which parts of the state to save\n      partialize: (state) => {\n        // 1. Exclude the top-level 'cards' object entirely.\n        // 2. From the 'currentStudySession', exclude the 'studyCards' array of full objects.\n        const { cards, currentStudySession, ...restOfState } = state;\n\n        const sessionToPersist = currentStudySession\n          ? {\n              deckId: currentStudySession.deckId,\n              currentCardIndex: currentStudySession.currentCardIndex,\n              studyCardIds: currentStudySession.studyCardIds, // Only persist the IDs\n              sessionStats: currentStudySession.sessionStats,\n              startedAt: currentStudySession.startedAt,\n            }\n          : null;\n\n        // Return a new object containing only the data we want to persist.\n        // Note: `decks` are preserved via `restOfState`.\n        return { ...restOfState, currentStudySession: sessionToPersist };\n      },\n    }\n  )\n)\n\nexport const useCurrentCard = (): Card | null => {\n  const store = useDeckStore();\n  const session = store.currentStudySession;\n\n  if (!session || !session.studyCardIds || session.studyCardIds.length === 0) {\n    return null;\n  }\n\n  const currentCardId = session.studyCardIds[session.currentCardIndex];\n  if (!currentCardId) {\n    return null;\n  }\n\n  // The full, non-persisted `cards` object holds all cards for the current deck.\n  const deckCards = store.cards[session.deckId] || [];\n  return deckCards.find(card => card.id === currentCardId) || null;\n};"],"file":"assets/stores-DWHkcQm5.js"}