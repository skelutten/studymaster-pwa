{"version":3,"mappings":"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","names":["validationRules","required","message","test","value","trim","length","minLength","min","maxLength","max","email","password","username","noXSS","noSQLInjection","some","pattern","validateField","rules","errors","rule","push","isValid","validateForm","data","results","field","fieldRules","Object","entries","sanitizeInput","input","replace","validationSchemas","signUp","signIn","convertPocketbaseUser","async","pocketbaseUser","debugLogger","log","userId","id","convertedUser","split","level","totalXp","total_xp","coins","gems","createdAt","created","Date","toISOString","lastActive","last_active","preferences","theme","language","notifications","soundEffects","dailyGoal","timezone","error","stack","Error","fallbackUser","validateSignUpInputs","validationResults","validationErrors","filter","_","result","map","join","validateSignInInputs","createPocketBaseUserData","passwordConfirm","handleSignUpError","includes","handleSignInError","isDemoLogin","undefined","performPocketBaseAuth","sanitizedEmail","pb","collection","authWithPassword","emailError","updateUserLastActive","update","updateError","warn","useAuthStore","create","set","get","user","session","isAuthenticated","isLoading","passwordLength","userData","newUser","authData","record","hasToken","token","timeoutId","setTimeout","hasRecord","clearTimeout","signOut","authStore","clear","resetPassword","requestPasswordReset","errorMessage","updatePassword","newPassword","currentState","hasUser","hasSession","errorType","constructor","name","updateProfile","updates","keys","updateData","clearError","initializeAuth","model","info","login","register","logout","updateUser","onChange","timestamp","then","setState","catch","useThemeStore","persist","systemTheme","setTheme","document","documentElement","classList","add","remove","toggleTheme","newTheme","initializeTheme","window","matchMedia","matches","addEventListener","e","newSystemTheme","partialize","state","mockAchievements","description","icon","category","requirements","type","operator","xpReward","coinReward","isSecret","rarity","mockChallenges","title","target","rewards","amount","startDate","endDate","now","isActive","participantCount","itemId","mockLeaderboards","xp_weekly","period","score","rank","change","updatedAt","streak_all_time","calculateLevel","xp","Math","floor","sqrt","calculateXPToNextLevel","pow","getInitialUserStats","totalCards","cardsStudiedToday","cardsStudiedThisWeek","cardsStudiedThisMonth","averageAccuracy","totalStudyTime","studyTimeToday","studyTimeThisWeek","decksCreated","decksCompleted","longestStreak","currentStreak","gold","diamonds","xpToNextLevel","getDemoUserStats","useGamificationStore","userStats","isFirstTimeUser","isInitialized","achievements","userAchievements","userStreak","activeChallenges","userChallengeParticipations","leaderboards","updateUserStats","stats","newStats","addUserAchievement","achievementId","find","ua","toString","earnedAt","updateStreak","streak","joinChallenge","challengeId","p","progress","completed","joinedAt","milestoneProgress","weeklyProgress","bestWeek","updateChallengeProgress","claimChallengeReward","challenge","c","participation","xpGained","_coinsGained","forEach","reward","initializeMockData","lastStudyDate","freezeCount","cards_studied_today","completedAt","milestone_1","cards_studied_week","milestone_2","week","storyUnlocked","initializeNewUser","resetAllUserData","addCurrency","spendCurrency","initializeUserData","isDemo","updateMilestoneProgress","milestoneId","updateWeeklyProgress","weekData","w","updateChallengeStreak","unlockStoryChapter","claimMilestoneReward","contributeToCommunityGoal","goalId","contribution","console","awardStudyXP","cardsStudied","correctAnswers","milestoneBonus","newXP","newLevel","newXPToNextLevel","createNewCard","frontContent","backContent","cardType","mediaRefs","queue","due","ivl","factor","reps","lapses","left","learningStep","graduationInterval","easyInterval","averageAnswerTime","flags","originalDue","originalDeck","xpAwarded","difficultyRating","defaultDeckSettings","newCardsPerDay","maxReviewsPerDay","easyBonus","intervalModifier","maximumInterval","minimumInterval","cleanFieldContent","content","detectBestFieldCombination","sampleFields","frontIndex","backIndex","fieldCount","combinations","front","back","validPairs","fields","match","normalizedScore","sort","a","b","parseApkgFile","file","default","JSZip","initSqlJs","Promise","all","__vitePreload","import","n","j","__VITE_PRELOAD__","s","SQL","locateFile","endsWith","arrayBuffer","zip","dbFile","loadAsync","dbArrayBuffer","db","Database","Uint8Array","deckQuery","exec","deckName","values","decksJson","decks","JSON","parse","deckIds","notesQuery","cards","sampleSize","i","row","close","useDeckStore","currentStudySession","importProgress","importStatus","createDeck","deckData","deck","crypto","randomUUID","settings","updateDeck","deleteDeck","_deletedCards","remainingCards","getDeck","addCard","deckId","cardData","card","easeFactor","intervalDays","nextReview","reviewCount","lapseCount","updatedCards","cardCount","addCardBulk","existingCards","cardKey","toLowerCase","createDeckBulk","addCardsBatch","cardsData","existingCardSet","Set","uniqueCardsData","has","updateCard","cardId","newCards","deleteCard","targetDeckId","findIndex","getCards","importAnkiDeck","setImportProgress","resetImportProgress","fileName","d","isPublic","uniqueCards","seenCards","batchSize","successfulImports","batch","slice","batchCards","ceil","cardProgress","toFixed","resolve","cardError","originalCard","individualError","text","separator","cleanText","importFromText","lines","line","validCards","skippedLines","parts","part","uniqueValidCards","addedCards","loadExampleDecks","existingTitles","exampleDecks","tags","setLoading","loading","removeDuplicateCards","deckCards","uniqueCardsMap","Map","duplicatesRemoved","Array","from","status","startStudySession","studyCards","studyCardIds","currentCardIndex","sessionStats","total","correct","incorrect","startedAt","updateStudySession","clearStudySession","getStudySession","resetAllStudyData","resetCards","restOfState","useCurrentCard","store","currentCardId"],"ignoreList":[],"sources":["../../src/utils/validation.ts","../../src/stores/authStore.ts","../../src/stores/themeStore.ts","../../src/stores/gamificationStore.ts","../../src/utils/cardDefaults.ts","../../src/stores/deckStore.ts"],"sourcesContent":["// Input validation utilities\r\n\r\nexport interface ValidationResult {\r\n  isValid: boolean\r\n  errors: string[]\r\n}\r\n\r\nexport interface ValidationRule {\r\n  test: (value: string) => boolean\r\n  message: string\r\n}\r\n\r\n// Common validation rules\r\nexport const validationRules = {\r\n  required: (message = 'This field is required'): ValidationRule => ({\r\n    test: (value: string) => value.trim().length > 0,\r\n    message\r\n  }),\r\n  \r\n  minLength: (min: number, message?: string): ValidationRule => ({\r\n    test: (value: string) => value.length >= min,\r\n    message: message || `Must be at least ${min} characters long`\r\n  }),\r\n  \r\n  maxLength: (max: number, message?: string): ValidationRule => ({\r\n    test: (value: string) => value.length <= max,\r\n    message: message || `Must be no more than ${max} characters long`\r\n  }),\r\n  \r\n  email: (message = 'Please enter a valid email address'): ValidationRule => ({\r\n    test: (value: string) => {\r\n      const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/\r\n      return emailRegex.test(value)\r\n    },\r\n    message\r\n  }),\r\n  \r\n  password: (message = 'Password must be at least 8 characters with uppercase, lowercase, number, and special character'): ValidationRule => ({\r\n    test: (value: string) => {\r\n      // At least 8 characters, one uppercase, one lowercase, one number, one special character\r\n      const passwordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&])[A-Za-z\\d@$!%*?&]{8,}$/\r\n      return passwordRegex.test(value)\r\n    },\r\n    message\r\n  }),\r\n  \r\n  username: (message = 'Username must be 3-50 characters and contain only letters, numbers, and underscores'): ValidationRule => ({\r\n    test: (value: string) => {\r\n      const usernameRegex = /^[a-zA-Z0-9_]{3,50}$/\r\n      return usernameRegex.test(value)\r\n    },\r\n    message\r\n  }),\r\n  \r\n  noXSS: (message = 'Invalid characters detected'): ValidationRule => ({\r\n    test: (value: string) => {\r\n      // Basic XSS prevention - reject common script tags and javascript protocols\r\n      const xssRegex = /<script|javascript:|data:|vbscript:|onload=|onerror=/i\r\n      return !xssRegex.test(value)\r\n    },\r\n    message\r\n  }),\r\n  \r\n  noSQLInjection: (message = 'Invalid characters detected'): ValidationRule => ({\r\n    test: (value: string) => {\r\n      // Basic SQL injection prevention\r\n      const patterns = [\r\n        /'/, // single quotes\r\n        /\\\\'/, // escaped quotes\r\n        /;/, // semicolons\r\n        /--/, // SQL comments\r\n        /\\/\\*/, // block comments start\r\n        /(union|select|insert|delete|update|drop|create|alter|exec|execute)\\s/i // SQL keywords\r\n      ]\r\n      const hasSQLInjection = patterns.some(pattern => pattern.test(value))\r\n      return !hasSQLInjection\r\n    },\r\n    message\r\n  })\r\n}\r\n\r\n// Validate a single field\r\nexport function validateField(value: string, rules: ValidationRule[]): ValidationResult {\r\n  const errors: string[] = []\r\n  \r\n  for (const rule of rules) {\r\n    if (!rule.test(value)) {\r\n      errors.push(rule.message)\r\n    }\r\n  }\r\n  \r\n  return {\r\n    isValid: errors.length === 0,\r\n    errors\r\n  }\r\n}\r\n\r\n// Validate multiple fields\r\nexport function validateForm(data: Record<string, string>, rules: Record<string, ValidationRule[]>): Record<string, ValidationResult> {\r\n  const results: Record<string, ValidationResult> = {}\r\n  \r\n  for (const [field, fieldRules] of Object.entries(rules)) {\r\n    const value = data[field] || ''\r\n    results[field] = validateField(value, fieldRules)\r\n  }\r\n  \r\n  return results\r\n}\r\n\r\n// Check if all validation results are valid\r\nexport function isFormValid(results: Record<string, ValidationResult>): boolean {\r\n  return Object.values(results).every(result => result.isValid)\r\n}\r\n\r\n// Sanitize input to prevent XSS\r\nexport function sanitizeInput(input: string): string {\r\n  return input\r\n    .replace(/</g, '&lt;')\r\n    .replace(/>/g, '&gt;')\r\n    .replace(/\"/g, '&quot;')\r\n    .replace(/'/g, '&#x27;')\r\n    .replace(/\\//g, '&#x2F;')\r\n    .trim()\r\n}\r\n\r\n// Validate and sanitize text content\r\nexport function validateAndSanitizeText(text: string, maxLength = 5000): { isValid: boolean; sanitized: string; errors: string[] } {\r\n  const validation = validateField(text, [\r\n    validationRules.required(),\r\n    validationRules.maxLength(maxLength),\r\n    validationRules.noXSS(),\r\n    validationRules.noSQLInjection()\r\n  ])\r\n  \r\n  return {\r\n    isValid: validation.isValid,\r\n    sanitized: sanitizeInput(text),\r\n    errors: validation.errors\r\n  }\r\n}\r\n\r\n// Pre-defined validation schemas for common forms\r\nexport const validationSchemas = {\r\n  signUp: {\r\n    email: [validationRules.required(), validationRules.email()],\r\n    password: [validationRules.required(), validationRules.password()],\r\n    username: [validationRules.required(), validationRules.username()]\r\n  },\r\n  \r\n  signIn: {\r\n    email: [validationRules.required()],\r\n    password: [validationRules.required(), validationRules.minLength(6)]\r\n  },\r\n  \r\n  profile: {\r\n    username: [validationRules.required(), validationRules.username()],\r\n    email: [validationRules.required(), validationRules.email()]\r\n  },\r\n  \r\n  card: {\r\n    front_content: [validationRules.required(), validationRules.maxLength(5000), validationRules.noXSS()],\r\n    back_content: [validationRules.required(), validationRules.maxLength(5000), validationRules.noXSS()]\r\n  },\r\n  \r\n  deck: {\r\n    title: [validationRules.required(), validationRules.maxLength(200), validationRules.noXSS()],\r\n    description: [validationRules.maxLength(1000), validationRules.noXSS()]\r\n  }\r\n}","import { create } from 'zustand'\r\nimport { pb } from '../lib/pocketbase'\r\nimport type { User } from '../types'\r\nimport { debugLogger } from '../utils/debugLogger'\r\nimport { validateForm, validationSchemas, sanitizeInput } from '../utils/validation'\r\n\r\ninterface AuthState {\r\n  user: User | null\r\n  session: { record: Record<string, unknown>; token: string } | null // PocketBase auth record\r\n  isAuthenticated: boolean\r\n  isLoading: boolean\r\n  error: string | null\r\n  \r\n  // Primary Actions (unified interface for components)\r\n  login: (email: string, password: string) => Promise<void>\r\n  register: (email: string, username: string, password: string) => Promise<void>\r\n  logout: () => void\r\n  updateUser: (updates: Partial<User>) => void\r\n  \r\n  // PocketBase-specific Actions\r\n  signUp: (email: string, password: string, username: string) => Promise<void>\r\n  signIn: (email: string, password: string) => Promise<void>\r\n  signOut: () => Promise<void>\r\n  resetPassword: (email: string) => Promise<void>\r\n  updatePassword: (newPassword: string) => Promise<void>\r\n  updateProfile: (updates: Partial<User>) => Promise<void>\r\n  clearError: () => void\r\n  initializeAuth: () => Promise<void>\r\n}\r\n\r\n// Helper function to convert PocketBase user to our User type\r\nconst convertPocketbaseUser = async (pocketbaseUser: Record<string, unknown>): Promise<User> => {\r\n  debugLogger.log('[POCKETBASE_AUTH_STORE]', 'START - convertPocketbaseUser', {\r\n    userId: pocketbaseUser.id,\r\n    email: pocketbaseUser.email,\r\n    username: pocketbaseUser.username\r\n  });\r\n\r\n  try {\r\n    const convertedUser = {\r\n      id: pocketbaseUser.id,\r\n      email: pocketbaseUser.email,\r\n      username: pocketbaseUser.username || pocketbaseUser.email?.split('@')[0] || 'User',\r\n      level: pocketbaseUser.level || 1,\r\n      totalXp: pocketbaseUser.total_xp || 0,\r\n      coins: pocketbaseUser.coins || 100,\r\n      gems: pocketbaseUser.gems || 10,\r\n      createdAt: pocketbaseUser.created || new Date().toISOString(),\r\n      lastActive: pocketbaseUser.last_active || new Date().toISOString(),\r\n      preferences: pocketbaseUser.preferences || {\r\n        theme: 'system' as const,\r\n        language: 'en',\r\n        notifications: true,\r\n        soundEffects: true,\r\n        dailyGoal: 50,\r\n        timezone: 'UTC'\r\n      }\r\n    };\r\n\r\n    debugLogger.log('[POCKETBASE_AUTH_STORE]', 'END - convertPocketbaseUser', convertedUser);\r\n    return convertedUser;\r\n  } catch (error) {\r\n    debugLogger.error('[POCKETBASE_AUTH_STORE]', 'Error in convertPocketbaseUser', {\r\n      error,\r\n      stack: error instanceof Error ? error.stack : undefined,\r\n      userId: pocketbaseUser.id\r\n    });\r\n    \r\n    // Fallback: create a basic user object\r\n    const fallbackUser = {\r\n      id: pocketbaseUser.id,\r\n      email: pocketbaseUser.email || 'unknown@example.com',\r\n      username: pocketbaseUser.username || pocketbaseUser.email?.split('@')[0] || 'User',\r\n      level: 1,\r\n      totalXp: 0,\r\n      coins: 100,\r\n      gems: 10,\r\n      createdAt: pocketbaseUser.created || new Date().toISOString(),\r\n      lastActive: new Date().toISOString(),\r\n      preferences: {\r\n        theme: 'system' as const,\r\n        language: 'en',\r\n        notifications: true,\r\n        soundEffects: true,\r\n        dailyGoal: 50,\r\n        timezone: 'UTC'\r\n      }\r\n    };\r\n\r\n    debugLogger.log('[POCKETBASE_AUTH_STORE]', 'END - convertPocketbaseUser (fallback)', fallbackUser);\r\n    return fallbackUser;\r\n  }\r\n}\r\n\r\n// Helper functions for authentication operations\r\nconst validateSignUpInputs = (email: string, password: string, username: string) => {\r\n  const validationResults = validateForm(\r\n    { email, password, username },\r\n    validationSchemas.signUp\r\n  )\r\n  \r\n  const validationErrors = Object.entries(validationResults)\r\n    .filter(([_, result]) => !result.isValid)\r\n    .map(([field, result]) => `${field}: ${result.errors.join(', ')}`)\r\n  \r\n  if (validationErrors.length > 0) {\r\n    throw new Error(validationErrors.join('; '))\r\n  }\r\n}\r\n\r\nconst validateSignInInputs = (email: string, password: string) => {\r\n  const validationResults = validateForm(\r\n    { email, password },\r\n    validationSchemas.signIn\r\n  )\r\n  \r\n  const validationErrors = Object.entries(validationResults)\r\n    .filter(([_, result]) => !result.isValid)\r\n    .map(([field, result]) => `${field}: ${result.errors.join(', ')}`)\r\n  \r\n  if (validationErrors.length > 0) {\r\n    throw new Error(validationErrors.join('; '))\r\n  }\r\n}\r\n\r\nconst createPocketBaseUserData = (email: string, username: string, password: string) => ({\r\n  username: sanitizeInput(username),\r\n  email: sanitizeInput(email),\r\n  password,\r\n  passwordConfirm: password,\r\n  level: 1,\r\n  total_xp: 0,\r\n  coins: 100,\r\n  gems: 10,\r\n  last_active: new Date().toISOString(),\r\n  preferences: {\r\n    theme: 'system',\r\n    language: 'en',\r\n    notifications: true,\r\n    soundEffects: true,\r\n    dailyGoal: 50,\r\n    timezone: 'UTC'\r\n  }\r\n})\r\n\r\nconst createDemoUser = (): User => ({\r\n  id: 'demo-user',\r\n  email: 'demo@studymaster.app',\r\n  username: 'DemoUser',\r\n  level: 5,\r\n  totalXp: 2500,\r\n  coins: 150,\r\n  gems: 25,\r\n  createdAt: new Date().toISOString(),\r\n  lastActive: new Date().toISOString(),\r\n  preferences: {\r\n    theme: 'system',\r\n    language: 'en',\r\n    notifications: true,\r\n    soundEffects: true,\r\n    dailyGoal: 50,\r\n    timezone: 'UTC'\r\n  }\r\n})\r\n\r\nconst handleSignUpError = (error: unknown): string => {\r\n  if (!(error instanceof Error)) return 'Registration failed'\r\n  \r\n  if (error.message.includes('username')) {\r\n    return 'Username already exists or is invalid'\r\n  } else if (error.message.includes('email')) {\r\n    return 'Email already exists or is invalid'\r\n  } else {\r\n    return error.message\r\n  }\r\n}\r\n\r\nconst handleSignInError = (error: unknown): string => {\r\n  if (!(error instanceof Error)) return 'Login failed'\r\n  \r\n  if (error.message.includes('Failed to authenticate')) {\r\n    return 'Invalid email/username or password. Please check your credentials and try again.'\r\n  } else if (error.message.includes('Too many requests')) {\r\n    return 'Too many login attempts. Please wait a moment and try again.'\r\n  } else {\r\n    return error.message\r\n  }\r\n}\r\n\r\nconst isDemoLogin = (email: string, password: string): boolean => {\r\n  const isDevelopment = import.meta.env.NODE_ENV === 'development' || import.meta.env.VITE_ENABLE_DEBUG_LOGGING === 'true'\r\n  const demoPassword = import.meta.env.VITE_DEMO_PASSWORD || 'demo123456'\r\n  return isDevelopment && email === 'demo' && password === demoPassword\r\n}\r\n\r\nconst performPocketBaseAuth = async (email: string, password: string) => {\r\n  const sanitizedEmail = sanitizeInput(email)\r\n  \r\n  // Try email first, then username fallback\r\n  try {\r\n    return await pb.collection('users').authWithPassword(sanitizedEmail, password)\r\n  } catch (emailError) {\r\n    debugLogger.log('[POCKETBASE_AUTH_STORE]', 'Email login failed, trying username');\r\n    return await pb.collection('users').authWithPassword(sanitizedEmail, password)\r\n  }\r\n}\r\n\r\nconst updateUserLastActive = async (userId: string) => {\r\n  try {\r\n    await pb.collection('users').update(userId, {\r\n      last_active: new Date().toISOString()\r\n    })\r\n    debugLogger.log('[POCKETBASE_AUTH_STORE]', 'Updated last active time');\r\n  } catch (updateError) {\r\n    debugLogger.warn('[POCKETBASE_AUTH_STORE]', 'Could not update last active time', {\r\n      error: updateError\r\n    });\r\n  }\r\n}\r\n\r\n// Consolidated authentication store - combines PocketBase + local fallback\r\n// This replaces the dual authStore/pocketbaseAuthStore pattern\r\nexport const useAuthStore = create<AuthState>()((set, get) => ({\r\n  user: null,\r\n  session: null,\r\n  isAuthenticated: false,\r\n  isLoading: false,\r\n  error: null,\r\n\r\n  signUp: async (email: string, password: string, username: string) => {\r\n    debugLogger.log('[POCKETBASE_AUTH_STORE]', 'START - signUp', {\r\n      email,\r\n      username,\r\n      passwordLength: password.length\r\n    });\r\n\r\n    set({ isLoading: true, error: null })\r\n    \r\n    try {\r\n      validateSignUpInputs(email, password, username)\r\n      \r\n      const userData = createPocketBaseUserData(email, username, password)\r\n      debugLogger.log('[POCKETBASE_AUTH_STORE]', 'Creating user in PocketBase', {\r\n        email: userData.email,\r\n        username: userData.username\r\n      });\r\n\r\n      const newUser = await pb.collection('users').create(userData)\r\n      debugLogger.log('[POCKETBASE_AUTH_STORE]', 'User created successfully', {\r\n        userId: newUser.id\r\n      });\r\n\r\n      // Authenticate the newly created user\r\n      const authData = await pb.collection('users').authWithPassword(userData.email, password)\r\n      debugLogger.log('[POCKETBASE_AUTH_STORE]', 'SignUp with auth successful', {\r\n        userId: authData.record.id,\r\n        hasToken: !!authData.token\r\n      });\r\n\r\n      const user = await convertPocketbaseUser(authData.record)\r\n      \r\n      set({\r\n        user,\r\n        session: authData,\r\n        isAuthenticated: true,\r\n        isLoading: false,\r\n        error: null\r\n      })\r\n\r\n    } catch (error) {\r\n      debugLogger.error('[POCKETBASE_AUTH_STORE]', 'SignUp error', {\r\n        error,\r\n        stack: error instanceof Error ? error.stack : undefined\r\n      });\r\n\r\n      set({\r\n        error: handleSignUpError(error),\r\n        isLoading: false\r\n      })\r\n    }\r\n\r\n    debugLogger.log('[POCKETBASE_AUTH_STORE]', 'END - signUp');\r\n  },\r\n\r\n  signIn: async (email: string, password: string) => {\r\n    debugLogger.log('[POCKETBASE_AUTH_STORE]', 'START - signIn', {\r\n      email,\r\n      passwordLength: password.length,\r\n      isDemoLogin: email === 'demo'\r\n    });\r\n\r\n    set({ isLoading: true, error: null })\r\n    \r\n    const timeoutId = setTimeout(() => {\r\n      debugLogger.warn('[POCKETBASE_AUTH_STORE]', 'SignIn timeout reached');\r\n      set({ isLoading: false, error: 'Login timed out. Please try again.' })\r\n    }, 10000)\r\n    \r\n    try {\r\n      // Handle demo login in development\r\n      if (isDemoLogin(email, password)) {\r\n        debugLogger.info('[POCKETBASE_AUTH_STORE]', 'Demo login detected (development mode)');\r\n        const demoUser = createDemoUser()\r\n        \r\n        clearTimeout(timeoutId)\r\n        set({\r\n          user: demoUser,\r\n          session: null,\r\n          isAuthenticated: true,\r\n          isLoading: false,\r\n          error: null\r\n        })\r\n        \r\n        debugLogger.log('[POCKETBASE_AUTH_STORE]', 'END - signIn (demo user)');\r\n        return\r\n      }\r\n\r\n      // Validate inputs for regular login\r\n      validateSignInInputs(email, password)\r\n      \r\n      // Perform PocketBase authentication\r\n      debugLogger.log('[POCKETBASE_AUTH_STORE]', 'Attempting PocketBase authentication');\r\n      const authData = await performPocketBaseAuth(email, password)\r\n\r\n      debugLogger.log('[POCKETBASE_AUTH_STORE]', 'SignIn response', {\r\n        hasRecord: !!authData.record,\r\n        hasToken: !!authData.token,\r\n        userId: authData.record?.id\r\n      });\r\n\r\n      if (authData.record && authData.token) {\r\n        debugLogger.log('[POCKETBASE_AUTH_STORE]', 'SignIn successful, converting user profile');\r\n        \r\n        const user = await convertPocketbaseUser(authData.record)\r\n        await updateUserLastActive(authData.record.id)\r\n        \r\n        clearTimeout(timeoutId)\r\n        \r\n        set({\r\n          user,\r\n          session: authData,\r\n          isAuthenticated: true,\r\n          isLoading: false,\r\n          error: null\r\n        })\r\n        \r\n        debugLogger.log('[POCKETBASE_AUTH_STORE]', 'END - signIn (success)');\r\n      } else {\r\n        debugLogger.warn('[POCKETBASE_AUTH_STORE]', 'No user or token in response');\r\n        clearTimeout(timeoutId)\r\n        set({\r\n          error: 'Invalid login response - no user or token',\r\n          isLoading: false\r\n        })\r\n      }\r\n    } catch (error) {\r\n      debugLogger.error('[POCKETBASE_AUTH_STORE]', 'SignIn error', {\r\n        error,\r\n        stack: error instanceof Error ? error.stack : undefined\r\n      });\r\n      \r\n      clearTimeout(timeoutId)\r\n      set({\r\n        error: handleSignInError(error),\r\n        isLoading: false\r\n      })\r\n    }\r\n\r\n    debugLogger.log('[POCKETBASE_AUTH_STORE]', 'END - signIn');\r\n  },\r\n\r\n  signOut: async () => {\r\n    debugLogger.log('[POCKETBASE_AUTH_STORE]', 'START - signOut');\r\n    \r\n    try {\r\n      debugLogger.log('[POCKETBASE_AUTH_STORE]', 'Calling PocketBase authStore.clear');\r\n      pb.authStore.clear()\r\n      \r\n      debugLogger.log('[POCKETBASE_AUTH_STORE]', 'Clearing auth state');\r\n      set({ \r\n        user: null,\r\n        session: null,\r\n        isAuthenticated: false, \r\n        error: null \r\n      })\r\n      \r\n      debugLogger.log('[POCKETBASE_AUTH_STORE]', 'END - signOut (success)');\r\n    } catch (error) {\r\n      debugLogger.error('[POCKETBASE_AUTH_STORE]', 'SignOut error', {\r\n        error,\r\n        stack: error instanceof Error ? error.stack : undefined\r\n      });\r\n      \r\n      set({\r\n        error: error instanceof Error ? error.message : 'Logout failed'\r\n      })\r\n    }\r\n  },\r\n\r\n  resetPassword: async (email: string) => {\r\n    debugLogger.log('[POCKETBASE_AUTH_STORE]', 'START - resetPassword', { email });\r\n    \r\n    set({ isLoading: true, error: null })\r\n    \r\n    try {\r\n      await pb.collection('users').requestPasswordReset(email)\r\n      \r\n      set({\r\n        isLoading: false,\r\n        error: null\r\n      })\r\n      \r\n      debugLogger.log('[POCKETBASE_AUTH_STORE]', 'END - resetPassword (success)');\r\n    } catch (error) {\r\n      debugLogger.error('[POCKETBASE_AUTH_STORE]', 'Reset password error', {\r\n        error,\r\n        stack: error instanceof Error ? error.stack : undefined\r\n      });\r\n      \r\n      let errorMessage = 'Password reset failed'\r\n      if (error instanceof Error) {\r\n        if (error.message.includes('Invalid email')) {\r\n          errorMessage = 'Please enter a valid email address.'\r\n        } else if (error.message.includes('not found')) {\r\n          errorMessage = 'No account found with this email address.'\r\n        } else {\r\n          errorMessage = error.message\r\n        }\r\n      }\r\n      \r\n      set({\r\n        error: errorMessage,\r\n        isLoading: false\r\n      })\r\n    }\r\n  },\r\n\r\n  updatePassword: async (newPassword: string) => {\r\n    debugLogger.log('[POCKETBASE_AUTH_STORE]', 'START - updatePassword', {\r\n      passwordLength: newPassword.length\r\n    });\r\n    \r\n    const currentState = get();\r\n    debugLogger.log('[POCKETBASE_AUTH_STORE]', 'Current auth state', {\r\n      hasUser: !!currentState.user,\r\n      hasSession: !!currentState.session,\r\n      isAuthenticated: currentState.isAuthenticated\r\n    });\r\n    \r\n    set({ isLoading: true, error: null });\r\n    \r\n    try {\r\n      // Validate password\r\n      if (!newPassword || newPassword.length < 6) {\r\n        throw new Error(\"Password must be at least 6 characters long.\");\r\n      }\r\n\r\n      if (!currentState.user?.id) {\r\n        throw new Error('No authenticated user found');\r\n      }\r\n\r\n      debugLogger.log('[POCKETBASE_AUTH_STORE]', 'Calling pb.collection.update');\r\n\r\n      await pb.collection('users').update(currentState.user.id, {\r\n        password: newPassword,\r\n        passwordConfirm: newPassword\r\n      });\r\n\r\n      debugLogger.log('[POCKETBASE_AUTH_STORE]', 'Password update successful');\r\n\r\n      set({ isLoading: false, error: null });\r\n      \r\n      debugLogger.log('[POCKETBASE_AUTH_STORE]', 'END - updatePassword (success)');\r\n    } catch (error) {\r\n      const errorMessage =\r\n        error instanceof Error\r\n          ? error.message\r\n          : \"An unknown error occurred during password update.\";\r\n      \r\n      debugLogger.error('[POCKETBASE_AUTH_STORE]', 'UpdatePassword failed', {\r\n        error: errorMessage,\r\n        errorType: error?.constructor?.name,\r\n        stack: error instanceof Error ? error.stack : undefined\r\n      });\r\n      \r\n      set({ isLoading: false, error: errorMessage });\r\n      \r\n      throw new Error(errorMessage);\r\n    }\r\n  },\r\n\r\n  updateProfile: async (updates: Partial<User>) => {\r\n    const { user } = get()\r\n    \r\n    debugLogger.log('[POCKETBASE_AUTH_STORE]', 'START - updateProfile', {\r\n      userId: user?.id,\r\n      updates: Object.keys(updates)\r\n    });\r\n    \r\n    if (!user) {\r\n      debugLogger.warn('[POCKETBASE_AUTH_STORE]', 'No user found for profile update');\r\n      return\r\n    }\r\n    \r\n    try {\r\n      const updateData = {\r\n        username: updates.username,\r\n        level: updates.level,\r\n        total_xp: updates.totalXp,\r\n        coins: updates.coins,\r\n        gems: updates.gems,\r\n        preferences: updates.preferences,\r\n        last_active: new Date().toISOString()\r\n      };\r\n      \r\n      debugLogger.log('[POCKETBASE_AUTH_STORE]', 'Updating profile in database', updateData);\r\n      \r\n      await pb.collection('users').update(user.id, updateData)\r\n      \r\n      debugLogger.log('[POCKETBASE_AUTH_STORE]', 'Updating local user state');\r\n      set({ user: { ...user, ...updates } })\r\n      \r\n      debugLogger.log('[POCKETBASE_AUTH_STORE]', 'END - updateProfile (success)');\r\n    } catch (error) {\r\n      debugLogger.error('[POCKETBASE_AUTH_STORE]', 'Profile update error', {\r\n        error,\r\n        stack: error instanceof Error ? error.stack : undefined\r\n      });\r\n      \r\n      set({\r\n        error: error instanceof Error ? error.message : 'Profile update failed'\r\n      })\r\n    }\r\n  },\r\n\r\n  clearError: () => {\r\n    debugLogger.log('[POCKETBASE_AUTH_STORE]', 'Clearing error state');\r\n    set({ error: null })\r\n  },\r\n\r\n  initializeAuth: async () => {\r\n    debugLogger.log('[POCKETBASE_AUTH_STORE]', 'START - initializeAuth');\r\n    \r\n    try {\r\n      if (pb.authStore.isValid && pb.authStore.model) {\r\n        debugLogger.log('[POCKETBASE_AUTH_STORE]', 'Valid auth store found, converting user', {\r\n          userId: pb.authStore.model.id,\r\n          email: pb.authStore.model.email\r\n        });\r\n        \r\n        const user = await convertPocketbaseUser(pb.authStore.model)\r\n        \r\n        debugLogger.log('[POCKETBASE_AUTH_STORE]', 'Setting authenticated state from initialization');\r\n        set({\r\n          user,\r\n          session: {\r\n            record: pb.authStore.model,\r\n            token: pb.authStore.token\r\n          },\r\n          isAuthenticated: true\r\n        })\r\n      } else {\r\n        debugLogger.info('[POCKETBASE_AUTH_STORE]', 'No valid auth store found during initialization');\r\n      }\r\n      \r\n      debugLogger.log('[POCKETBASE_AUTH_STORE]', 'END - initializeAuth');\r\n    } catch (error) {\r\n      debugLogger.error('[POCKETBASE_AUTH_STORE]', 'Auth initialization error', {\r\n        error,\r\n        stack: error instanceof Error ? error.stack : undefined\r\n      });\r\n      \r\n      set({ \r\n        user: null,\r\n        session: null,\r\n        isAuthenticated: false \r\n      })\r\n    }\r\n  },\r\n\r\n  // Unified methods for backward compatibility with existing components\r\n  login: async (email: string, password: string) => {\r\n    const { signIn } = get()\r\n    await signIn(email, password)\r\n  },\r\n\r\n  register: async (email: string, username: string, password: string) => {\r\n    const { signUp } = get()\r\n    await signUp(email, password, username)\r\n  },\r\n\r\n  logout: () => {\r\n    const { signOut } = get()\r\n    signOut()\r\n  },\r\n\r\n  updateUser: (updates: Partial<User>) => {\r\n    const { user } = get()\r\n    if (user) {\r\n      set({ user: { ...user, ...updates } })\r\n    }\r\n  }\r\n}))\r\n\r\n// Set up auth state change listener\r\npb.authStore.onChange((token, record) => {\r\n  debugLogger.info('[POCKETBASE_AUTH_STORE]', 'Auth state change detected', {\r\n    hasToken: !!token,\r\n    hasRecord: !!record,\r\n    userId: record?.id,\r\n    timestamp: new Date().toISOString()\r\n  });\r\n  \r\n  if (token && record) {\r\n    debugLogger.log('[POCKETBASE_AUTH_STORE]', 'Processing auth state change - user logged in');\r\n    \r\n    convertPocketbaseUser(record).then(user => {\r\n      debugLogger.log('[POCKETBASE_AUTH_STORE]', 'Updating auth store for logged in user');\r\n      useAuthStore.setState({\r\n        user,\r\n        session: { record, token },\r\n        isAuthenticated: true\r\n      })\r\n    }).catch(error => {\r\n      debugLogger.error('[POCKETBASE_AUTH_STORE]', 'Failed to convert user during auth change', {\r\n        error,\r\n        userId: record.id\r\n      });\r\n    });\r\n  } else {\r\n    debugLogger.log('[POCKETBASE_AUTH_STORE]', 'Processing auth state change - user logged out');\r\n    \r\n    useAuthStore.setState({\r\n      user: null,\r\n      session: null,\r\n      isAuthenticated: false\r\n    })\r\n  }\r\n})","import { create } from 'zustand'\r\nimport { persist } from 'zustand/middleware'\r\n\r\ntype Theme = 'light' | 'dark' | 'system'\r\n\r\ninterface ThemeState {\r\n  theme: Theme\r\n  systemTheme: 'light' | 'dark'\r\n  \r\n  // Actions\r\n  setTheme: (theme: Theme) => void\r\n  toggleTheme: () => void\r\n  initializeTheme: () => void\r\n}\r\n\r\nexport const useThemeStore = create<ThemeState>()(\r\n  persist(\r\n    (set, get) => ({\r\n      theme: 'system',\r\n      systemTheme: 'light',\r\n\r\n      setTheme: (theme: Theme) => {\r\n        set({ theme })\r\n        \r\n        // Apply theme immediately\r\n        const { systemTheme } = get()\r\n        const effectiveTheme = theme === 'system' ? systemTheme : theme\r\n        \r\n        if (effectiveTheme === 'dark') {\r\n          document.documentElement.classList.add('dark')\r\n        } else {\r\n          document.documentElement.classList.remove('dark')\r\n        }\r\n      },\r\n\r\n      toggleTheme: () => {\r\n        const { theme } = get()\r\n        const newTheme = theme === 'light' ? 'dark' : 'light'\r\n        get().setTheme(newTheme)\r\n      },\r\n\r\n      initializeTheme: () => {\r\n        // Detect system theme preference\r\n        const systemTheme = window.matchMedia('(prefers-color-scheme: dark)').matches \r\n          ? 'dark' \r\n          : 'light'\r\n        \r\n        set({ systemTheme })\r\n        \r\n        // Listen for system theme changes\r\n        window.matchMedia('(prefers-color-scheme: dark)')\r\n          .addEventListener('change', (e) => {\r\n            const newSystemTheme = e.matches ? 'dark' : 'light'\r\n            set({ systemTheme: newSystemTheme })\r\n            \r\n            // If using system theme, update the applied theme\r\n            const { theme } = get()\r\n            if (theme === 'system') {\r\n              if (newSystemTheme === 'dark') {\r\n                document.documentElement.classList.add('dark')\r\n              } else {\r\n                document.documentElement.classList.remove('dark')\r\n              }\r\n            }\r\n          })\r\n        \r\n        // Apply initial theme\r\n        const { theme } = get()\r\n        const effectiveTheme = theme === 'system' ? systemTheme : theme\r\n        \r\n        if (effectiveTheme === 'dark') {\r\n          document.documentElement.classList.add('dark')\r\n        } else {\r\n          document.documentElement.classList.remove('dark')\r\n        }\r\n      }\r\n    }),\r\n    {\r\n      name: 'theme-storage',\r\n      partialize: (state) => ({ theme: state.theme })\r\n    }\r\n  )\r\n)","import { create } from 'zustand'\r\nimport { persist } from 'zustand/middleware'\r\nimport type {\r\n  Achievement,\r\n  UserAchievement,\r\n  UserStreak,\r\n  Challenge,\r\n  ChallengeParticipation,\r\n  Leaderboard,\r\n  WeeklyProgress\r\n} from '@shared/types'\r\n\r\ninterface UserStats {\r\n  totalCards: number\r\n  cardsStudiedToday: number\r\n  cardsStudiedThisWeek: number\r\n  cardsStudiedThisMonth: number\r\n  averageAccuracy: number\r\n  totalStudyTime: number // in minutes\r\n  studyTimeToday: number // in minutes\r\n  studyTimeThisWeek: number // in minutes\r\n  decksCreated: number\r\n  decksCompleted: number\r\n  longestStreak: number\r\n  currentStreak: number\r\n  // Currency system\r\n  gold: number\r\n  diamonds: number\r\n  // User level and XP\r\n  level: number\r\n  xp: number\r\n  xpToNextLevel: number\r\n}\r\n\r\ninterface GamificationState {\r\n  // User stats\r\n  userStats: UserStats\r\n  \r\n  // Achievements\r\n  achievements: Achievement[]\r\n  userAchievements: UserAchievement[]\r\n  \r\n  // Streaks\r\n  userStreak: UserStreak | null\r\n  \r\n  // Challenges\r\n  activeChallenges: Challenge[]\r\n  userChallengeParticipations: ChallengeParticipation[]\r\n  \r\n  // Leaderboards\r\n  leaderboards: Record<string, Leaderboard>\r\n  \r\n  // User state tracking\r\n  isFirstTimeUser: boolean\r\n  isInitialized: boolean\r\n  \r\n  // Actions\r\n  updateUserStats: (stats: Partial<UserStats>) => void\r\n  addUserAchievement: (achievementId: string) => void\r\n  updateStreak: (streak: Partial<UserStreak>) => void\r\n  joinChallenge: (challengeId: string) => void\r\n  updateChallengeProgress: (challengeId: string, progress: Record<string, number>) => void\r\n  claimChallengeReward: (challengeId: string) => void\r\n  initializeMockData: () => void\r\n  initializeNewUser: () => void\r\n  initializeUserData: (isDemo?: boolean) => void\r\n  resetAllUserData: () => void\r\n  addCurrency: (gold: number, diamonds: number) => void\r\n  spendCurrency: (gold: number, diamonds: number) => boolean\r\n  awardStudyXP: (cardsStudied: number, correctAnswers: number) => void\r\n  \r\n  // Monthly Challenge Management\r\n  updateMilestoneProgress: (challengeId: string, milestoneId: string, completed: boolean) => void\r\n  updateWeeklyProgress: (challengeId: string, weekData: WeeklyProgress) => void\r\n  updateChallengeStreak: (challengeId: string, streak: number) => void\r\n  unlockStoryChapter: (challengeId: string, week: number) => void\r\n  claimMilestoneReward: (challengeId: string, milestoneId: string) => void\r\n  contributeToCommunityGoal: (goalId: string, contribution: number) => void\r\n}\r\n\r\n// Mock data\r\nconst mockAchievements: Achievement[] = [\r\n  {\r\n    id: '1',\r\n    name: 'First Steps',\r\n    description: 'Complete your first study session',\r\n    icon: '',\r\n    category: 'study_milestones',\r\n    requirements: [{ type: 'sessions_completed', value: 1, operator: 'gte' }],\r\n    xpReward: 50,\r\n    coinReward: 10,\r\n    isSecret: false,\r\n    rarity: 'common'\r\n  },\r\n  {\r\n    id: '2',\r\n    name: 'Streak Master',\r\n    description: 'Maintain a 7-day study streak',\r\n    icon: '',\r\n    category: 'streaks',\r\n    requirements: [{ type: 'current_streak', value: 7, operator: 'gte' }],\r\n    xpReward: 200,\r\n    coinReward: 50,\r\n    isSecret: false,\r\n    rarity: 'rare'\r\n  },\r\n  {\r\n    id: '3',\r\n    name: 'Perfect Score',\r\n    description: 'Get 100% accuracy in a 20+ card session',\r\n    icon: '',\r\n    category: 'accuracy',\r\n    requirements: [\r\n      { type: 'session_accuracy', value: 100, operator: 'eq' },\r\n      { type: 'session_cards', value: 20, operator: 'gte' }\r\n    ],\r\n    xpReward: 150,\r\n    coinReward: 30,\r\n    isSecret: false,\r\n    rarity: 'rare'\r\n  },\r\n  {\r\n    id: '4',\r\n    name: 'Speed Demon',\r\n    description: 'Complete 50 cards in under 10 minutes',\r\n    icon: '',\r\n    category: 'special',\r\n    requirements: [\r\n      { type: 'cards_in_session', value: 50, operator: 'gte' },\r\n      { type: 'session_time', value: 600, operator: 'lte' }\r\n    ],\r\n    xpReward: 300,\r\n    coinReward: 75,\r\n    isSecret: false,\r\n    rarity: 'epic'\r\n  },\r\n  {\r\n    id: '5',\r\n    name: 'Scholar',\r\n    description: 'Study 1000 cards total',\r\n    icon: '',\r\n    category: 'study_milestones',\r\n    requirements: [{ type: 'total_cards', value: 1000, operator: 'gte' }],\r\n    xpReward: 500,\r\n    coinReward: 100,\r\n    isSecret: false,\r\n    rarity: 'epic'\r\n  },\r\n  {\r\n    id: '6',\r\n    name: 'Legend',\r\n    description: 'Reach level 20',\r\n    icon: '',\r\n    category: 'special',\r\n    requirements: [{ type: 'user_level', value: 20, operator: 'gte' }],\r\n    xpReward: 1000,\r\n    coinReward: 500,\r\n    isSecret: false,\r\n    rarity: 'legendary'\r\n  }\r\n]\r\n\r\nconst mockChallenges: Challenge[] = [\r\n  {\r\n    id: '1',\r\n    title: 'Daily Grind',\r\n    description: 'Study 25 cards today',\r\n    type: 'daily',\r\n    requirements: [{ type: 'cards_studied_today', target: 25, description: 'Study 25 cards' }],\r\n    rewards: [\r\n      { type: 'xp', amount: 50 },\r\n      { type: 'coins', amount: 10 }\r\n    ],\r\n    startDate: new Date().toISOString(),\r\n    endDate: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString(),\r\n    isActive: true,\r\n    participantCount: 1247\r\n  },\r\n  {\r\n    id: '2',\r\n    title: 'Weekly Warrior',\r\n    description: 'Complete 200 cards this week',\r\n    type: 'weekly',\r\n    requirements: [{ type: 'cards_studied_week', target: 200, description: 'Study 200 cards this week' }],\r\n    rewards: [\r\n      { type: 'xp', amount: 200 },\r\n      { type: 'coins', amount: 50 },\r\n      { type: 'gems', amount: 5 }\r\n    ],\r\n    startDate: new Date(Date.now() - 3 * 24 * 60 * 60 * 1000).toISOString(),\r\n    endDate: new Date(Date.now() + 4 * 24 * 60 * 60 * 1000).toISOString(),\r\n    isActive: true,\r\n    participantCount: 892\r\n  },\r\n  {\r\n    id: '3',\r\n    title: 'Accuracy Master',\r\n    description: 'Maintain 90%+ accuracy for 5 sessions',\r\n    type: 'weekly',\r\n    requirements: [{ type: 'accuracy_sessions', target: 5, description: 'Complete 5 sessions with 90%+ accuracy' }],\r\n    rewards: [\r\n      { type: 'xp', amount: 300 },\r\n      { type: 'coins', amount: 75 },\r\n      { type: 'badge', itemId: 'accuracy_master' }\r\n    ],\r\n    startDate: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000).toISOString(),\r\n    endDate: new Date(Date.now() + 5 * 24 * 60 * 60 * 1000).toISOString(),\r\n    isActive: true,\r\n    participantCount: 456\r\n  }\r\n]\r\n\r\nconst mockLeaderboards: Record<string, Leaderboard> = {\r\n  'xp_weekly': {\r\n    id: 'xp_weekly',\r\n    type: 'xp',\r\n    period: 'weekly',\r\n    entries: [\r\n      { userId: '1', username: 'DemoUser', score: 2500, rank: 1, change: 0 },\r\n      { userId: '2', username: 'StudyMaster', score: 2350, rank: 2, change: 1 },\r\n      { userId: '3', username: 'FlashcardPro', score: 2200, rank: 3, change: -1 },\r\n      { userId: '4', username: 'LearnFast', score: 2100, rank: 4, change: 2 },\r\n      { userId: '5', username: 'MemoryKing', score: 2050, rank: 5, change: -1 },\r\n      { userId: '6', username: 'QuizWhiz', score: 1980, rank: 6, change: 0 },\r\n      { userId: '7', username: 'CardShark', score: 1920, rank: 7, change: 3 },\r\n      { userId: '8', username: 'BrainBoost', score: 1850, rank: 8, change: -2 },\r\n      { userId: '9', username: 'StudyBuddy', score: 1800, rank: 9, change: 1 },\r\n      { userId: '10', username: 'FlashGenius', score: 1750, rank: 10, change: -1 }\r\n    ],\r\n    updatedAt: new Date().toISOString()\r\n  },\r\n  'streak_all_time': {\r\n    id: 'streak_all_time',\r\n    type: 'streak',\r\n    period: 'all_time',\r\n    entries: [\r\n      { userId: '2', username: 'StudyMaster', score: 45, rank: 1, change: 0 },\r\n      { userId: '3', username: 'FlashcardPro', score: 38, rank: 2, change: 0 },\r\n      { userId: '4', username: 'LearnFast', score: 32, rank: 3, change: 1 },\r\n      { userId: '1', username: 'DemoUser', score: 28, rank: 4, change: -1 },\r\n      { userId: '5', username: 'MemoryKing', score: 25, rank: 5, change: 0 },\r\n      { userId: '6', username: 'QuizWhiz', score: 22, rank: 6, change: 2 },\r\n      { userId: '7', username: 'CardShark', score: 20, rank: 7, change: -1 },\r\n      { userId: '8', username: 'BrainBoost', score: 18, rank: 8, change: -1 },\r\n      { userId: '9', username: 'StudyBuddy', score: 15, rank: 9, change: 0 },\r\n      { userId: '10', username: 'FlashGenius', score: 12, rank: 10, change: 0 }\r\n    ],\r\n    updatedAt: new Date().toISOString()\r\n  }\r\n}\r\n\r\n// Helper function to calculate level from XP\r\nconst calculateLevel = (xp: number): number => {\r\n  return Math.floor(Math.sqrt(xp / 100)) + 1\r\n}\r\n\r\n// Helper function to calculate XP needed for next level\r\nconst calculateXPToNextLevel = (level: number): number => {\r\n  const nextLevelXP = Math.pow(level, 2) * 100\r\n  return nextLevelXP\r\n}\r\n\r\n// Initial clean state for new users\r\nconst getInitialUserStats = (): UserStats => ({\r\n  totalCards: 0,\r\n  cardsStudiedToday: 0,\r\n  cardsStudiedThisWeek: 0,\r\n  cardsStudiedThisMonth: 0,\r\n  averageAccuracy: 0,\r\n  totalStudyTime: 0,\r\n  studyTimeToday: 0,\r\n  studyTimeThisWeek: 0,\r\n  decksCreated: 0,\r\n  decksCompleted: 0,\r\n  longestStreak: 0,\r\n  currentStreak: 0,\r\n  gold: 0,\r\n  diamonds: 0,\r\n  level: 1,\r\n  xp: 0,\r\n  xpToNextLevel: 100\r\n})\r\n\r\n// Demo data for demonstration purposes\r\nconst getDemoUserStats = (): UserStats => ({\r\n  totalCards: 1250,\r\n  cardsStudiedToday: 45,\r\n  cardsStudiedThisWeek: 180,\r\n  cardsStudiedThisMonth: 720,\r\n  averageAccuracy: 87.5,\r\n  totalStudyTime: 2400, // 40 hours\r\n  studyTimeToday: 35,\r\n  studyTimeThisWeek: 240, // 4 hours\r\n  decksCreated: 8,\r\n  decksCompleted: 3,\r\n  longestStreak: 28,\r\n  currentStreak: 12,\r\n  gold: 100,\r\n  diamonds: 10,\r\n  level: 8,\r\n  xp: 6400,\r\n  xpToNextLevel: 8100\r\n})\r\n\r\nexport const useGamificationStore = create<GamificationState>()(\r\n  persist(\r\n    (set, get) => ({\r\n      userStats: getInitialUserStats(),\r\n      isFirstTimeUser: true,\r\n      isInitialized: false,\r\n      \r\n      achievements: mockAchievements,\r\n      userAchievements: [],\r\n      \r\n      userStreak: null,\r\n      \r\n      activeChallenges: mockChallenges,\r\n      userChallengeParticipations: [],\r\n      \r\n      leaderboards: mockLeaderboards,\r\n      \r\n      updateUserStats: (stats) => {\r\n        set((state) => {\r\n          const newStats = { ...state.userStats, ...stats }\r\n          \r\n          // Recalculate level and XP if XP changed\r\n          if (stats.xp !== undefined) {\r\n            newStats.level = calculateLevel(newStats.xp)\r\n            newStats.xpToNextLevel = calculateXPToNextLevel(newStats.level)\r\n          }\r\n          \r\n          return {\r\n            userStats: newStats,\r\n            isFirstTimeUser: false,\r\n            isInitialized: true\r\n          }\r\n        })\r\n      },\r\n      \r\n      addUserAchievement: (achievementId) => {\r\n        const { userAchievements } = get()\r\n        if (!userAchievements.find(ua => ua.achievementId === achievementId)) {\r\n          set((state) => ({\r\n            userAchievements: [\r\n              ...state.userAchievements,\r\n              {\r\n                id: Date.now().toString(),\r\n                userId: '1',\r\n                achievementId,\r\n                earnedAt: new Date().toISOString()\r\n              }\r\n            ]\r\n          }))\r\n        }\r\n      },\r\n      \r\n      updateStreak: (streak) => {\r\n        set((state) => ({\r\n          userStreak: state.userStreak ? { ...state.userStreak, ...streak } : null\r\n        }))\r\n      },\r\n      \r\n      joinChallenge: (challengeId) => {\r\n        const { userChallengeParticipations } = get()\r\n        if (!userChallengeParticipations.find(p => p.challengeId === challengeId)) {\r\n          set((state) => ({\r\n            userChallengeParticipations: [\r\n              ...state.userChallengeParticipations,\r\n              {\r\n                id: Date.now().toString(),\r\n                userId: '1',\r\n                challengeId,\r\n                progress: {},\r\n                completed: false,\r\n                joinedAt: new Date().toISOString(),\r\n                milestoneProgress: {},\r\n                weeklyProgress: [],\r\n                currentStreak: 0,\r\n                bestWeek: 0\r\n              }\r\n            ]\r\n          }))\r\n        }\r\n      },\r\n      \r\n      updateChallengeProgress: (challengeId, progress) => {\r\n        set((state) => ({\r\n          userChallengeParticipations: state.userChallengeParticipations.map(p =>\r\n            p.challengeId === challengeId\r\n              ? { ...p, progress: { ...p.progress, ...progress } }\r\n              : p\r\n          )\r\n        }))\r\n      },\r\n      \r\n      claimChallengeReward: (challengeId) => {\r\n        const { activeChallenges, userChallengeParticipations } = get()\r\n        const challenge = activeChallenges.find(c => c.id === challengeId)\r\n        const participation = userChallengeParticipations.find(p => p.challengeId === challengeId)\r\n        \r\n        if (challenge && participation && participation.completed) {\r\n          // Calculate total XP and coins from rewards\r\n          let xpGained = 0\r\n          // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n          let _coinsGained = 0\r\n          \r\n          challenge.rewards.forEach(reward => {\r\n            if (reward.type === 'xp' && reward.amount) {\r\n              xpGained += reward.amount\r\n            } else if (reward.type === 'coins' && reward.amount) {\r\n              _coinsGained += reward.amount\r\n            }\r\n          })\r\n          \r\n          // Update user stats with rewards\r\n          set((state) => ({\r\n            userStats: {\r\n              ...state.userStats,\r\n              totalCards: state.userStats.totalCards + xpGained / 10 // Rough conversion\r\n            },\r\n            // Remove the participation since reward is claimed\r\n            userChallengeParticipations: state.userChallengeParticipations.filter(\r\n              p => p.challengeId !== challengeId\r\n            )\r\n          }))\r\n        }\r\n      },\r\n      \r\n      initializeMockData: () => {\r\n        // This function can be called to load demo data\r\n        set({\r\n          userStats: getDemoUserStats(),\r\n          achievements: mockAchievements,\r\n          activeChallenges: mockChallenges,\r\n          leaderboards: mockLeaderboards,\r\n          userAchievements: [\r\n            {\r\n              id: '1',\r\n              userId: '1',\r\n              achievementId: '1',\r\n              earnedAt: new Date(Date.now() - 10 * 24 * 60 * 60 * 1000).toISOString()\r\n            },\r\n            {\r\n              id: '2',\r\n              userId: '1',\r\n              achievementId: '2',\r\n              earnedAt: new Date(Date.now() - 5 * 24 * 60 * 60 * 1000).toISOString()\r\n            }\r\n          ],\r\n          userStreak: {\r\n            id: '1',\r\n            userId: '1',\r\n            currentStreak: 12,\r\n            longestStreak: 28,\r\n            lastStudyDate: new Date().toISOString(),\r\n            freezeCount: 2,\r\n            createdAt: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString()\r\n          },\r\n          userChallengeParticipations: [\r\n            {\r\n              id: '1',\r\n              userId: '1',\r\n              challengeId: '1',\r\n              progress: { cards_studied_today: 45 } as Record<string, number>,\r\n              completed: true,\r\n              joinedAt: new Date().toISOString(),\r\n              completedAt: new Date().toISOString(),\r\n              milestoneProgress: { 'milestone_1': true },\r\n              weeklyProgress: [],\r\n              currentStreak: 5,\r\n              bestWeek: 1\r\n            },\r\n            {\r\n              id: '2',\r\n              userId: '1',\r\n              challengeId: '2',\r\n              progress: { cards_studied_week: 180 } as Record<string, number>,\r\n              completed: false,\r\n              joinedAt: new Date(Date.now() - 3 * 24 * 60 * 60 * 1000).toISOString(),\r\n              milestoneProgress: { 'milestone_1': true, 'milestone_2': false },\r\n              weeklyProgress: [\r\n                {\r\n                  week: 1,\r\n                  startDate: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString(),\r\n                  endDate: new Date().toISOString(),\r\n                  progress: { cards_studied_week: 180 },\r\n                  completed: true,\r\n                  completedAt: new Date().toISOString(),\r\n                  storyUnlocked: true\r\n                }\r\n              ],\r\n              currentStreak: 3,\r\n              bestWeek: 1\r\n            }\r\n          ] as ChallengeParticipation[],\r\n          isFirstTimeUser: false,\r\n          isInitialized: true\r\n        })\r\n      },\r\n\r\n      initializeNewUser: () => {\r\n        // Initialize a completely fresh user\r\n        set({\r\n          userStats: getInitialUserStats(),\r\n          userAchievements: [],\r\n          userStreak: null,\r\n          userChallengeParticipations: [],\r\n          isFirstTimeUser: false,\r\n          isInitialized: true\r\n        })\r\n      },\r\n\r\n      resetAllUserData: () => {\r\n        // Reset all user-specific data to initial state\r\n        set({\r\n          userStats: getInitialUserStats(),\r\n          userAchievements: [],\r\n          userStreak: null,\r\n          userChallengeParticipations: [],\r\n          isFirstTimeUser: true,\r\n          isInitialized: true\r\n        })\r\n      },\r\n\r\n      addCurrency: (gold, diamonds) => {\r\n        set((state) => ({\r\n          userStats: {\r\n            ...state.userStats,\r\n            gold: state.userStats.gold + gold,\r\n            diamonds: state.userStats.diamonds + diamonds\r\n          }\r\n        }))\r\n      },\r\n\r\n      spendCurrency: (gold, diamonds) => {\r\n        const { userStats } = get()\r\n        if (userStats.gold >= gold && userStats.diamonds >= diamonds) {\r\n          set((state) => ({\r\n            userStats: {\r\n              ...state.userStats,\r\n              gold: state.userStats.gold - gold,\r\n              diamonds: state.userStats.diamonds - diamonds\r\n            }\r\n          }))\r\n          return true\r\n        }\r\n        return false\r\n      },\r\n\r\n      // Initialize user data based on authentication status\r\n      initializeUserData: (isDemo: boolean = false) => {\r\n        const state = get()\r\n        \r\n        // Only initialize if not already done\r\n        if (!state.isInitialized) {\r\n          if (isDemo) {\r\n            // Load demo data for demo users\r\n            set({\r\n              userStats: getDemoUserStats(),\r\n              achievements: mockAchievements,\r\n              activeChallenges: mockChallenges,\r\n              leaderboards: mockLeaderboards,\r\n              userAchievements: [\r\n                {\r\n                  id: '1',\r\n                  userId: '1',\r\n                  achievementId: '1',\r\n                  earnedAt: new Date(Date.now() - 10 * 24 * 60 * 60 * 1000).toISOString()\r\n                },\r\n                {\r\n                  id: '2',\r\n                  userId: '1',\r\n                  achievementId: '2',\r\n                  earnedAt: new Date(Date.now() - 5 * 24 * 60 * 60 * 1000).toISOString()\r\n                }\r\n              ],\r\n              userStreak: {\r\n                id: '1',\r\n                userId: '1',\r\n                currentStreak: 12,\r\n                longestStreak: 28,\r\n                lastStudyDate: new Date().toISOString(),\r\n                freezeCount: 2,\r\n                createdAt: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString()\r\n              },\r\n              userChallengeParticipations: [\r\n                {\r\n                  id: '1',\r\n                  userId: '1',\r\n                  challengeId: '1',\r\n                  progress: { cards_studied_today: 45 } as Record<string, number>,\r\n                  completed: true,\r\n                  joinedAt: new Date().toISOString(),\r\n                  completedAt: new Date().toISOString()\r\n                },\r\n                {\r\n                  id: '2',\r\n                  userId: '1',\r\n                  challengeId: '2',\r\n                  progress: { cards_studied_week: 180 } as Record<string, number>,\r\n                  completed: false,\r\n                  joinedAt: new Date(Date.now() - 3 * 24 * 60 * 60 * 1000).toISOString()\r\n                }\r\n              ] as ChallengeParticipation[],\r\n              isFirstTimeUser: false,\r\n              isInitialized: true\r\n            })\r\n          } else {\r\n            // Initialize fresh user data for new authenticated users\r\n            set({\r\n              userStats: getInitialUserStats(),\r\n              userAchievements: [],\r\n              userStreak: null,\r\n              userChallengeParticipations: [],\r\n              isFirstTimeUser: false,\r\n              isInitialized: true\r\n            })\r\n          }\r\n        }\r\n      },\r\n\r\n      // Monthly Challenge Management Methods\r\n      updateMilestoneProgress: (challengeId, milestoneId, completed) => {\r\n        set((state) => ({\r\n          userChallengeParticipations: state.userChallengeParticipations.map(p =>\r\n            p.challengeId === challengeId\r\n              ? {\r\n                  ...p,\r\n                  milestoneProgress: {\r\n                    ...p.milestoneProgress,\r\n                    [milestoneId]: completed\r\n                  }\r\n                }\r\n              : p\r\n          )\r\n        }))\r\n      },\r\n\r\n      updateWeeklyProgress: (challengeId, weekData) => {\r\n        set((state) => ({\r\n          userChallengeParticipations: state.userChallengeParticipations.map(p =>\r\n            p.challengeId === challengeId\r\n              ? {\r\n                  ...p,\r\n                  weeklyProgress: p.weeklyProgress\r\n                    ? [...p.weeklyProgress.filter(w => w.week !== weekData.week), weekData]\r\n                    : [weekData]\r\n                }\r\n              : p\r\n          )\r\n        }))\r\n      },\r\n\r\n      updateChallengeStreak: (challengeId, streak) => {\r\n        set((state) => ({\r\n          userChallengeParticipations: state.userChallengeParticipations.map(p =>\r\n            p.challengeId === challengeId\r\n              ? { ...p, currentStreak: streak }\r\n              : p\r\n          )\r\n        }))\r\n      },\r\n\r\n      unlockStoryChapter: (challengeId, week) => {\r\n        set((state) => ({\r\n          userChallengeParticipations: state.userChallengeParticipations.map(p =>\r\n            p.challengeId === challengeId\r\n              ? {\r\n                  ...p,\r\n                  weeklyProgress: p.weeklyProgress?.map(w =>\r\n                    w.week === week\r\n                      ? { ...w, storyUnlocked: true }\r\n                      : w\r\n                  ) || []\r\n                }\r\n              : p\r\n          )\r\n        }))\r\n      },\r\n\r\n      claimMilestoneReward: (challengeId, milestoneId) => {\r\n        // Find the challenge and milestone to get reward details\r\n        const { activeChallenges } = get()\r\n        const challenge = activeChallenges.find(c => c.id === challengeId)\r\n        \r\n        if (challenge) {\r\n          // Add milestone reward logic here\r\n          // For now, just mark milestone as claimed\r\n          set((state) => ({\r\n            userChallengeParticipations: state.userChallengeParticipations.map(p =>\r\n              p.challengeId === challengeId\r\n                ? {\r\n                    ...p,\r\n                    milestoneProgress: {\r\n                      ...p.milestoneProgress,\r\n                      [`${milestoneId}_claimed`]: true\r\n                    }\r\n                  }\r\n                : p\r\n            )\r\n          }))\r\n        }\r\n      },\r\n\r\n      contributeToCommunityGoal: (goalId, contribution) => {\r\n        // Update community goal progress\r\n        // This would typically involve API calls to update server-side data\r\n        // For now, we'll just update local state\r\n        console.log(`Contributing ${contribution} to community goal ${goalId}`)\r\n        \r\n        // Update user stats to reflect contribution\r\n        set((state) => ({\r\n          userStats: {\r\n            ...state.userStats,\r\n            // Add contribution tracking if needed\r\n          }\r\n        }))\r\n      },\r\n\r\n      awardStudyXP: (cardsStudied, correctAnswers) => {\r\n        // Award XP based on study performance\r\n        // Base XP: 1 XP per card studied\r\n        // Bonus XP: 1 additional XP per correct answer (rating higher than \"Again\")\r\n        // Milestone bonus: 10 XP for every 10 cards studied with good performance\r\n        \r\n        let xpGained = cardsStudied // Base XP\r\n        xpGained += correctAnswers // Bonus for correct answers\r\n        \r\n        // Milestone bonus: 10 XP for every 10 cards with good performance\r\n        const milestoneBonus = Math.floor(correctAnswers / 10) * 10\r\n        xpGained += milestoneBonus\r\n        \r\n        if (xpGained > 0) {\r\n          set((state) => {\r\n            const newXP = state.userStats.xp + xpGained\r\n            const newLevel = calculateLevel(newXP)\r\n            const newXPToNextLevel = calculateXPToNextLevel(newLevel)\r\n            \r\n            console.log(` XP Awarded: +${xpGained} XP (${cardsStudied} cards, ${correctAnswers} correct, ${milestoneBonus} milestone bonus)`)\r\n            console.log(` Total XP: ${state.userStats.xp}  ${newXP} (Level ${state.userStats.level}  ${newLevel})`)\r\n            \r\n            return {\r\n              userStats: {\r\n                ...state.userStats,\r\n                xp: newXP,\r\n                level: newLevel,\r\n                xpToNextLevel: newXPToNextLevel,\r\n                totalCards: state.userStats.totalCards + cardsStudied,\r\n                cardsStudiedToday: state.userStats.cardsStudiedToday + cardsStudied\r\n              }\r\n            }\r\n          })\r\n        }\r\n      }\r\n    }),\r\n    {\r\n      name: 'gamification-storage',\r\n      partialize: (state) => ({\r\n        userStats: state.userStats,\r\n        userAchievements: state.userAchievements,\r\n        userStreak: state.userStreak,\r\n        userChallengeParticipations: state.userChallengeParticipations,\r\n        isFirstTimeUser: state.isFirstTimeUser,\r\n        isInitialized: state.isInitialized\r\n      })\r\n    }\r\n  )\r\n)","import { Card, CardType, MediaReference } from '../../../shared/types'\r\n\r\n/**\r\n * Create a new card with all required Anki-style fields populated with defaults\r\n */\r\nexport function createNewCard(\r\n  frontContent: string,\r\n  backContent: string,\r\n  cardType: CardType = { type: 'basic' },\r\n  mediaRefs: MediaReference[] = []\r\n): Omit<Card, 'id' | 'createdAt' | 'deckId' | 'easeFactor' | 'intervalDays' | 'nextReview' | 'reviewCount' | 'lapseCount'> {\r\n  return {\r\n    frontContent,\r\n    backContent,\r\n    cardType,\r\n    mediaRefs,\r\n    \r\n    // Enhanced Anki-style fields with defaults\r\n    state: 'new',\r\n    queue: 0, // 0 = new\r\n    due: 0, // New cards have no due date\r\n    ivl: 0, // No interval yet\r\n    factor: 2500, // Default ease factor (250%)\r\n    reps: 0, // No repetitions yet\r\n    lapses: 0, // No lapses yet\r\n    left: 0, // No learning time left\r\n    \r\n    // Learning state defaults\r\n    learningStep: 0,\r\n    graduationInterval: 1, // Default 1 day\r\n    easyInterval: 4, // Default 4 days\r\n    \r\n    // Timing and performance defaults\r\n    totalStudyTime: 0,\r\n    averageAnswerTime: 0,\r\n    \r\n    // Metadata defaults\r\n    flags: 0,\r\n    originalDue: 0,\r\n    originalDeck: '', // Will be set when card is created\r\n    \r\n    // Gamification defaults\r\n    xpAwarded: 0,\r\n    difficultyRating: 3 // Default medium difficulty\r\n  }\r\n}\r\n\r\n/**\r\n * Create a complete card object for SVG map cards\r\n */\r\nexport function createSvgMapCard(\r\n  id: string,\r\n  deckId: string,\r\n  frontContent: string,\r\n  backContent: string,\r\n  cardType: CardType,\r\n  mediaRefs: MediaReference[] = []\r\n): Card {\r\n  const baseCard = createNewCard(frontContent, backContent, cardType, mediaRefs)\r\n  \r\n  return {\r\n    ...baseCard,\r\n    id,\r\n    deckId,\r\n    createdAt: new Date().toISOString(),\r\n    \r\n    // Legacy fields for backward compatibility\r\n    easeFactor: 2.5,\r\n    intervalDays: 0,\r\n    nextReview: new Date().toISOString(),\r\n    reviewCount: 0,\r\n    lapseCount: 0,\r\n    \r\n    // Set original deck\r\n    originalDeck: deckId\r\n  }\r\n}","import { create } from 'zustand'\nimport { persist } from 'zustand/middleware'\nimport { Deck, Card, DeckSettings } from '../../../shared/types'\nimport { createNewCard } from '../utils/cardDefaults'\n\ninterface StudySession {\n  deckId: string\n  currentCardIndex: number\n  studyCards: Card[] // For in-memory access during a session\n  studyCardIds: string[] // For persistence\n  sessionStats: {\n    total: number\n    correct: number\n    incorrect: number\n  }\n  startedAt: string\n}\n\ninterface DeckStore {\n  decks: Deck[]\n  cards: Record<string, Card[]> // deckId -> cards\n  currentStudySession: StudySession | null\n  isLoading: boolean\n  error: string | null\n  importProgress: number // 0-100\n  importStatus: string | null\n  \n  // Deck operations\n  createDeck: (deck: Omit<Deck, 'id' | 'createdAt' | 'updatedAt'>) => Promise<Deck>\n  updateDeck: (id: string, updates: Partial<Deck>) => Promise<void>\n  deleteDeck: (id: string) => Promise<void>\n  getDeck: (id: string) => Deck | undefined\n  \n  // Card operations\n  addCard: (deckId: string, card: Omit<Card, 'id' | 'deckId' | 'createdAt' | 'easeFactor' | 'intervalDays' | 'nextReview' | 'reviewCount' | 'lapseCount'>) => Promise<Card>\n  addCardBulk: (deckId: string, card: Omit<Card, 'id' | 'deckId' | 'createdAt' | 'easeFactor' | 'intervalDays' | 'nextReview' | 'reviewCount' | 'lapseCount'>) => Promise<Card>\n  addCardsBatch: (deckId: string, cards: Array<Omit<Card, 'id' | 'deckId' | 'createdAt' | 'easeFactor' | 'intervalDays' | 'nextReview' | 'reviewCount' | 'lapseCount'>>) => Promise<Card[]>\n  createDeckBulk: (deck: Omit<Deck, 'id' | 'createdAt' | 'updatedAt'>) => Promise<Deck>\n  updateCard: (cardId: string, updates: Partial<Card>) => Promise<void>\n  deleteCard: (cardId: string) => Promise<void>\n  getCards: (deckId: string) => Card[]\n  \n  // Import operations\n  importAnkiDeck: (file: File) => Promise<Deck>\n  importFromText: (deckName: string, text: string, separator?: string) => Promise<Deck>\n  \n  // Example data\n  loadExampleDecks: () => Promise<void>\n  \n  // Utility\n  clearError: () => void\n  setLoading: (loading: boolean) => void\n  setImportProgress: (progress: number, status?: string) => void\n  resetImportProgress: () => void\n  removeDuplicateCards: (deckId: string) => Promise<number>\n  \n  // Study session functions\n  startStudySession: (deckId: string, studyCards: Card[]) => void\n  updateStudySession: (currentCardIndex: number, sessionStats: StudySession['sessionStats']) => void\n  clearStudySession: () => void\n  getStudySession: (deckId: string) => StudySession | null\n  resetAllStudyData: () => void\n}\n\nconst defaultDeckSettings: DeckSettings = {\n  newCardsPerDay: 20,\n  maxReviewsPerDay: 100,\n  easyBonus: 1.3,\n  intervalModifier: 1.0,\n  maximumInterval: 36500, // 100 years\n  minimumInterval: 1\n}\n\n// Helper function to clean field content\nconst cleanFieldContent = (content: string): string => {\n  return content\n    .replace(/<[^>]*>/g, '') // Remove HTML tags\n    .replace(/&nbsp;/g, ' ')\n    .replace(/&lt;/g, '<')\n    .replace(/&gt;/g, '>')\n    .replace(/&amp;/g, '&')\n    .replace(/\\[sound:[^\\]]*\\]/g, '') // Remove sound references\n    .trim()\n}\n\n// Helper function to detect the best field combination for front/back\nconst detectBestFieldCombination = (sampleFields: string[][]): { frontIndex: number; backIndex: number } => {\n  if (sampleFields.length === 0) {\n    return { frontIndex: 0, backIndex: 1 }\n  }\n  \n  const fieldCount = sampleFields[0].length\n  const combinations: Array<{ frontIndex: number; backIndex: number; score: number }> = []\n  \n  // Try different field combinations\n  for (let front = 0; front < fieldCount; front++) {\n    for (let back = front + 1; back < fieldCount; back++) {\n      let score = 0\n      let validPairs = 0\n      \n      for (const fields of sampleFields) {\n        const frontContent = cleanFieldContent(fields[front] || '')\n        const backContent = cleanFieldContent(fields[back] || '')\n        \n        // Score based on content quality\n        if (frontContent && backContent) {\n          validPairs++\n          \n          // Prefer combinations where both fields have substantial content\n          if (frontContent.length > 2 && backContent.length > 2) {\n            score += 10\n          }\n          \n          // Prefer combinations where fields are different\n          if (frontContent !== backContent) {\n            score += 5\n          }\n          \n          // Avoid fields that look like audio references or numbers only\n          if (!frontContent.match(/^\\[sound:/) && !backContent.match(/^\\[sound:/)) {\n            score += 3\n          }\n          \n          if (!frontContent.match(/^\\d+$/) && !backContent.match(/^\\d+$/)) {\n            score += 2\n          }\n        }\n      }\n      \n      // Normalize score by number of valid pairs\n      const normalizedScore = validPairs > 0 ? score / validPairs : 0\n      combinations.push({ frontIndex: front, backIndex: back, score: normalizedScore })\n    }\n  }\n  \n  // Sort by score and return the best combination\n  combinations.sort((a, b) => b.score - a.score)\n  \n  if (combinations.length > 0 && combinations[0].score > 0) {\n    console.log(`Best field combination: ${combinations[0].frontIndex} -> ${combinations[0].backIndex} (score: ${combinations[0].score})`)\n    return { frontIndex: combinations[0].frontIndex, backIndex: combinations[0].backIndex }\n  }\n  \n  // Fallback to 0->1 or 0->2 if available\n  if (fieldCount >= 3) {\n    return { frontIndex: 0, backIndex: 2 }\n  }\n  return { frontIndex: 0, backIndex: 1 }\n}\n\n// Helper function to parse .apkg files (with dynamic imports for bundle optimization)\nconst parseApkgFile = async (file: File): Promise<{ name: string; cards: Array<{ front: string; back: string }> }> => {\n  try {\n    // Dynamic imports to reduce initial bundle size\n    const [{ default: JSZip }, { default: initSqlJs }] = await Promise.all([\n      import('jszip'),\n      import('sql.js')\n    ])\n\n    // Initialize SQL.js\n    const SQL = await initSqlJs({\n      locateFile: (file) => {\n        if (file.endsWith('.wasm')) {\n          return '/sql-wasm.wasm'\n        }\n        return `/${file}`\n      }\n    })\n\n    // Read the .apkg file as array buffer\n    const arrayBuffer = await file.arrayBuffer()\n    \n    // Extract the ZIP file\n    const zip = new JSZip()\n    const zipContent = await zip.loadAsync(arrayBuffer)\n    \n    // Get the collection.anki2 file (SQLite database)\n    const dbFile = zipContent.file('collection.anki2')\n    if (!dbFile) {\n      throw new Error('Invalid .apkg file: collection.anki2 not found')\n    }\n    \n    // Read the database file\n    const dbArrayBuffer = await dbFile.async('arraybuffer')\n    const db = new SQL.Database(new Uint8Array(dbArrayBuffer))\n    \n    // Query to get deck name from the col table\n    const deckQuery = db.exec(\"SELECT decks FROM col LIMIT 1\")\n    let deckName = file.name.replace(/\\.apkg$/, '')\n    if (deckQuery.length > 0 && deckQuery[0].values.length > 0) {\n      try {\n        const decksJson = deckQuery[0].values[0][0] as string\n        const decks = JSON.parse(decksJson)\n        // Find the first non-default deck (id != 1)\n        const deckIds = Object.keys(decks).filter(id => id !== '1')\n        if (deckIds.length > 0) {\n          deckName = decks[deckIds[0]].name || deckName\n        }\n      } catch (e) {\n        console.warn('Could not parse deck names from .apkg file, using filename')\n      }\n    }\n    \n    // Query to get notes and cards\n    const notesQuery = db.exec(`\n      SELECT n.flds, n.tags, c.type\n      FROM notes n\n      JOIN cards c ON n.id = c.nid\n      WHERE c.type >= 0\n      ORDER BY n.id\n    `)\n    \n    const cards: Array<{ front: string; back: string }> = []\n    \n    if (notesQuery.length > 0) {\n      // First, analyze a sample of fields to determine the best field combination\n      const sampleSize = Math.min(10, notesQuery[0].values.length)\n      const sampleFields: string[][] = []\n      \n      for (let i = 0; i < sampleSize; i++) {\n        const fields = (notesQuery[0].values[i][0] as string).split('\\x1f')\n        sampleFields.push(fields)\n      }\n      \n      // Detect the best field combination\n      const { frontIndex, backIndex } = detectBestFieldCombination(sampleFields)\n      console.log(`Using field combination: ${frontIndex} (front) -> ${backIndex} (back)`)\n      \n      // Process all cards using the detected field combination\n      for (const row of notesQuery[0].values) {\n        const fields = (row[0] as string).split('\\x1f') // Anki uses \\x1f as field separator\n        \n        if (fields.length > Math.max(frontIndex, backIndex)) {\n          const front = cleanFieldContent(fields[frontIndex] || '')\n          const back = cleanFieldContent(fields[backIndex] || '')\n          \n          if (front && back && front !== back) {\n            cards.push({ front, back })\n          }\n        }\n      }\n    }\n    \n    db.close()\n    \n    if (cards.length === 0) {\n      throw new Error('No valid cards found in the .apkg file')\n    }\n    \n    console.log(`Successfully parsed ${cards.length} cards from .apkg file`)\n    return { name: deckName, cards }\n  } catch (error) {\n    console.error('Error parsing .apkg file:', error)\n    throw new Error(`Failed to parse .apkg file: ${error instanceof Error ? error.message : 'Unknown error'}`)\n  }\n}\n\nexport const useDeckStore = create<DeckStore>()(\n  persist(\n    (set, get) => ({\n      decks: [],\n      cards: {},\n      currentStudySession: null,\n      isLoading: false,\n      error: null,\n      importProgress: 0,\n      importStatus: null,\n\n      createDeck: async (deckData) => {\n        set({ isLoading: true, error: null })\n        try {\n          const deck: Deck = {\n            ...deckData,\n            id: crypto.randomUUID(),\n            createdAt: new Date().toISOString(),\n            updatedAt: new Date().toISOString(),\n            settings: { ...defaultDeckSettings, ...deckData.settings }\n          }\n          \n          set(state => ({\n            decks: [...state.decks, deck],\n            cards: { ...state.cards, [deck.id]: [] },\n            isLoading: false\n          }))\n          \n          return deck\n        } catch (error) {\n          set({ error: 'Failed to create deck', isLoading: false })\n          throw error\n        }\n      },\n\n      updateDeck: async (id, updates) => {\n        set({ isLoading: true, error: null })\n        try {\n          set(state => ({\n            decks: state.decks.map(deck => \n              deck.id === id \n                ? { ...deck, ...updates, updatedAt: new Date().toISOString() }\n                : deck\n            ),\n            isLoading: false\n          }))\n        } catch (error) {\n          set({ error: 'Failed to update deck', isLoading: false })\n          throw error\n        }\n      },\n\n      deleteDeck: async (id) => {\n        set({ isLoading: true, error: null })\n        try {\n          set(state => {\n            // eslint-disable-next-line @typescript-eslint/no-unused-vars\n            const { [id]: _deletedCards, ...remainingCards } = state.cards\n            return {\n              decks: state.decks.filter(deck => deck.id !== id),\n              cards: remainingCards,\n              isLoading: false\n            }\n          })\n        } catch (error) {\n          set({ error: 'Failed to delete deck', isLoading: false })\n          throw error\n        }\n      },\n\n      getDeck: (id) => {\n        return get().decks.find(deck => deck.id === id)\n      },\n\n      addCard: async (deckId, cardData) => {\n        set({ isLoading: true, error: null })\n        try {\n          const card: Card = {\n            ...cardData,\n            id: crypto.randomUUID(),\n            deckId,\n            createdAt: new Date().toISOString(),\n            easeFactor: 2.5,\n            intervalDays: 0,\n            nextReview: new Date().toISOString(),\n            reviewCount: 0,\n            lapseCount: 0\n          }\n          \n          set(state => {\n            const deckCards = state.cards[deckId] || []\n            const updatedCards = [...deckCards, card]\n            \n            return {\n              cards: { ...state.cards, [deckId]: updatedCards },\n              decks: state.decks.map(deck => \n                deck.id === deckId \n                  ? { ...deck, cardCount: updatedCards.length, updatedAt: new Date().toISOString() }\n                  : deck\n              ),\n              isLoading: false\n            }\n          })\n          \n          return card\n        } catch (error) {\n          set({ error: 'Failed to add card', isLoading: false })\n          throw error\n        }\n      },\n\n      addCardBulk: async (deckId, cardData) => {\n        try {\n          const state = get()\n          const existingCards = state.cards[deckId] || []\n          \n          // Check if this card already exists\n          const cardKey = `${cardData.frontContent.trim().toLowerCase()}|${cardData.backContent.trim().toLowerCase()}`\n          const isDuplicate = existingCards.some(card =>\n            `${card.frontContent.trim().toLowerCase()}|${card.backContent.trim().toLowerCase()}` === cardKey\n          )\n          \n          if (isDuplicate) {\n            console.log('Skipping duplicate card:', cardData.frontContent)\n            // Return a dummy card to maintain the interface, but don't add it\n            return {\n              ...cardData,\n              id: 'duplicate-skipped',\n              deckId,\n              createdAt: new Date().toISOString(),\n              easeFactor: 2.5,\n              intervalDays: 0,\n              nextReview: new Date().toISOString(),\n              reviewCount: 0,\n              lapseCount: 0\n            }\n          }\n          \n          const card: Card = {\n            ...cardData,\n            id: crypto.randomUUID(),\n            deckId,\n            createdAt: new Date().toISOString(),\n            easeFactor: 2.5,\n            intervalDays: 0,\n            nextReview: new Date().toISOString(),\n            reviewCount: 0,\n            lapseCount: 0\n          }\n          \n          set(state => {\n            const deckCards = state.cards[deckId] || []\n            const updatedCards = [...deckCards, card]\n            \n            return {\n              cards: { ...state.cards, [deckId]: updatedCards },\n              decks: state.decks.map(deck =>\n                deck.id === deckId\n                  ? { ...deck, cardCount: updatedCards.length, updatedAt: new Date().toISOString() }\n                  : deck\n              )\n            }\n          })\n          \n          return card\n        } catch (error) {\n          console.error('Failed to add card during bulk import:', error)\n          throw error\n        }\n      },\n\n      createDeckBulk: async (deckData) => {\n        try {\n          const deck: Deck = {\n            ...deckData,\n            id: crypto.randomUUID(),\n            createdAt: new Date().toISOString(),\n            updatedAt: new Date().toISOString(),\n            settings: { ...defaultDeckSettings, ...deckData.settings }\n          }\n          \n          set(state => ({\n            decks: [...state.decks, deck],\n            cards: { ...state.cards, [deck.id]: [] }\n          }))\n          \n          return deck\n        } catch (error) {\n          console.error('Failed to create deck during bulk import:', error)\n          throw error\n        }\n      },\n\n      addCardsBatch: async (deckId, cardsData) => {\n        try {\n          const state = get()\n          const existingCards = state.cards[deckId] || []\n          \n          // Create a Set of existing card content for fast lookup\n          const existingCardSet = new Set(\n            existingCards.map(card => `${card.frontContent.trim().toLowerCase()}|${card.backContent.trim().toLowerCase()}`)\n          )\n          \n          // Filter out duplicates and create new cards\n          const uniqueCardsData = cardsData.filter(cardData => {\n            const cardKey = `${cardData.frontContent.trim().toLowerCase()}|${cardData.backContent.trim().toLowerCase()}`\n            return !existingCardSet.has(cardKey)\n          })\n          \n          console.log(`Batch processing: ${cardsData.length} cards submitted, ${uniqueCardsData.length} unique cards to add`)\n          \n          if (uniqueCardsData.length === 0) {\n            console.log('No new unique cards to add in this batch')\n            return []\n          }\n          \n          const cards: Card[] = uniqueCardsData.map(cardData => ({\n            ...cardData,\n            id: crypto.randomUUID(),\n            deckId,\n            createdAt: new Date().toISOString(),\n            easeFactor: 2.5,\n            intervalDays: 0,\n            nextReview: new Date().toISOString(),\n            reviewCount: 0,\n            lapseCount: 0\n          }))\n          \n          set(state => {\n            const deckCards = state.cards[deckId] || []\n            const updatedCards = [...deckCards, ...cards]\n            \n            return {\n              cards: { ...state.cards, [deckId]: updatedCards },\n              decks: state.decks.map(deck =>\n                deck.id === deckId\n                  ? { ...deck, cardCount: updatedCards.length, updatedAt: new Date().toISOString() }\n                  : deck\n              )\n            }\n          })\n          \n          return cards\n        } catch (error) {\n          console.error('Failed to add cards during batch import:', error)\n          throw error\n        }\n      },\n\n      updateCard: async (cardId, updates) => {\n        set({ isLoading: true, error: null })\n        try {\n          set(state => {\n            const newCards = { ...state.cards }\n            for (const deckId in newCards) {\n              newCards[deckId] = newCards[deckId].map(card =>\n                card.id === cardId ? { ...card, ...updates } : card\n              )\n            }\n            return { cards: newCards, isLoading: false }\n          })\n        } catch (error) {\n          set({ error: 'Failed to update card', isLoading: false })\n          throw error\n        }\n      },\n\n      deleteCard: async (cardId) => {\n        set({ isLoading: true, error: null })\n        try {\n          set(state => {\n            const newCards = { ...state.cards }\n            let targetDeckId = ''\n            \n            for (const deckId in newCards) {\n              const cardIndex = newCards[deckId].findIndex(card => card.id === cardId)\n              if (cardIndex !== -1) {\n                newCards[deckId] = newCards[deckId].filter(card => card.id !== cardId)\n                targetDeckId = deckId\n                break\n              }\n            }\n            \n            return {\n              cards: newCards,\n              decks: state.decks.map(deck => \n                deck.id === targetDeckId \n                  ? { ...deck, cardCount: newCards[targetDeckId].length, updatedAt: new Date().toISOString() }\n                  : deck\n              ),\n              isLoading: false\n            }\n          })\n        } catch (error) {\n          set({ error: 'Failed to delete card', isLoading: false })\n          throw error\n        }\n      },\n\n      getCards: (deckId) => {\n        return get().cards[deckId] || []\n      },\n\n      importAnkiDeck: async (file) => {\n        const { setImportProgress, resetImportProgress } = get()\n        set({ isLoading: true, error: null })\n        resetImportProgress()\n        \n        try {\n          const fileName = file.name.toLowerCase()\n          \n          // Handle different file types\n          if (fileName.endsWith('.apkg')) {\n            setImportProgress(10, 'Reading file...')\n            \n            // Parse .apkg file using the new parser\n            const { name, cards } = await parseApkgFile(file)\n\n            // Check if deck with the same name already exists\n            const existingDeck = get().decks.find(d => d.title === name);\n            if (existingDeck) {\n              throw new Error(`A deck named \"${name}\" already exists. Please rename the deck or the file before importing.`);\n            }\n            \n            setImportProgress(30, 'Creating deck...')\n            \n            // Create deck\n            const deck = await get().createDeckBulk({\n              userId: 'current-user',\n              title: name,\n              description: `Imported Anki deck with ${cards.length} cards`,\n              cardCount: 0,\n              isPublic: false,\n              settings: defaultDeckSettings,\n              category: 'imported'\n            })\n            \n            setImportProgress(40, `Importing ${cards.length} cards...`)\n            \n            // Remove duplicates from cards before batch processing\n            const uniqueCards: typeof cards = []\n            const seenCards = new Set<string>()\n            \n            for (const card of cards) {\n              const cardKey = `${card.front.trim().toLowerCase()}|${card.back.trim().toLowerCase()}`\n              if (!seenCards.has(cardKey)) {\n                seenCards.add(cardKey)\n                uniqueCards.push(card)\n              }\n            }\n            \n            console.log(`Removed ${cards.length - uniqueCards.length} duplicates from Anki cards. Processing ${uniqueCards.length} unique cards.`)\n            \n            // Process unique cards in smaller batches for better performance and reliability\n            const batchSize = 100\n            let successfulImports = 0\n            const totalCards = uniqueCards.length\n            \n            console.log(`Starting batch import of ${totalCards} unique cards`)\n            \n            for (let i = 0; i < totalCards; i += batchSize) {\n              const batch = uniqueCards.slice(i, i + batchSize)\n              const batchCards = batch.map(cardData => createNewCard(\n                cardData.front,\n                cardData.back,\n                { type: 'basic' as const },\n                []\n              ))\n              \n              try {\n                console.log(`Processing batch ${Math.floor(i / batchSize) + 1}/${Math.ceil(totalCards / batchSize)} (${batch.length} cards)`)\n                await get().addCardsBatch(deck.id, batchCards)\n                successfulImports += batch.length\n                \n                // Update progress (40% to 90% for card import)\n                const cardProgress = 40 + (50 * Math.min(i + batchSize, totalCards) / totalCards)\n                setImportProgress(cardProgress, `Imported ${successfulImports}/${totalCards} cards...`)\n                \n                console.log(`Batch completed. Progress: ${cardProgress.toFixed(1)}%`)\n                \n                // Add small delay to allow UI updates\n                await new Promise(resolve => setTimeout(resolve, 50))\n              } catch (cardError) {\n                console.error('Failed to import batch:', cardError)\n                // Try individual cards in this batch as fallback\n                for (const originalCard of batch) {\n                  try {\n                    await get().addCardBulk(deck.id, createNewCard(\n                      originalCard.front,\n                      originalCard.back,\n                      { type: 'basic' as const },\n                      []\n                    ))\n                    successfulImports++\n                  } catch (individualError) {\n                    console.warn('Failed to import individual card:', originalCard, individualError)\n                  }\n                }\n                \n                // Update progress even after fallback\n                const cardProgress = 40 + (50 * Math.min(i + batchSize, totalCards) / totalCards)\n                setImportProgress(cardProgress, `Imported ${successfulImports}/${totalCards} cards...`)\n              }\n            }\n            \n            console.log(`Batch import completed. Total successful: ${successfulImports}`)\n            \n            setImportProgress(95, 'Finalizing import...')\n            \n            // Update deck description with final count\n            await get().updateDeck(deck.id, {\n              description: `Imported Anki deck with ${successfulImports} cards`\n            })\n            \n            setImportProgress(100, 'Import completed!')\n            \n            // Clear progress after a short delay\n            setTimeout(() => {\n              resetImportProgress()\n            }, 1000)\n            \n            set({ isLoading: false })\n            return deck\n          } else if (fileName.endsWith('.txt') || fileName.endsWith('.tsv') || fileName.endsWith('.csv')) {\n            setImportProgress(10, 'Reading text file...')\n            \n            // Handle text-based imports\n            const text = await file.text()\n            \n            // Detect separator\n            let separator = '\\t' // Corrected: \t is a tab character\n            if (fileName.endsWith('.csv')) {\n              separator = ','\n            }\n            \n            setImportProgress(20, 'Processing text content...')\n            \n            // Clean the text and handle encoding issues\n            const cleanText = text\n              .replace(/\\r\\n/g, '\\n')  // Normalize line endings\n              .replace(/\\r/g, '\\n')    // Handle old Mac line endings\n              .trim()\n            \n            const deck = await get().importFromText(\n              file.name.replace(/\\.[^/.]+$/, \"\"),\n              cleanText,\n              separator\n            )\n            set({ isLoading: false })\n            return deck\n          } else {\n            setImportProgress(10, 'Reading file as text...')\n            \n            // Try to parse as text anyway\n            const text = await file.text()\n            \n            setImportProgress(20, 'Processing content...')\n            \n            const cleanText = text\n              .replace(/\\r\\n/g, '\\n')\n              .replace(/\\r/g, '\\n')\n              .trim()\n            \n            const deck = await get().importFromText(\n              file.name.replace(/\\.[^/.]+$/, \"\"),\n              cleanText,\n              '\\t'\n            )\n            set({ isLoading: false })\n            return deck\n          }\n        } catch (error) {\n          const errorMessage = error instanceof Error ? error.message : 'Failed to import Anki deck'\n          set({ error: errorMessage, isLoading: false })\n          resetImportProgress()\n          throw error\n        }\n      },\n\n      importFromText: async (deckName, text, separator = '\\t') => {\n        const { setImportProgress, resetImportProgress } = get()\n        set({ isLoading: true, error: null })\n        \n        try {\n          setImportProgress(30, 'Processing text content...')\n          \n          // Clean and normalize the text\n          const cleanText = text\n            .replace(/\\r\\n/g, '\\n')  // Normalize Windows line endings\n            .replace(/\\r/g, '\\n')    // Handle old Mac line endings\n            .replace(/\\\\u0000/g, '')  // Remove null characters\n            .replace(/[\\\\u0001-\\\\u0008\\\\u000B\\\\u000C\\\\u000E-\\\\u001F\\\\u007F]/g, '') // Remove control characters\n            .trim()\n          \n          const lines = cleanText\n            .split('\\n')\n            .map(line => line.trim())\n            .filter(line => line.length > 0)\n          \n          if (lines.length === 0) {\n            throw new Error('No valid content found in the file')\n          }\n          \n          setImportProgress(40, 'Creating deck...')\n          \n          const deck = await get().createDeckBulk({\n            userId: 'current-user', // This would come from auth store\n            title: deckName,\n            description: `Imported deck with ${lines.length} cards`,\n            cardCount: 0,\n            isPublic: false,\n            settings: defaultDeckSettings,\n            category: 'imported'\n          })\n          \n          setImportProgress(50, `Importing ${lines.length} cards...`)\n          \n          // Process lines and prepare cards for batch import\n          const validCards: Array<Omit<Card, 'id' | 'createdAt' | 'deckId' | 'easeFactor' | 'intervalDays' | 'nextReview' | 'reviewCount' | 'lapseCount'>> = []\n          let skippedLines = 0\n          \n          // First pass: parse and validate all lines\n          for (let i = 0; i < lines.length; i++) {\n            const line = lines[i]\n            try {\n              // Handle quoted fields (CSV style)\n              let parts: string[]\n              if (separator === ',' && line.includes('\"')) {\n                // Simple CSV parsing for quoted fields\n                parts = line.split(',').map(part =>\n                  part.replace(/^\"(.*)\"$/, '$1').trim()\n                )\n              } else {\n                parts = line.split(separator)\n              }\n              \n              if (parts.length >= 2) {\n                const front = parts[0].trim()\n                const back = parts[1].trim()\n                \n                // Skip empty cards\n                if (front && back) {\n                  validCards.push(createNewCard(\n                    front,\n                    back,\n                    { type: 'basic' as const },\n                    []\n                  ))\n                } else {\n                  skippedLines++\n                }\n              } else {\n                skippedLines++\n              }\n            } catch (cardError) {\n              console.warn('Failed to parse line:', line, cardError)\n              skippedLines++\n            }\n          }\n          \n          // Remove duplicates from validCards before batch processing\n          const uniqueValidCards: typeof validCards = []\n          const seenCards = new Set<string>()\n          \n          for (const card of validCards) {\n            const cardKey = `${card.frontContent.trim().toLowerCase()}|${card.backContent.trim().toLowerCase()}`\n            if (!seenCards.has(cardKey)) {\n              seenCards.add(cardKey)\n              uniqueValidCards.push(card)\n            }\n          }\n          \n          console.log(`Removed ${validCards.length - uniqueValidCards.length} duplicates from parsed cards. Processing ${uniqueValidCards.length} unique cards.`)\n          \n          // Second pass: batch import unique cards\n          const batchSize = 100\n          let successfulImports = 0\n          \n          console.log(`Starting text import batch processing of ${uniqueValidCards.length} unique cards`)\n          \n          for (let i = 0; i < uniqueValidCards.length; i += batchSize) {\n            const batch = uniqueValidCards.slice(i, i + batchSize)\n            \n            try {\n              console.log(`Processing text batch ${Math.floor(i / batchSize) + 1}/${Math.ceil(uniqueValidCards.length / batchSize)} (${batch.length} cards)`)\n              const addedCards = await get().addCardsBatch(deck.id, batch)\n              successfulImports += addedCards.length\n              \n              // Update progress (50% to 90% for card import)\n              const cardProgress = 50 + (40 * Math.min(i + batchSize, uniqueValidCards.length) / uniqueValidCards.length)\n              setImportProgress(cardProgress, `Imported ${successfulImports}/${uniqueValidCards.length} cards...`)\n              \n              console.log(`Text batch completed. Progress: ${cardProgress.toFixed(1)}%, Added: ${addedCards.length} cards`)\n              \n              // Add small delay to allow UI updates\n              await new Promise(resolve => setTimeout(resolve, 50))\n            } catch (cardError) {\n              console.error('Failed to import text batch:', cardError)\n              // Try individual cards in this batch as fallback\n              for (const cardData of batch) {\n                try {\n                  const addedCard = await get().addCardBulk(deck.id, cardData)\n                  if (addedCard.id !== 'duplicate-skipped') {\n                    successfulImports++\n                  }\n                } catch (individualError) {\n                  console.warn('Failed to import individual text card:', cardData, individualError)\n                }\n              }\n              \n              // Update progress even after fallback\n              const cardProgress = 50 + (40 * Math.min(i + batchSize, uniqueValidCards.length) / uniqueValidCards.length)\n              setImportProgress(cardProgress, `Imported ${successfulImports}/${uniqueValidCards.length} cards...`)\n            }\n          }\n          \n          console.log(`Text import batch processing completed. Total successful: ${successfulImports}`)\n          \n          setImportProgress(95, 'Finalizing import...')\n          \n          // Update deck description with import results\n          await get().updateDeck(deck.id, {\n            description: `Imported deck with ${successfulImports} cards${skippedLines > 0 ? ` (${skippedLines} lines skipped)` : ''}`\n          })\n          \n          if (successfulImports === 0) {\n            throw new Error('No valid cards could be imported. Please check the file format.')\n          }\n          \n          setImportProgress(100, 'Import completed!')\n          \n          // Clear progress after a short delay\n          setTimeout(() => {\n            resetImportProgress()\n          }, 1000)\n          \n          set({ isLoading: false })\n          return deck\n        } catch (error) {\n          set({ error: 'Failed to import from text', isLoading: false })\n          resetImportProgress()\n          throw error\n        }\n      },\n\n      loadExampleDecks: async () => {\n        set({ isLoading: true, error: null })\n        try {\n          const state = get()\n          \n          // Check if example decks already exist to prevent duplicates\n          const existingTitles = new Set(state.decks.map(deck => deck.title))\n          const exampleTitles = ['Spanish Vocabulary', 'JavaScript Concepts', 'World Capitals']\n          \n          // If any example deck already exists, don't load any\n          if (exampleTitles.some(title => existingTitles.has(title))) {\n            console.log('Example decks already exist, skipping load')\n            set({ isLoading: false })\n            return\n          }\n\n          const exampleDecks = [\n            {\n              title: 'Spanish Vocabulary',\n              description: 'Essential Spanish words for beginners',\n              category: 'language',\n              cards: [\n                { front: 'Hello', back: 'Hola' },\n                { front: 'Goodbye', back: 'Adis' },\n                { front: 'Thank you', back: 'Gracias' },\n                { front: 'Please', back: 'Por favor' },\n                { front: 'Yes', back: 'S' },\n                { front: 'No', back: 'No' },\n                { front: 'Water', back: 'Agua' },\n                { front: 'Food', back: 'Comida' },\n                { front: 'House', back: 'Casa' },\n                { front: 'Car', back: 'Coche' }\n              ]\n            },\n            {\n              title: 'JavaScript Concepts',\n              description: 'Important JavaScript programming concepts',\n              category: 'programming',\n              cards: [\n                { front: 'What is a closure?', back: 'A closure is a function that has access to variables in its outer (enclosing) scope even after the outer function has returned.' },\n                { front: 'What is hoisting?', back: 'Hoisting is JavaScript\\'s default behavior of moving declarations to the top of their scope.' },\n                { front: 'What is the difference between let and var?', back: 'let has block scope and cannot be redeclared, while var has function scope and can be redeclared.' },\n                { front: 'What is a Promise?', back: 'A Promise is an object representing the eventual completion or failure of an asynchronous operation.' },\n                { front: 'What is async/await?', back: 'async/await is syntactic sugar for working with Promises, making asynchronous code look more like synchronous code.' }\n              ]\n            },\n            {\n              title: 'World Capitals',\n              description: 'Capital cities of countries around the world',\n              category: 'geography',\n              cards: [\n                { front: 'France', back: 'Paris' },\n                { front: 'Germany', back: 'Berlin' },\n                { front: 'Italy', back: 'Rome' },\n                { front: 'Spain', back: 'Madrid' },\n                { front: 'United Kingdom', back: 'London' },\n                { front: 'Japan', back: 'Tokyo' },\n                { front: 'China', back: 'Beijing' },\n                { front: 'Australia', back: 'Canberra' },\n                { front: 'Brazil', back: 'Braslia' },\n                { front: 'Canada', back: 'Ottawa' }\n              ]\n            }\n          ]\n\n          console.log('Loading example decks...')\n          for (const deckData of exampleDecks) {\n            const deck = await get().createDeck({\n              userId: 'current-user',\n              title: deckData.title,\n              description: deckData.description,\n              cardCount: 0,\n              isPublic: false,\n              settings: defaultDeckSettings,\n              category: deckData.category,\n              tags: [deckData.category]\n            })\n\n            for (const cardData of deckData.cards) {\n              await get().addCard(deck.id, createNewCard(\n                cardData.front,\n                cardData.back,\n                { type: 'basic' },\n                []\n              ))\n            }\n          }\n\n          console.log('Example decks loaded successfully')\n          set({ isLoading: false })\n        } catch (error) {\n          set({ error: 'Failed to load example decks', isLoading: false })\n          throw error\n        }\n      },\n\n      clearError: () => set({ error: null }),\n      setLoading: (loading) => set({ isLoading: loading }),\n      removeDuplicateCards: async (deckId) => {\n        try {\n          const state = get()\n          const deckCards = state.cards[deckId] || []\n          \n          if (deckCards.length === 0) {\n            return 0\n          }\n          \n          // Create a Map to track unique cards (first occurrence wins)\n          const uniqueCardsMap = new Map<string, Card>()\n          let duplicatesRemoved = 0\n          \n          for (const card of deckCards) {\n            const cardKey = `${card.frontContent.trim().toLowerCase()}|${card.backContent.trim().toLowerCase()}`\n            \n            if (!uniqueCardsMap.has(cardKey)) {\n              uniqueCardsMap.set(cardKey, card)\n            } else {\n              duplicatesRemoved++\n              console.log(`Removing duplicate card: ${card.frontContent}`)\n            }\n          }\n          \n          const uniqueCards = Array.from(uniqueCardsMap.values())\n          \n          if (duplicatesRemoved > 0) {\n            set(state => ({\n              cards: { ...state.cards, [deckId]: uniqueCards },\n              decks: state.decks.map(deck =>\n                deck.id === deckId\n                  ? { ...deck, cardCount: uniqueCards.length, updatedAt: new Date().toISOString() }\n                  : deck\n              )\n            }))\n            \n            console.log(`Removed ${duplicatesRemoved} duplicate cards from deck. ${uniqueCards.length} unique cards remaining.`)\n          }\n          \n          return duplicatesRemoved\n        } catch (error) {\n          console.error('Failed to remove duplicate cards:', error)\n          throw error\n        }\n      },\n\n      setImportProgress: (progress, status) => set({ importProgress: progress, importStatus: status }),\n      resetImportProgress: () => set({ importProgress: 0, importStatus: null }),\n\n      // Study session functions\n            startStudySession: (deckId, studyCards) => {\n        const studyCardIds = studyCards.map(c => c.id);\n        set({\n          currentStudySession: {\n            deckId,\n            currentCardIndex: 0,\n            studyCards, // Keep full cards for in-memory access\n            studyCardIds, // Add the IDs for persistence\n            sessionStats: {\n              total: studyCards.length,\n              correct: 0,\n              incorrect: 0\n            },\n            startedAt: new Date().toISOString()\n          }\n        })\n      },\n\n      updateStudySession: (currentCardIndex, sessionStats) => {\n        set(state => ({\n          currentStudySession: state.currentStudySession ? {\n            ...state.currentStudySession,\n            currentCardIndex,\n            sessionStats\n          } : null\n        }))\n      },\n\n      clearStudySession: () => {\n        set({ currentStudySession: null })\n      },\n\n      getStudySession: (deckId) => {\n        const state = get()\n        return state.currentStudySession?.deckId === deckId ? state.currentStudySession : null\n      },\n\n      resetAllStudyData: () => {\n        // Reset all study-related data but keep decks and cards\n        set(state => {\n          // Reset all card progress data\n          const resetCards: Record<string, Card[]> = {}\n          \n          for (const [deckId, cards] of Object.entries(state.cards)) {\n            resetCards[deckId] = cards.map(card => ({\n              ...card,\n              easeFactor: 2.5,\n              intervalDays: 0,\n              nextReview: new Date().toISOString(),\n              reviewCount: 0,\n              lapseCount: 0\n            }))\n          }\n          \n          return {\n            cards: resetCards,\n            currentStudySession: null\n          }\n        })\n      }\n    }),\n    {\n      name: 'deck-storage',\n      // This function selects which parts of the state to save\n      partialize: (state) => {\n        // 1. Exclude the top-level 'cards' object entirely.\n        // 2. From the 'currentStudySession', exclude the 'studyCards' array of full objects.\n        const { cards, currentStudySession, ...restOfState } = state;\n\n        const sessionToPersist = currentStudySession\n          ? {\n              deckId: currentStudySession.deckId,\n              currentCardIndex: currentStudySession.currentCardIndex,\n              studyCardIds: currentStudySession.studyCardIds, // Only persist the IDs\n              sessionStats: currentStudySession.sessionStats,\n              startedAt: currentStudySession.startedAt,\n            }\n          : null;\n\n        // Return a new object containing only the data we want to persist.\n        // Note: `decks` are preserved via `restOfState`.\n        return { ...restOfState, currentStudySession: sessionToPersist };\n      },\n    }\n  )\n)\n\nexport const useCurrentCard = (): Card | null => {\n  const store = useDeckStore();\n  const session = store.currentStudySession;\n\n  if (!session || !session.studyCardIds || session.studyCardIds.length === 0) {\n    return null;\n  }\n\n  const currentCardId = session.studyCardIds[session.currentCardIndex];\n  if (!currentCardId) {\n    return null;\n  }\n\n  // The full, non-persisted `cards` object holds all cards for the current deck.\n  const deckCards = store.cards[session.deckId] || [];\n  return deckCards.find(card => card.id === currentCardId) || null;\n};"],"file":"assets/stores-BMPtdeoH.js"}