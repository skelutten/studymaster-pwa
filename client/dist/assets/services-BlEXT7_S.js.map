{"version":3,"file":"services-BlEXT7_S.js","sources":["../../src/services/errorTrackingService.tsx","../../src/services/localProfileService.ts","../../src/services/onlineLinkService.ts","../../src/utils/hash.ts","../../src/services/mediaStorageService.ts","../../src/services/userDataService.ts","../../src/services/exportImportService.ts","../../src/services/leaderboard.ts","../../src/services/realTimeDataService.ts","../../src/services/uamsApiService.ts","../../src/services/unifiedQueueManager.ts","../../src/services/environmental/environmentalContextService.ts","../../src/services/storage/StorageManager.ts","../../src/services/syncQueueFlusher.ts"],"sourcesContent":["// Basic error tracking service for StudyMaster PWA\r\n\r\nimport React from 'react'\r\n\r\nexport interface ErrorReport {\r\n  id: string\r\n  timestamp: string\r\n  level: 'error' | 'warning' | 'info'\r\n  message: string\r\n  stack?: string\r\n  userAgent?: string\r\n  url?: string\r\n  userId?: string\r\n  sessionId?: string\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  context?: Record<string, any>\r\n}\r\n\r\nexport interface ErrorTrackingConfig {\r\n  maxStoredErrors: number\r\n  enableConsoleLogging: boolean\r\n  enableLocalStorage: boolean\r\n  apiEndpoint?: string\r\n  apiKey?: string\r\n  environment: 'development' | 'production' | 'staging'\r\n}\r\n\r\nclass ErrorTrackingService {\r\n  private config: ErrorTrackingConfig\r\n  private errors: ErrorReport[] = []\r\n  private sessionId: string\r\n  private initialized = false\r\n\r\n  constructor(config: Partial<ErrorTrackingConfig> = {}) {\r\n    this.config = {\r\n      maxStoredErrors: 100,\r\n      enableConsoleLogging: true,\r\n      enableLocalStorage: true,\r\n      environment: import.meta.env.MODE === 'production' ? 'production' : 'development',\r\n      ...config\r\n    }\r\n    \r\n    this.sessionId = this.generateSessionId()\r\n    this.loadStoredErrors()\r\n    this.setupGlobalErrorHandlers()\r\n    this.initialized = true\r\n    \r\n    this.logInfo('Error tracking initialized', { sessionId: this.sessionId })\r\n  }\r\n\r\n  /**\r\n   * Log an error\r\n   */\r\n  logError(error: Error | string, context?: Record<string, unknown>): void {\r\n    const errorReport = this.createErrorReport('error', error, context)\r\n    this.recordError(errorReport)\r\n  }\r\n\r\n  /**\r\n   * Log a warning\r\n   */\r\n  logWarning(message: string, context?: Record<string, unknown>): void {\r\n    const errorReport = this.createErrorReport('warning', message, context)\r\n    this.recordError(errorReport)\r\n  }\r\n\r\n  /**\r\n   * Log an info message\r\n   */\r\n  logInfo(message: string, context?: Record<string, unknown>): void {\r\n    const errorReport = this.createErrorReport('info', message, context)\r\n    this.recordError(errorReport)\r\n  }\r\n\r\n  /**\r\n   * Get all stored errors\r\n   */\r\n  getErrors(): ErrorReport[] {\r\n    return [...this.errors]\r\n  }\r\n\r\n  /**\r\n   * Clear all stored errors\r\n   */\r\n  clearErrors(): void {\r\n    this.errors = []\r\n    if (this.config.enableLocalStorage) {\r\n      localStorage.removeItem('studymaster_errors')\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get error statistics\r\n   */\r\n  getErrorStats(): {\r\n    total: number\r\n    byLevel: Record<string, number>\r\n    recent: number // Errors in last hour\r\n  } {\r\n    const now = Date.now()\r\n    const oneHourAgo = now - (60 * 60 * 1000)\r\n    \r\n    const stats = {\r\n      total: this.errors.length,\r\n      byLevel: { error: 0, warning: 0, info: 0 },\r\n      recent: 0\r\n    }\r\n\r\n    this.errors.forEach(error => {\r\n      stats.byLevel[error.level]++\r\n      if (new Date(error.timestamp).getTime() > oneHourAgo) {\r\n        stats.recent++\r\n      }\r\n    })\r\n\r\n    return stats\r\n  }\r\n\r\n  /**\r\n   * Export errors for debugging\r\n   */\r\n  exportErrors(): string {\r\n    return JSON.stringify(this.errors, null, 2)\r\n  }\r\n\r\n  private createErrorReport(\r\n    level: ErrorReport['level'],\r\n    error: Error | string,\r\n    context?: Record<string, unknown>\r\n  ): ErrorReport {\r\n    const message = error instanceof Error ? error.message : error\r\n    const stack = error instanceof Error ? error.stack : undefined\r\n    \r\n    return {\r\n      id: this.generateErrorId(),\r\n      timestamp: new Date().toISOString(),\r\n      level,\r\n      message,\r\n      stack,\r\n      userAgent: navigator.userAgent,\r\n      url: window.location.href,\r\n      sessionId: this.sessionId,\r\n      context: context || {}\r\n    }\r\n  }\r\n\r\n  private recordError(error: ErrorReport): void {\r\n    // Add to in-memory storage\r\n    this.errors.unshift(error)\r\n    \r\n    // Limit stored errors\r\n    if (this.errors.length > this.config.maxStoredErrors) {\r\n      this.errors = this.errors.slice(0, this.config.maxStoredErrors)\r\n    }\r\n\r\n    // Console logging\r\n    if (this.config.enableConsoleLogging) {\r\n      const logMethod = error.level === 'error' ? console.error : \r\n                       error.level === 'warning' ? console.warn : console.log\r\n      logMethod(`[ErrorTracker] ${error.message}`, error)\r\n    }\r\n\r\n    // Local storage persistence\r\n    if (this.config.enableLocalStorage) {\r\n      try {\r\n        localStorage.setItem('studymaster_errors', JSON.stringify(this.errors.slice(0, 50)))\r\n      } catch (e) {\r\n        // Storage quota exceeded, clear old errors\r\n        this.errors = this.errors.slice(0, 25)\r\n        try {\r\n          localStorage.setItem('studymaster_errors', JSON.stringify(this.errors))\r\n        } catch (e) {\r\n          // If still failing, disable local storage\r\n          console.warn('Error tracking: Local storage disabled due to quota issues')\r\n        }\r\n      }\r\n    }\r\n\r\n    // Send to remote endpoint if configured\r\n    if (this.config.apiEndpoint && this.config.environment === 'production') {\r\n      this.sendToRemote(error).catch(e => {\r\n        console.warn('Failed to send error to remote endpoint:', e)\r\n      })\r\n    }\r\n  }\r\n\r\n  private loadStoredErrors(): void {\r\n    if (!this.config.enableLocalStorage) return\r\n\r\n    try {\r\n      const stored = localStorage.getItem('studymaster_errors')\r\n      if (stored) {\r\n        const parsedErrors = JSON.parse(stored)\r\n        if (Array.isArray(parsedErrors)) {\r\n          this.errors = parsedErrors\r\n        }\r\n      }\r\n    } catch (e) {\r\n      console.warn('Failed to load stored errors:', e)\r\n    }\r\n  }\r\n\r\n  private setupGlobalErrorHandlers(): void {\r\n    // Unhandled JavaScript errors\r\n    window.addEventListener('error', (event) => {\r\n      this.logError(event.error || new Error(event.message), {\r\n        filename: event.filename,\r\n        lineno: event.lineno,\r\n        colno: event.colno,\r\n        type: 'unhandled_error'\r\n      })\r\n    })\r\n\r\n    // Unhandled promise rejections\r\n    window.addEventListener('unhandledrejection', (event) => {\r\n      this.logError(new Error(`Unhandled promise rejection: ${event.reason}`), {\r\n        type: 'unhandled_promise_rejection',\r\n        reason: event.reason\r\n      })\r\n    })\r\n\r\n    // React error boundary integration\r\n    if (window.React) {\r\n      const originalErrorHandler = window.console.error\r\n      window.console.error = (...args) => {\r\n        const message = args[0]\r\n        if (typeof message === 'string' && message.includes('React')) {\r\n          this.logError(new Error(message), {\r\n            type: 'react_error',\r\n            args: args\r\n          })\r\n        }\r\n        originalErrorHandler.apply(console, args)\r\n      }\r\n    }\r\n  }\r\n\r\n  private async sendToRemote(error: ErrorReport): Promise<void> {\r\n    if (!this.config.apiEndpoint) return\r\n\r\n    try {\r\n      await fetch(this.config.apiEndpoint, {\r\n        method: 'POST',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n          ...(this.config.apiKey ? { 'Authorization': `Bearer ${this.config.apiKey}` } : {})\r\n        },\r\n        body: JSON.stringify({\r\n          ...error,\r\n          environment: this.config.environment,\r\n          userAgent: navigator.userAgent,\r\n          timestamp: new Date().toISOString()\r\n        })\r\n      })\r\n    } catch (e) {\r\n      // Silently fail for remote logging\r\n      console.warn('Failed to send error to remote endpoint:', e)\r\n    }\r\n  }\r\n\r\n  private generateSessionId(): string {\r\n    return `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`\r\n  }\r\n\r\n  private generateErrorId(): string {\r\n    return `error_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`\r\n  }\r\n}\r\n\r\n// Singleton instance\r\nexport const errorTracker = new ErrorTrackingService({\r\n  environment: import.meta.env.MODE === 'production' ? 'production' : 'development',\r\n  maxStoredErrors: 100,\r\n  enableConsoleLogging: import.meta.env.DEV,\r\n  enableLocalStorage: true\r\n})\r\n\r\n// Convenience functions\r\nexport const logError = (error: Error | string, context?: Record<string, unknown>) => \r\n  errorTracker.logError(error, context)\r\n\r\nexport const logWarning = (message: string, context?: Record<string, unknown>) => \r\n  errorTracker.logWarning(message, context)\r\n\r\nexport const logInfo = (message: string, context?: Record<string, unknown>) => \r\n  errorTracker.logInfo(message, context)\r\n\r\n// React Error Boundary component\r\nexport class ErrorBoundary extends React.Component<\r\n  { children: React.ReactNode; fallback?: React.ComponentType<{ error: Error }> },\r\n  { hasError: boolean; error?: Error }\r\n> {\r\n  constructor(props: any) {\r\n    super(props)\r\n    this.state = { hasError: false }\r\n  }\r\n\r\n  static getDerivedStateFromError(error: Error) {\r\n    return { hasError: true, error }\r\n  }\r\n\r\n  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {\r\n    logError(error, {\r\n      type: 'react_error_boundary',\r\n      componentStack: errorInfo.componentStack,\r\n      errorBoundary: true\r\n    })\r\n  }\r\n\r\n  render() {\r\n    if (this.state.hasError) {\r\n      const FallbackComponent = this.props.fallback || DefaultErrorFallback\r\n      return <FallbackComponent error={this.state.error!} />\r\n    }\r\n\r\n    return this.props.children\r\n  }\r\n}\r\n\r\n// Default error fallback component\r\nexport const DefaultErrorFallback: React.FC<{ error: Error }> = ({ error }) => (\r\n  <div className=\"min-h-screen flex items-center justify-center bg-gray-50 dark:bg-gray-900\">\r\n    <div className=\"max-w-md mx-auto text-center p-6\">\r\n      <div className=\"mb-4\">\r\n        <svg className=\"mx-auto h-12 w-12 text-red-500\" fill=\"none\" viewBox=\"0 0 24 24\" stroke=\"currentColor\">\r\n          <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.732-.833-2.502 0L4.732 15.5c-.77.833.192 2.5 1.732 2.5z\" />\r\n        </svg>\r\n      </div>\r\n      <h1 className=\"text-xl font-semibold text-gray-900 dark:text-white mb-2\">\r\n        Something went wrong\r\n      </h1>\r\n      <p className=\"text-gray-600 dark:text-gray-400 mb-4\">\r\n        {error.message || 'An unexpected error occurred'}\r\n      </p>\r\n      <button\r\n        onClick={() => window.location.reload()}\r\n        className=\"inline-flex items-center px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors\"\r\n      >\r\n        Reload Page\r\n      </button>\r\n    </div>\r\n  </div>\r\n)\r\n\r\nexport default ErrorTrackingService","/**\r\n * Local Profile Service\r\n * - Creates/loads/updates a device-local user profile (no server required)\r\n * - Derives an anonymizedId for public contexts\r\n * - Stores profile in IndexedDB (Dexie users table)\r\n *\r\n * Schema source: client/src/data/db.ts (UserRow)\r\n */\r\n\r\nimport db, { ensureDBOpen, type UserRow } from '../data/db';\r\n\r\nexport type LocalProfile = {\r\n  deviceUserId: string;\r\n  displayName?: string;\r\n  avatarUrl?: string;\r\n  anonymizedId: string;\r\n  createdAt: number;\r\n  updatedAt: number;\r\n};\r\n\r\nfunction hasSubtleCrypto(): boolean {\r\n  try {\r\n    return typeof crypto !== 'undefined' && !!(crypto as any).subtle?.digest;\r\n  } catch {\r\n    return false;\r\n  }\r\n}\r\n\r\nfunction toBase64Url(bytes: Uint8Array): string {\r\n  let str = '';\r\n  for (let i = 0; i < bytes.length; i++) {\r\n    str += String.fromCharCode(bytes[i]);\r\n  }\r\n  // btoa is available in browsers; in tests it might be polyfilled\r\n  const b64 = typeof btoa !== 'undefined' ? btoa(str) : Buffer.from(bytes).toString('base64');\r\n  return b64.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=+$/, '');\r\n}\r\n\r\n/**\r\n * Derive a stable anonymizedId from deviceUserId and createdAt\r\n * - Uses SHA-256 when available; falls back to a simple base64url of the input\r\n */\r\nexport async function deriveAnonymizedId(deviceUserId: string, createdAt: number): Promise<string> {\r\n  const input = new TextEncoder().encode(`${deviceUserId}:${createdAt}`);\r\n  if (hasSubtleCrypto()) {\r\n    try {\r\n      const digest = await (crypto as any).subtle.digest('SHA-256', input);\r\n      return toBase64Url(new Uint8Array(digest));\r\n    } catch {\r\n      // fallthrough to fallback\r\n    }\r\n  }\r\n  // Fallback: base64url of the input (non-cryptographic)\r\n  return toBase64Url(input);\r\n}\r\n\r\nfunction uuidv4(): string {\r\n  if (typeof crypto !== 'undefined' && (crypto as any).randomUUID) {\r\n    return (crypto as any).randomUUID();\r\n  }\r\n  // RFC4122-ish fallback\r\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\r\n    const r = (Math.random() * 16) | 0;\r\n    const v = c === 'x' ? r : (r & 0x3) | 0x8;\r\n    return v.toString(16);\r\n  });\r\n}\r\n\r\n/**\r\n * Create a new local profile\r\n */\r\nasync function createLocalProfileInternal(displayName?: string, avatarUrl?: string): Promise<LocalProfile> {\r\n  await ensureDBOpen();\r\n  const deviceUserId = uuidv4();\r\n  const now = Date.now();\r\n  const anonymizedId = await deriveAnonymizedId(deviceUserId, now);\r\n\r\n  const row: UserRow = {\r\n    deviceUserId,\r\n    displayName,\r\n    avatarUrl,\r\n    anonymizedId,\r\n    createdAt: now,\r\n    updatedAt: now,\r\n  };\r\n  await db.users.add(row);\r\n  return {\r\n    deviceUserId: row.deviceUserId,\r\n    displayName: row.displayName,\r\n    avatarUrl: row.avatarUrl,\r\n    anonymizedId: row.anonymizedId || anonymizedId,\r\n    createdAt: row.createdAt,\r\n    updatedAt: row.updatedAt,\r\n  };\r\n}\r\n\r\n/**\r\n * Get the first local profile if present (single profile model), else null\r\n */\r\nexport async function getLocalProfile(): Promise<LocalProfile | null> {\r\n  await ensureDBOpen();\r\n  const any = await db.users.toCollection().first();\r\n  if (!any) return null;\r\n  return {\r\n    deviceUserId: any.deviceUserId,\r\n    displayName: any.displayName,\r\n    avatarUrl: any.avatarUrl,\r\n    anonymizedId: any.anonymizedId || (await deriveAnonymizedId(any.deviceUserId, any.createdAt)),\r\n    createdAt: any.createdAt,\r\n    updatedAt: any.updatedAt,\r\n  };\r\n}\r\n\r\n/**\r\n * Ensure a local profile exists and return it\r\n */\r\nexport async function ensureLocalProfile(displayName?: string, avatarUrl?: string): Promise<LocalProfile> {\r\n  const existing = await getLocalProfile();\r\n  if (existing) return existing;\r\n  return createLocalProfileInternal(displayName, avatarUrl);\r\n}\r\n\r\n/**\r\n * Update local profile fields\r\n */\r\nexport async function updateLocalProfile(patch: Partial<Pick<LocalProfile, 'displayName' | 'avatarUrl'>>): Promise<LocalProfile> {\r\n  await ensureDBOpen();\r\n  const existing = await db.users.toCollection().first();\r\n  if (!existing) {\r\n    // If no profile exists, create one with requested fields\r\n    return createLocalProfileInternal(patch.displayName, patch.avatarUrl);\r\n  }\r\n  const updated: UserRow = {\r\n    ...existing,\r\n    displayName: patch.displayName ?? existing.displayName,\r\n    avatarUrl: patch.avatarUrl ?? existing.avatarUrl,\r\n    updatedAt: Date.now(),\r\n  };\r\n  await db.users.put(updated);\r\n  return {\r\n    deviceUserId: updated.deviceUserId,\r\n    displayName: updated.displayName,\r\n    avatarUrl: updated.avatarUrl,\r\n    anonymizedId: updated.anonymizedId || (await deriveAnonymizedId(updated.deviceUserId, updated.createdAt)),\r\n    createdAt: updated.createdAt,\r\n    updatedAt: updated.updatedAt,\r\n  };\r\n}\r\n\r\n/**\r\n * Utility to read just the anonymizedId (derives it if missing)\r\n */\r\nexport async function getAnonymizedId(): Promise<string> {\r\n  const profile = await ensureLocalProfile();\r\n  return profile.anonymizedId || (await deriveAnonymizedId(profile.deviceUserId, profile.createdAt));\r\n}","/**\r\n * onlineLinkService\r\n * - Manages optional server link for a local profile (deviceUserId)\r\n * - Stores tokens and serverUserId in IndexedDB (userOnlineLinks)\r\n * - No network dependency for unlink operations\r\n *\r\n * Repos: repos.userOnlineLinks\r\n */\r\n\r\nimport { repos } from '../data';\r\n\r\nexport type Provider = 'studymaster' | 'custom';\r\n\r\nexport interface LinkInput {\r\n  deviceUserId: string;\r\n  provider: Provider;\r\n  serverUserId: string;\r\n  accessToken: string;\r\n  refreshToken?: string;\r\n  scopes?: string[];\r\n  meta?: Record<string, unknown>;\r\n  lastLinkedAt?: number;\r\n}\r\n\r\nexport interface OnlineLinkInfo {\r\n  linkKey: string;\r\n  deviceUserId: string;\r\n  provider: Provider;\r\n  serverUserId: string;\r\n  accessToken: string;\r\n  refreshToken?: string;\r\n  scopes?: string[];\r\n  lastLinkedAt: number;\r\n  meta?: Record<string, unknown>;\r\n}\r\n\r\nfunction toLinkKey(deviceUserId: string, provider: Provider): string {\r\n  return `${deviceUserId}:${provider}`;\r\n}\r\n\r\n/**\r\n * Create or update a link for a local profile\r\n */\r\nexport async function linkAccount(input: LinkInput): Promise<OnlineLinkInfo> {\r\n  const row = await repos.userOnlineLinks.upsert({\r\n    deviceUserId: input.deviceUserId,\r\n    provider: input.provider,\r\n    serverUserId: input.serverUserId,\r\n    accessToken: input.accessToken,\r\n    refreshToken: input.refreshToken,\r\n    scopes: input.scopes,\r\n    meta: input.meta,\r\n    lastLinkedAt: input.lastLinkedAt,\r\n  });\r\n  return row;\r\n}\r\n\r\n/**\r\n * Remove link for a local profile (by deviceUserId + provider)\r\n */\r\nexport async function unlinkAccount(deviceUserId: string, provider: Provider): Promise<void> {\r\n  const linkKey = toLinkKey(deviceUserId, provider);\r\n  await repos.userOnlineLinks.remove(linkKey);\r\n}\r\n\r\n/**\r\n * Get link info for a local profile (by deviceUserId + provider)\r\n */\r\nexport async function getLink(deviceUserId: string, provider: Provider): Promise<OnlineLinkInfo | null> {\r\n  const linkKey = toLinkKey(deviceUserId, provider);\r\n  return repos.userOnlineLinks.get(linkKey);\r\n}\r\n\r\n/**\r\n * List all links for a local profile (multi-provider support)\r\n */\r\nexport async function listLinks(deviceUserId: string): Promise<OnlineLinkInfo[]> {\r\n  return repos.userOnlineLinks.listByDevice(deviceUserId);\r\n}\r\n\r\n/**\r\n * Returns true if the profile is linked with the given provider\r\n */\r\nexport async function isLinked(deviceUserId: string, provider: Provider): Promise<boolean> {\r\n  const row = await getLink(deviceUserId, provider);\r\n  return !!row?.accessToken && !!row?.serverUserId;\r\n}\r\n\r\n/**\r\n * Access token helper\r\n */\r\nexport async function getAccessToken(deviceUserId: string, provider: Provider): Promise<string | null> {\r\n  const row = await getLink(deviceUserId, provider);\r\n  return row?.accessToken ?? null;\r\n}\r\n\r\n/**\r\n * Refresh token helper (for future extension)\r\n */\r\nexport async function getRefreshToken(deviceUserId: string, provider: Provider): Promise<string | null> {\r\n  const row = await getLink(deviceUserId, provider);\r\n  return row?.refreshToken ?? null;\r\n}","/**\r\n * Media hashing utilities for deduplication (Phase 1)\r\n * Uses WebCrypto SubtleCrypto to compute SHA-256 digests.\r\n */\r\n\r\nfunction bytesToHex(bytes: ArrayBuffer): string {\r\n  const view = new Uint8Array(bytes);\r\n  let hex = '';\r\n  for (let i = 0; i < view.length; i++) {\r\n    const h = view[i].toString(16).padStart(2, '0');\r\n    hex += h;\r\n  }\r\n  return hex;\r\n}\r\n\r\n/**\r\n * Compute SHA-256 hash of an ArrayBuffer and return lowercase hex string.\r\n */\r\nexport async function hashArrayBufferSHA256(buffer: ArrayBuffer): Promise<string> {\r\n  const anyCrypto = (globalThis as any).crypto;\r\n  if (!anyCrypto?.subtle?.digest) {\r\n    throw new Error('WebCrypto SubtleCrypto not available for hashing');\r\n  }\r\n  const digest = await anyCrypto.subtle.digest('SHA-256', buffer);\r\n  return bytesToHex(digest);\r\n}\r\n\r\n/**\r\n * Compute SHA-256 hash of a Blob (e.g., media file) and return lowercase hex string.\r\n * Uses blob.arrayBuffer() when available; falls back to Response for broader support (jsdom).\r\n */\r\nexport async function hashBlobSHA256(blob: Blob): Promise<string> {\r\n  // Prefer native blob.arrayBuffer if available\r\n  const anyBlob = blob as any;\r\n  if (anyBlob && typeof anyBlob.arrayBuffer === 'function') {\r\n    const buffer = await anyBlob.arrayBuffer();\r\n    return hashArrayBufferSHA256(buffer);\r\n  }\r\n  // Fallback: use Response to read as ArrayBuffer (works in jsdom/node environments)\r\n  const buffer = await new Response(blob).arrayBuffer();\r\n  return hashArrayBufferSHA256(buffer);\r\n}","/**\r\n * MediaStorageService\r\n * - Client-side media persistence with SHA-256 deduplication\r\n * - Uses IndexedDB via repositories for storage\r\n * - OPFS pointer support can be added later (Phase 1 enhancement)\r\n */\r\n\r\nimport { repos } from '../data';\r\nimport type { MediaRow } from '../data/db';\r\nimport { hashBlobSHA256 } from '../utils/hash';\r\nimport { logError, logInfo } from '../services/errorTrackingService';\r\n\r\nexport class MediaStorageService {\r\n  /**\r\n   * Store a Blob in media store with SHA-256 deduplication.\r\n   * Returns the mediaHash (content hash).\r\n   */\r\n  async storeBlob(\r\n    blob: Blob,\r\n    mimeType: string,\r\n    options?: {\r\n      // Optional OPFS pointer save path (client-only, best-effort)\r\n      useOPFS?: boolean;\r\n      validationMeta?: Record<string, unknown>;\r\n      securityFlags?: MediaRow['securityFlags'];\r\n    }\r\n  ): Promise<string> {\r\n    try {\r\n      // 1) Compute content hash for deduplication\r\n      const mediaHash = await hashBlobSHA256(blob);\r\n\r\n      // 2) Short-circuit if already present\r\n      if (await repos.media.has(mediaHash)) {\r\n        logInfo('Media dedup hit', { mediaHash, size: blob.size, mimeType, scope: 'media.storeBlob' });\r\n        return mediaHash;\r\n      }\r\n\r\n      let opfsPointer: string | undefined;\r\n\r\n      // 3) Attempt OPFS write when requested and supported\r\n      if (options?.useOPFS && typeof navigator !== 'undefined' && (navigator as any).storage?.getDirectory) {\r\n        try {\r\n          const root: any = await (navigator as any).storage.getDirectory();\r\n          const mediaDir = await root.getDirectoryHandle('media', { create: true });\r\n          const fileHandle = await mediaDir.getFileHandle(mediaHash, { create: true });\r\n          const writable = await fileHandle.createWritable();\r\n          await writable.write(blob);\r\n          await writable.close();\r\n          opfsPointer = `media/${mediaHash}`;\r\n          logInfo('Media saved to OPFS', { mediaHash, path: opfsPointer, scope: 'media.storeBlob' });\r\n        } catch (e) {\r\n          // Fall back to IndexedDB blob if OPFS fails\r\n          logError(e instanceof Error ? e : new Error(String(e)), { scope: 'media.storeBlob.opfs' });\r\n          opfsPointer = undefined;\r\n        }\r\n      }\r\n\r\n      // 4) Persist record: prefer OPFS pointer when available; otherwise store blob in IndexedDB\r\n      await repos.media.put({\r\n        mediaHash,\r\n        blob: opfsPointer ? undefined : blob,\r\n        opfsPointer,\r\n        mimeType,\r\n        byteLength: opfsPointer ? blob.size : blob.size,\r\n        validationMeta: options?.validationMeta,\r\n        securityFlags: options?.securityFlags,\r\n      });\r\n\r\n      return mediaHash;\r\n    } catch (err) {\r\n      logError(err instanceof Error ? err : new Error(String(err)), { scope: 'media.storeBlob' });\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Ensure a MediaRow exists for a given hash (null if missing)\r\n   */\r\n  async get(mediaHash: string): Promise<MediaRow | null> {\r\n    try {\r\n      return await repos.media.get(mediaHash);\r\n    } catch (err) {\r\n      logError(err instanceof Error ? err : new Error(String(err)), { scope: 'media.get' });\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create an object URL for a stored blob (caller must revoke when done).\r\n   * Returns null if not available (e.g., OPFS pointer without blob present).\r\n   */\r\n  async createObjectUrl(mediaHash: string): Promise<string | null> {\r\n    try {\r\n      const row = await repos.media.get(mediaHash);\r\n      if (!row) return null;\r\n\r\n      // Prefer in-DB blob when present\r\n      if (row.blob) {\r\n        return URL.createObjectURL(row.blob);\r\n      }\r\n\r\n      // Fallback to OPFS pointer when available\r\n      if (row.opfsPointer && typeof navigator !== 'undefined' && (navigator as any).storage?.getDirectory) {\r\n        try {\r\n          const root: any = await (navigator as any).storage.getDirectory();\r\n          // Resolve pointer like \"media/<hash>\"\r\n          const [dirName, fileName] = String(row.opfsPointer).split('/');\r\n          const mediaDir = await root.getDirectoryHandle(dirName, { create: false });\r\n          const fileHandle = await mediaDir.getFileHandle(fileName, { create: false });\r\n          const file = await fileHandle.getFile();\r\n          return URL.createObjectURL(file);\r\n        } catch (e) {\r\n          logError(e instanceof Error ? e : new Error(String(e)), { scope: 'media.createObjectUrl.opfs' });\r\n          return null;\r\n        }\r\n      }\r\n\r\n      return null;\r\n    } catch (err) {\r\n      logError(err instanceof Error ? err : new Error(String(err)), { scope: 'media.createObjectUrl' });\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Revoke a previously created object URL\r\n   */\r\n  revokeObjectUrl(url: string): void {\r\n    try {\r\n      URL.revokeObjectURL(url);\r\n    } catch (err) {\r\n      logError(err instanceof Error ? err : new Error(String(err)), { scope: 'media.revokeObjectUrl' });\r\n    }\r\n  }\r\n}\r\n\r\n// Singleton\r\nexport const mediaStorage = new MediaStorageService();\r\nexport default MediaStorageService;","import type {\r\n  User\r\n} from '@shared/types';\r\nimport { debugLogger } from '../utils/debugLogger';\r\n\r\n// Extended User interface for authentication context\r\nexport interface AuthenticatedUser extends User {\r\n  token?: string;\r\n  tokenType?: 'demo' | 'mock' | 'real';\r\n}\r\n\r\n// Types for user data and statistics\r\nexport interface UserStats {\r\n  totalXP: number;\r\n  level: number;\r\n  currentLevelXP: number;\r\n  nextLevelXP: number;\r\n  cardsStudied: number;\r\n  studyTime: number; // in minutes\r\n  accuracy: number; // percentage\r\n  currentStreak: number;\r\n  longestStreak: number;\r\n  coins: number;\r\n  gems: number;\r\n  lastStudyDate: string;\r\n  joinDate: string;\r\n}\r\n\r\nexport interface UserActivity {\r\n  date: string;\r\n  cardsStudied: number;\r\n  studyTime: number;\r\n  accuracy: number;\r\n  xpGained: number;\r\n}\r\n\r\nexport interface UserAchievement {\r\n  id: string;\r\n  name: string;\r\n  description: string;\r\n  icon: string;\r\n  unlockedAt: string;\r\n  category: 'study' | 'streak' | 'accuracy' | 'time' | 'social';\r\n}\r\n\r\nexport interface UserChallenge {\r\n  id: string;\r\n  name: string;\r\n  description: string;\r\n  type: 'daily' | 'weekly' | 'monthly';\r\n  target: number;\r\n  current: number;\r\n  reward: {\r\n    xp: number;\r\n    coins: number;\r\n    gems?: number;\r\n  };\r\n  expiresAt: string;\r\n  completedAt?: string;\r\n}\r\n\r\nexport interface UserPerformanceMetrics {\r\n  weeklyProgress: {\r\n    cardsStudied: number;\r\n    studyTime: number;\r\n    accuracy: number;\r\n    goal: number;\r\n  };\r\n  monthlyProgress: {\r\n    cardsStudied: number;\r\n    studyTime: number;\r\n    decksCompleted: number;\r\n  };\r\n  studyPattern: {\r\n    preferredTime: string;\r\n    averageSessionLength: number;\r\n    studyFrequency: number;\r\n  };\r\n}\r\n\r\nexport interface LeaderboardEntry {\r\n  userId: string;\r\n  username: string;\r\n  avatar?: string;\r\n  score: number;\r\n  rank: number;\r\n  change: number; // position change from last period\r\n}\r\n\r\nexport interface LeaderboardData {\r\n  global: LeaderboardEntry[];\r\n  friends: LeaderboardEntry[];\r\n  weekly: LeaderboardEntry[];\r\n  monthly: LeaderboardEntry[];\r\n}\r\n\r\n// Demo data for demo users\r\nconst DEMO_USER_STATS: UserStats = {\r\n  totalXP: 2500,\r\n  level: 5,\r\n  currentLevelXP: 100,\r\n  nextLevelXP: 500,\r\n  cardsStudied: 1250,\r\n  studyTime: 2400, // 40 hours\r\n  accuracy: 87.5,\r\n  currentStreak: 15,\r\n  longestStreak: 28,\r\n  coins: 150,\r\n  gems: 10,\r\n  lastStudyDate: new Date().toISOString(),\r\n  joinDate: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString()\r\n};\r\n\r\nconst DEMO_ACHIEVEMENTS: UserAchievement[] = [\r\n  {\r\n    id: 'first_study',\r\n    name: 'First Steps',\r\n    description: 'Complete your first study session',\r\n    icon: 'ðŸŽ¯',\r\n    unlockedAt: new Date(Date.now() - 25 * 24 * 60 * 60 * 1000).toISOString(),\r\n    category: 'study'\r\n  },\r\n  {\r\n    id: 'week_streak',\r\n    name: 'Week Warrior',\r\n    description: 'Study for 7 days in a row',\r\n    icon: 'ðŸ”¥',\r\n    unlockedAt: new Date(Date.now() - 10 * 24 * 60 * 60 * 1000).toISOString(),\r\n    category: 'streak'\r\n  }\r\n];\r\n\r\n// Enhanced Monthly Challenges\r\nconst ENHANCED_MONTHLY_CHALLENGES: UserChallenge[] = [\r\n  {\r\n    id: 'monthly_mastery',\r\n    name: 'Monthly Mastery Challenge',\r\n    description: 'Complete an intensive month-long study challenge with progressive difficulty',\r\n    type: 'monthly',\r\n    target: 1000,\r\n    current: 245,\r\n    reward: { xp: 1500, coins: 500, gems: 50 },\r\n    expiresAt: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString()\r\n  },\r\n  {\r\n    id: 'knowledge_seeker',\r\n    name: 'Knowledge Seeker',\r\n    description: 'Explore diverse subjects and maintain high accuracy throughout the month',\r\n    type: 'monthly',\r\n    target: 800,\r\n    current: 156,\r\n    reward: { xp: 1200, coins: 400, gems: 30 },\r\n    expiresAt: new Date(Date.now() + 25 * 24 * 60 * 60 * 1000).toISOString()\r\n  }\r\n];\r\n\r\nconst DEMO_CHALLENGES: UserChallenge[] = [\r\n  {\r\n    id: 'daily_grind',\r\n    name: 'Daily Grind',\r\n    description: 'Study 25 cards today',\r\n    type: 'daily',\r\n    target: 25,\r\n    current: 18,\r\n    reward: { xp: 50, coins: 10 },\r\n    expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString()\r\n  },\r\n  {\r\n    id: 'weekly_warrior',\r\n    name: 'Weekly Warrior',\r\n    description: 'Study 200 cards this week',\r\n    type: 'weekly',\r\n    target: 200,\r\n    current: 145,\r\n    reward: { xp: 200, coins: 50, gems: 5 },\r\n    expiresAt: new Date(Date.now() + 3 * 24 * 60 * 60 * 1000).toISOString()\r\n  },\r\n  ...ENHANCED_MONTHLY_CHALLENGES\r\n];\r\n\r\nconst DEMO_LEADERBOARD: LeaderboardData = {\r\n  global: [\r\n    { userId: 'demo1', username: 'StudyMaster', score: 5420, rank: 1, change: 0 },\r\n    { userId: 'demo2', username: 'FlashcardPro', score: 4890, rank: 2, change: 1 },\r\n    { userId: 'demo3', username: 'MemoryWiz', score: 4650, rank: 3, change: -1 },\r\n    { userId: 'demo4', username: 'QuizKing', score: 4200, rank: 4, change: 2 },\r\n    { userId: 'demo_user', username: 'Demo User', score: 2500, rank: 15, change: 3 }\r\n  ],\r\n  friends: [\r\n    { userId: 'friend1', username: 'StudyBuddy', score: 3200, rank: 1, change: 0 },\r\n    { userId: 'demo_user', username: 'Demo User', score: 2500, rank: 2, change: 1 },\r\n    { userId: 'friend2', username: 'LearningPal', score: 2100, rank: 3, change: -1 }\r\n  ],\r\n  weekly: [\r\n    { userId: 'demo1', username: 'StudyMaster', score: 890, rank: 1, change: 2 },\r\n    { userId: 'demo_user', username: 'Demo User', score: 420, rank: 8, change: 5 }\r\n  ],\r\n  monthly: [\r\n    { userId: 'demo1', username: 'StudyMaster', score: 3200, rank: 1, change: 0 },\r\n    { userId: 'demo_user', username: 'Demo User', score: 1800, rank: 12, change: -2 }\r\n  ]\r\n};\r\n\r\n// API service class\r\nexport class UserDataService {\r\n  private baseUrl = '/api';\r\n\r\n  // Check if user is demo user\r\n  private isDemoUser(user: AuthenticatedUser): boolean {\r\n    return user.tokenType === 'demo' || user.email === 'demo@studymaster.app';\r\n  }\r\n\r\n  // Get user statistics\r\n  async getUserStats(user: AuthenticatedUser): Promise<UserStats> {\r\n    debugLogger.log('[USER_DATA_SERVICE]', 'START - getUserStats', {\r\n      userId: user.id,\r\n      isDemoUser: this.isDemoUser(user)\r\n    });\r\n\r\n    if (this.isDemoUser(user)) {\r\n      debugLogger.log('[USER_DATA_SERVICE]', 'Returning demo user stats');\r\n      return DEMO_USER_STATS;\r\n    }\r\n\r\n    // Primary: Try REST API\r\n    try {\r\n      const response = await fetch(`${this.baseUrl}/users/${user.id}/stats`, {\r\n        headers: {\r\n          'Authorization': `Bearer ${user.token}`,\r\n          'Content-Type': 'application/json'\r\n        }\r\n      });\r\n\r\n      if (!response.ok) {\r\n        throw new Error('Failed to fetch user stats from REST API');\r\n      }\r\n\r\n      const data = await response.json();\r\n      debugLogger.log('[USER_DATA_SERVICE]', 'REST API user stats fetched successfully');\r\n      return data;\r\n    } catch (apiError) {\r\n      debugLogger.warn('[USER_DATA_SERVICE]', 'REST API failed, using mock data', {\r\n        apiError\r\n      });\r\n      \r\n      // Final fallback: Return personalized mock data\r\n      return this.generatePersonalizedMockStats(user);\r\n    }\r\n  }\r\n\r\n  // Get user activity history\r\n  async getUserActivity(user: AuthenticatedUser, days: number = 30): Promise<UserActivity[]> {\r\n    if (this.isDemoUser(user)) {\r\n      return this.generateDemoActivity(days);\r\n    }\r\n\r\n    try {\r\n      const response = await fetch(`${this.baseUrl}/users/${user.id}/activity?days=${days}`, {\r\n        headers: {\r\n          'Authorization': `Bearer ${user.token}`,\r\n          'Content-Type': 'application/json'\r\n        }\r\n      });\r\n\r\n      if (!response.ok) {\r\n        throw new Error('Failed to fetch user activity');\r\n      }\r\n\r\n      return await response.json();\r\n    } catch (error) {\r\n      console.warn('Failed to fetch real user activity, using mock data:', error);\r\n      return this.generatePersonalizedActivity(user, days);\r\n    }\r\n  }\r\n\r\n  // Get user achievements\r\n  async getUserAchievements(user: AuthenticatedUser): Promise<UserAchievement[]> {\r\n    if (this.isDemoUser(user)) {\r\n      return DEMO_ACHIEVEMENTS;\r\n    }\r\n\r\n    try {\r\n      const response = await fetch(`${this.baseUrl}/users/${user.id}/achievements`, {\r\n        headers: {\r\n          'Authorization': `Bearer ${user.token}`,\r\n          'Content-Type': 'application/json'\r\n        }\r\n      });\r\n\r\n      if (!response.ok) {\r\n        throw new Error('Failed to fetch user achievements');\r\n      }\r\n\r\n      return await response.json();\r\n    } catch (error) {\r\n      console.warn('Failed to fetch real user achievements, using mock data:', error);\r\n      return this.generatePersonalizedAchievements(user);\r\n    }\r\n  }\r\n\r\n  // Get user challenges\r\n  async getUserChallenges(user: AuthenticatedUser): Promise<UserChallenge[]> {\r\n    if (this.isDemoUser(user)) {\r\n      return DEMO_CHALLENGES;\r\n    }\r\n\r\n    try {\r\n      const response = await fetch(`${this.baseUrl}/users/${user.id}/challenges`, {\r\n        headers: {\r\n          'Authorization': `Bearer ${user.token}`,\r\n          'Content-Type': 'application/json'\r\n        }\r\n      });\r\n\r\n      if (!response.ok) {\r\n        throw new Error('Failed to fetch user challenges');\r\n      }\r\n\r\n      return await response.json();\r\n    } catch (error) {\r\n      console.warn('Failed to fetch real user challenges, using mock data:', error);\r\n      return this.generatePersonalizedChallenges(user);\r\n    }\r\n  }\r\n\r\n  // Get leaderboard data\r\n  async getLeaderboardData(user: AuthenticatedUser): Promise<LeaderboardData> {\r\n    if (this.isDemoUser(user)) {\r\n      return DEMO_LEADERBOARD;\r\n    }\r\n\r\n    try {\r\n      const response = await fetch(`${this.baseUrl}/gamification/leaderboard`, {\r\n        headers: {\r\n          'Authorization': `Bearer ${user.token}`,\r\n          'Content-Type': 'application/json'\r\n        }\r\n      });\r\n\r\n      if (!response.ok) {\r\n        throw new Error('Failed to fetch leaderboard data');\r\n      }\r\n\r\n      return await response.json();\r\n    } catch (error) {\r\n      console.warn('Failed to fetch real leaderboard data, using mock data:', error);\r\n      return this.generatePersonalizedLeaderboard(user);\r\n    }\r\n  }\r\n\r\n  // Get performance metrics\r\n  async getPerformanceMetrics(user: AuthenticatedUser): Promise<UserPerformanceMetrics> {\r\n    if (this.isDemoUser(user)) {\r\n      return this.generateDemoPerformanceMetrics();\r\n    }\r\n\r\n    try {\r\n      const response = await fetch(`${this.baseUrl}/users/${user.id}/performance`, {\r\n        headers: {\r\n          'Authorization': `Bearer ${user.token}`,\r\n          'Content-Type': 'application/json'\r\n        }\r\n      });\r\n\r\n      if (!response.ok) {\r\n        throw new Error('Failed to fetch performance metrics');\r\n      }\r\n\r\n      return await response.json();\r\n    } catch (error) {\r\n      console.warn('Failed to fetch real performance metrics, using mock data:', error);\r\n      return this.generatePersonalizedPerformanceMetrics(user);\r\n    }\r\n  }\r\n\r\n  // Get comprehensive user profile data\r\n  async getCompleteUserProfile(user: AuthenticatedUser): Promise<{\r\n    stats: UserStats;\r\n    activity: UserActivity[];\r\n    achievements: UserAchievement[];\r\n    challenges: UserChallenge[];\r\n    performance: UserPerformanceMetrics;\r\n  }> {\r\n    const [stats, activity, achievements, challenges, performance] = await Promise.all([\r\n      this.getUserStats(user),\r\n      this.getUserActivity(user, 30),\r\n      this.getUserAchievements(user),\r\n      this.getUserChallenges(user),\r\n      this.getPerformanceMetrics(user)\r\n    ]);\r\n\r\n    return {\r\n      stats,\r\n      activity,\r\n      achievements,\r\n      challenges,\r\n      performance\r\n    };\r\n  }\r\n\r\n  // Reset all user data\r\n  async resetAllUserData(user: AuthenticatedUser): Promise<void> {\r\n    if (this.isDemoUser(user)) {\r\n      // For demo users, we don't need to do anything as data is static\r\n      return;\r\n    }\r\n\r\n    try {\r\n      const response = await fetch(`${this.baseUrl}/users/${user.id}/reset`, {\r\n        method: 'POST',\r\n        headers: {\r\n          'Authorization': `Bearer ${user.token}`,\r\n          'Content-Type': 'application/json'\r\n        }\r\n      });\r\n\r\n      if (!response.ok) {\r\n        throw new Error('Failed to reset user data');\r\n      }\r\n    } catch (error) {\r\n      console.warn('Failed to reset real user data via API:', error);\r\n      // For mock users, we don't need to do anything as the stores will handle the reset\r\n      // The error is expected when API is not available\r\n    }\r\n  }\r\n\r\n  // Generate personalized mock data for authenticated users\r\n  private generatePersonalizedMockStats(user: AuthenticatedUser): UserStats {\r\n    const userHash = this.hashString(user.email);\r\n    const daysSinceJoin = Math.floor(userHash % 60) + 1; // 1-60 days\r\n    \r\n    return {\r\n      totalXP: Math.floor(userHash % 1000) + 100,\r\n      level: Math.floor((userHash % 1000) / 200) + 1,\r\n      currentLevelXP: userHash % 200,\r\n      nextLevelXP: 200,\r\n      cardsStudied: Math.floor(userHash % 500) + 50,\r\n      studyTime: Math.floor(userHash % 1200) + 60, // 1-20 hours\r\n      accuracy: 75 + (userHash % 20), // 75-95%\r\n      currentStreak: Math.floor(userHash % 15) + 1,\r\n      longestStreak: Math.floor(userHash % 30) + 5,\r\n      coins: Math.floor(userHash % 200) + 50,\r\n      gems: Math.floor(userHash % 20) + 5,\r\n      lastStudyDate: new Date().toISOString(),\r\n      joinDate: new Date(Date.now() - daysSinceJoin * 24 * 60 * 60 * 1000).toISOString()\r\n    };\r\n  }\r\n\r\n  private generatePersonalizedActivity(user: AuthenticatedUser, days: number): UserActivity[] {\r\n    const activities: UserActivity[] = [];\r\n    \r\n    for (let i = 0; i < days; i++) {\r\n      const date = new Date(Date.now() - i * 24 * 60 * 60 * 1000);\r\n      const dayHash = this.hashString(user.email + date.toDateString());\r\n      \r\n      // Some days have no activity\r\n      if (dayHash % 4 === 0) continue;\r\n      \r\n      activities.push({\r\n        date: date.toISOString().split('T')[0],\r\n        cardsStudied: Math.floor(dayHash % 50) + 5,\r\n        studyTime: Math.floor(dayHash % 120) + 10,\r\n        accuracy: 70 + (dayHash % 25),\r\n        xpGained: Math.floor(dayHash % 100) + 20\r\n      });\r\n    }\r\n    \r\n    return activities.reverse();\r\n  }\r\n\r\n  private generatePersonalizedAchievements(user: AuthenticatedUser): UserAchievement[] {\r\n    const userHash = this.hashString(user.email);\r\n    const baseAchievements = [...DEMO_ACHIEVEMENTS];\r\n    \r\n    // Add user-specific achievements based on their hash\r\n    if (userHash % 3 === 0) {\r\n      baseAchievements.push({\r\n        id: 'accuracy_master',\r\n        name: 'Accuracy Master',\r\n        description: 'Achieve 90% accuracy in a session',\r\n        icon: 'ðŸŽ¯',\r\n        unlockedAt: new Date(Date.now() - 5 * 24 * 60 * 60 * 1000).toISOString(),\r\n        category: 'accuracy'\r\n      });\r\n    }\r\n    \r\n    return baseAchievements;\r\n  }\r\n\r\n  private generatePersonalizedChallenges(user: AuthenticatedUser): UserChallenge[] {\r\n    // Generate personalized data based on user email\r\n    const challenges = [...DEMO_CHALLENGES];\r\n    \r\n    // Personalize challenge progress based on user\r\n    challenges.forEach(challenge => {\r\n      const progressHash = this.hashString(user.email + challenge.id);\r\n      challenge.current = Math.floor((progressHash % 80) / 100 * challenge.target);\r\n    });\r\n    \r\n    return challenges;\r\n  }\r\n\r\n  private generatePersonalizedLeaderboard(user: AuthenticatedUser): LeaderboardData {\r\n    const userHash = this.hashString(user.email);\r\n    const userScore = Math.floor(userHash % 1000) + 100;\r\n    const userRank = Math.floor(userHash % 50) + 5;\r\n    \r\n    const leaderboard = { ...DEMO_LEADERBOARD };\r\n    \r\n    // Insert user into leaderboards\r\n    leaderboard.global.push({\r\n      userId: user.id,\r\n      username: user.username,\r\n      score: userScore,\r\n      rank: userRank,\r\n      change: Math.floor(userHash % 10) - 5\r\n    });\r\n    \r\n    return leaderboard;\r\n  }\r\n\r\n  private generateDemoActivity(days: number): UserActivity[] {\r\n    const activities: UserActivity[] = [];\r\n    \r\n    for (let i = 0; i < days; i++) {\r\n      const date = new Date(Date.now() - i * 24 * 60 * 60 * 1000);\r\n      \r\n      // Skip some days to make it realistic\r\n      if (i % 3 === 0) continue;\r\n      \r\n      activities.push({\r\n        date: date.toISOString().split('T')[0],\r\n        cardsStudied: Math.floor(Math.random() * 40) + 10,\r\n        studyTime: Math.floor(Math.random() * 90) + 15,\r\n        accuracy: 80 + Math.floor(Math.random() * 15),\r\n        xpGained: Math.floor(Math.random() * 80) + 30\r\n      });\r\n    }\r\n    \r\n    return activities.reverse();\r\n  }\r\n\r\n  private generateDemoPerformanceMetrics(): UserPerformanceMetrics {\r\n    return {\r\n      weeklyProgress: {\r\n        cardsStudied: 180,\r\n        studyTime: 240, // 4 hours\r\n        accuracy: 87.5,\r\n        goal: 350\r\n      },\r\n      monthlyProgress: {\r\n        cardsStudied: 720,\r\n        studyTime: 1200, // 20 hours\r\n        decksCompleted: 8\r\n      },\r\n      studyPattern: {\r\n        preferredTime: 'evening',\r\n        averageSessionLength: 25,\r\n        studyFrequency: 5.2\r\n      }\r\n    };\r\n  }\r\n\r\n  private generatePersonalizedPerformanceMetrics(user: AuthenticatedUser): UserPerformanceMetrics {\r\n    const userHash = this.hashString(user.email);\r\n    \r\n    return {\r\n      weeklyProgress: {\r\n        cardsStudied: Math.floor(userHash % 200) + 50,\r\n        studyTime: Math.floor(userHash % 300) + 60,\r\n        accuracy: 75 + (userHash % 20),\r\n        goal: 300\r\n      },\r\n      monthlyProgress: {\r\n        cardsStudied: Math.floor(userHash % 800) + 200,\r\n        studyTime: Math.floor(userHash % 1500) + 300,\r\n        decksCompleted: Math.floor(userHash % 15) + 3\r\n      },\r\n      studyPattern: {\r\n        preferredTime: ['morning', 'afternoon', 'evening'][userHash % 3],\r\n        averageSessionLength: Math.floor(userHash % 30) + 15,\r\n        studyFrequency: 3 + (userHash % 4)\r\n      }\r\n    };\r\n  }\r\n\r\n  // Simple hash function for consistent personalization\r\n  private hashString(str: string): number {\r\n    let hash = 0;\r\n    for (let i = 0; i < str.length; i++) {\r\n      const char = str.charCodeAt(i);\r\n      hash = ((hash << 5) - hash) + char;\r\n      hash = hash & hash; // Convert to 32-bit integer\r\n    }\r\n    return Math.abs(hash);\r\n  }\r\n}\r\n\r\n// Export singleton instance\r\nexport const userDataService = new UserDataService();","import db, {\r\n  ensureDBOpen,\r\n  type SettingRow,\r\n  type UserRow,\r\n  type DeckRow,\r\n  type CardRow,\r\n  type ReviewRow,\r\n  type MediaRow,\r\n  type AchievementRow,\r\n  type ChallengeRow,\r\n  type LeaderboardCacheRow,\r\n  type MediaAnalyticsRow,\r\n  type UserOnlineLinkRow,\r\n  type SyncQueueRow\r\n} from '../data/db';\r\nimport { logError, logInfo } from './errorTrackingService';\r\n\r\nexport type ExportBundle = {\r\n  version: number; // export format version\r\n  exportedAt: number;\r\n  tables: {\r\n    settings?: SettingRow;\r\n    users?: UserRow[];\r\n    decks?: DeckRow[];\r\n    cards?: CardRow[];\r\n    reviews?: ReviewRow[];\r\n    media?: Omit<MediaRow, 'blob'>[]; // blobs omitted in JSON export\r\n    achievements?: AchievementRow[];\r\n    challenges?: ChallengeRow[];\r\n    leaderboardCache?: LeaderboardCacheRow[];\r\n    mediaAnalytics?: MediaAnalyticsRow[];\r\n    userOnlineLinks?: UserOnlineLinkRow[];\r\n    // Ephemeral/operational\r\n    syncQueue?: SyncQueueRow[];\r\n  };\r\n};\r\n\r\nexport type ImportOptions = {\r\n  includeEphemeral?: boolean; // default false (skip syncQueue)\r\n  overwriteSettings?: boolean; // default true\r\n};\r\n\r\nexport type ImportResult = {\r\n  ok: boolean;\r\n  counts: {\r\n    users?: number;\r\n    decks?: number;\r\n    cards?: number;\r\n    reviews?: number;\r\n    media?: number;\r\n    achievements?: number;\r\n    challenges?: number;\r\n    leaderboardCache?: number;\r\n    mediaAnalytics?: number;\r\n    userOnlineLinks?: number;\r\n    syncQueue?: number;\r\n  };\r\n};\r\n\r\n/**\r\n * Export all local data (JSON). Media blobs are excluded (manifest only).\r\n * Intended for backup/migration between browsers/devices.\r\n */\r\nexport async function exportAll(): Promise<ExportBundle> {\r\n  await ensureDBOpen();\r\n\r\n  const [settingsRow, users, decks, cards, reviews, mediaRows, achievements, challenges, leaderboardCache, mediaAnalytics, userOnlineLinks] =\r\n    await Promise.all([\r\n      db.settings.get('settings'),\r\n      db.users.toArray(),\r\n      db.decks.toArray(),\r\n      db.cards.toArray(),\r\n      db.reviews.toArray(),\r\n      db.media.toArray(),\r\n      db.achievements.toArray(),\r\n      db.challenges.toArray(),\r\n      db.leaderboardCache.toArray(),\r\n      db.mediaAnalytics?.toArray?.() ?? [],\r\n      db.userOnlineLinks?.toArray?.() ?? [],\r\n    ]);\r\n\r\n  // Strip Blob from media; keep metadata and pointers\r\n  const mediaNoBlob: Omit<MediaRow, 'blob'>[] = mediaRows.map(({ blob, ...rest }) => rest);\r\n\r\n  const bundle: ExportBundle = {\r\n    version: 1,\r\n    exportedAt: Date.now(),\r\n    tables: {\r\n      settings: settingsRow ?? { id: 'settings', createdAt: Date.now(), updatedAt: Date.now() },\r\n      users,\r\n      decks,\r\n      cards,\r\n      reviews,\r\n      media: mediaNoBlob,\r\n      achievements,\r\n      challenges,\r\n      leaderboardCache,\r\n      mediaAnalytics,\r\n      userOnlineLinks,\r\n      // syncQueue intentionally omitted by default (ephemeral)\r\n    },\r\n  };\r\n\r\n  logInfo('Export created', {\r\n    scope: 'exportImport.exportAll',\r\n    counts: {\r\n      users: users.length,\r\n      decks: decks.length,\r\n      cards: cards.length,\r\n      reviews: reviews.length,\r\n      media: mediaNoBlob.length,\r\n    },\r\n  });\r\n\r\n  return bundle;\r\n}\r\n\r\n/**\r\n * Create a JSON Blob from current export\r\n */\r\nexport async function exportToBlob(): Promise<Blob> {\r\n  const data = await exportAll();\r\n  const json = JSON.stringify(data, null, 2);\r\n  return new Blob([json], { type: 'application/json' });\r\n}\r\n\r\n/**\r\n * Trigger a browser download of the export JSON.\r\n * Returns the Blob for cases where programmatic handling is preferred.\r\n */\r\nexport async function downloadExport(filename?: string): Promise<Blob> {\r\n  const blob = await exportToBlob();\r\n  try {\r\n    if (typeof window !== 'undefined') {\r\n      const url = URL.createObjectURL(blob);\r\n      const a = document.createElement('a');\r\n      a.href = url;\r\n      a.download = filename || defaultExportFilename();\r\n      document.body.appendChild(a);\r\n      a.click();\r\n      document.body.removeChild(a);\r\n      URL.revokeObjectURL(url);\r\n    }\r\n  } catch (e) {\r\n    logError(e instanceof Error ? e : new Error(String(e)), { scope: 'exportImport.downloadExport' });\r\n  }\r\n  return blob;\r\n}\r\n\r\nfunction defaultExportFilename(): string {\r\n  const d = new Date();\r\n  const pad = (n: number) => String(n).padStart(2, '0');\r\n  const stamp = `${d.getFullYear()}${pad(d.getMonth() + 1)}${pad(d.getDate())}-${pad(d.getHours())}${pad(d.getMinutes())}${pad(d.getSeconds())}`;\r\n  return `studymaster-export-${stamp}.json`;\r\n}\r\n\r\n/**\r\n * Import a JSON bundle produced by exportAll().\r\n * Uses bulkPut to upsert records. Media blobs are not restored (manifest only).\r\n */\r\nexport async function importAll(bundle: ExportBundle, options?: ImportOptions): Promise<ImportResult> {\r\n  await ensureDBOpen();\r\n\r\n  if (!bundle || typeof bundle !== 'object' || !bundle.tables) {\r\n    throw new Error('Invalid import bundle');\r\n  }\r\n\r\n  const includeEphemeral = options?.includeEphemeral === true;\r\n  const overwriteSettings = options?.overwriteSettings !== false;\r\n\r\n  const counts: ImportResult['counts'] = {};\r\n\r\n  // Prepare table arrays (default to empty)\r\n  const t = bundle.tables;\r\n\r\n  await db.transaction(\r\n    'rw',\r\n    [\r\n      db.settings,\r\n      db.users,\r\n      db.decks,\r\n      db.cards,\r\n      db.reviews,\r\n      db.media,\r\n      db.achievements,\r\n      db.challenges,\r\n      db.leaderboardCache,\r\n      db.mediaAnalytics,\r\n      db.userOnlineLinks,\r\n      db.syncQueue\r\n    ],\r\n    async () => {\r\n      // settings\r\n      if (t.settings && overwriteSettings) {\r\n        await db.settings.put(t.settings);\r\n      }\r\n\r\n      // users\r\n      if (Array.isArray(t.users) && t.users.length) {\r\n        await db.users.bulkPut(t.users);\r\n        counts.users = t.users.length;\r\n      }\r\n\r\n      // decks\r\n      if (Array.isArray(t.decks) && t.decks.length) {\r\n        await db.decks.bulkPut(t.decks);\r\n        counts.decks = t.decks.length;\r\n      }\r\n\r\n      // cards\r\n      if (Array.isArray(t.cards) && t.cards.length) {\r\n        await db.cards.bulkPut(t.cards);\r\n        counts.cards = t.cards.length;\r\n      }\r\n\r\n      // reviews\r\n      if (Array.isArray(t.reviews) && t.reviews.length) {\r\n        await db.reviews.bulkPut(t.reviews);\r\n        counts.reviews = t.reviews.length;\r\n      }\r\n\r\n      // media (metadata only)\r\n      if (Array.isArray(t.media) && t.media.length) {\r\n        // cast since blob is omitted in input\r\n        await (db.media as any).bulkPut(t.media as any);\r\n        counts.media = t.media.length;\r\n      }\r\n\r\n      // achievements\r\n      if (Array.isArray(t.achievements) && t.achievements.length) {\r\n        await db.achievements.bulkPut(t.achievements);\r\n        counts.achievements = t.achievements.length;\r\n      }\r\n\r\n      // challenges\r\n      if (Array.isArray(t.challenges) && t.challenges.length) {\r\n        await db.challenges.bulkPut(t.challenges);\r\n        counts.challenges = t.challenges.length;\r\n      }\r\n\r\n      // leaderboardCache (optional)\r\n      if (Array.isArray(t.leaderboardCache) && t.leaderboardCache.length) {\r\n        await db.leaderboardCache.bulkPut(t.leaderboardCache);\r\n        counts.leaderboardCache = t.leaderboardCache.length;\r\n      }\r\n\r\n      // mediaAnalytics (optional)\r\n      if (Array.isArray(t.mediaAnalytics) && t.mediaAnalytics.length) {\r\n        await db.mediaAnalytics.bulkPut(t.mediaAnalytics);\r\n        counts.mediaAnalytics = t.mediaAnalytics.length;\r\n      }\r\n\r\n      // userOnlineLinks (optional)\r\n      if (Array.isArray(t.userOnlineLinks) && t.userOnlineLinks.length) {\r\n        await db.userOnlineLinks.bulkPut(t.userOnlineLinks);\r\n        counts.userOnlineLinks = t.userOnlineLinks.length;\r\n      }\r\n\r\n      // syncQueue (ephemeral, opt-in)\r\n      if (includeEphemeral && Array.isArray(t.syncQueue) && t.syncQueue.length) {\r\n        await db.syncQueue.bulkPut(t.syncQueue);\r\n        counts.syncQueue = t.syncQueue.length;\r\n      }\r\n    }\r\n  );\r\n\r\n  logInfo('Import completed', { scope: 'exportImport.importAll', counts });\r\n  return { ok: true, counts };\r\n}\r\n\r\n/**\r\n * Import from a File (JSON export)\r\n */\r\nexport async function importFromFile(file: File, options?: ImportOptions): Promise<ImportResult> {\r\n  const text = await file.text();\r\n  let data: ExportBundle;\r\n  try {\r\n    data = JSON.parse(text);\r\n  } catch (e) {\r\n    throw new Error('Invalid JSON file');\r\n  }\r\n  return importAll(data, options);\r\n}\r\n\r\nexport const exportImport = {\r\n  exportAll,\r\n  exportToBlob,\r\n  downloadExport,\r\n  importAll,\r\n  importFromFile,\r\n};\r\n\r\nexport default exportImport;","/**\r\n * Leaderboard Provider (Phase 2/3)\r\n * - Local-cached, offline-first provider with optional remote fetch/submit\r\n * - Caches leaderboard data in IndexedDB (leaderboardCache) with TTL\r\n * - Queues submissions in IndexedDB (syncQueue) when offline or on failure\r\n */\r\n\r\nimport { repos } from '../data';\r\nimport type { AuthenticatedUser, LeaderboardData, LeaderboardEntry } from './userDataService';\r\nimport { userDataService } from './userDataService';\r\n\r\ntype Scope = 'global' | 'friends' | 'weekly' | 'monthly';\r\n\r\nexport interface LeaderboardProvider {\r\n  fetchAll(user: AuthenticatedUser): Promise<LeaderboardData>;\r\n  fetchScope(user: AuthenticatedUser, scope: Scope): Promise<LeaderboardEntry[]>;\r\n  submit(user: AuthenticatedUser, scope: Scope, score: number): Promise<void>;\r\n}\r\n\r\nfunction toScopeKey(scope: Scope): string {\r\n  if (scope === 'friends') {\r\n    return `friends:global`;\r\n  }\r\n  return `${scope}:global`;\r\n}\r\n\r\nconst DEFAULT_TTL_MS = 10 * 60 * 1000; // 10 minutes\r\n\r\n// Map app entries -> cache entry shape\r\nfunction toCacheEntries(entries: LeaderboardEntry[]): { rank: number; name: string; anonymizedId: string; score: number }[] {\r\n  return entries.map(e => ({\r\n    rank: e.rank,\r\n    name: e.username,\r\n    anonymizedId: e.userId, // use userId as anonymizedId for local caching\r\n    score: e.score,\r\n  }));\r\n}\r\n\r\n// Map cache entry shape -> app entries\r\nfunction fromCacheEntries(entries: { rank: number; name: string; anonymizedId: string; score: number }[]): LeaderboardEntry[] {\r\n  return entries.map((e) => ({\r\n    userId: e.anonymizedId,\r\n    username: e.name,\r\n    score: e.score,\r\n    rank: e.rank,\r\n    change: 0, // cached rows don't track change; show neutral; remote fetch will provide real values\r\n  }));\r\n}\r\n\r\nasync function cacheWrite(scope: Scope, entries: LeaderboardEntry[], ttlMs: number = DEFAULT_TTL_MS): Promise<void> {\r\n  await repos.leaderboardCache.set({\r\n    scope: toScopeKey(scope),\r\n    entries: toCacheEntries(entries),\r\n    ttlMs,\r\n  });\r\n}\r\n\r\nasync function cacheRead(scope: Scope, ignoreTTL = false): Promise<LeaderboardEntry[] | null> {\r\n  const row = await repos.leaderboardCache.get(toScopeKey(scope), { ignoreTTL });\r\n  return row ? fromCacheEntries(row.entries) : null;\r\n}\r\n\r\nasync function tryRemoteFetchAll(user: AuthenticatedUser): Promise<LeaderboardData> {\r\n  return userDataService.getLeaderboardData(user);\r\n}\r\n\r\nasync function tryRemoteSubmit(user: AuthenticatedUser, scope: Scope, score: number, requestId: string): Promise<void> {\r\n  const response = await fetch('/api/leaderboard/submit', {\r\n    method: 'POST',\r\n    headers: {\r\n      'Content-Type': 'application/json',\r\n      ...(user.token ? { Authorization: `Bearer ${user.token}` } : {}),\r\n      'X-Idempotency-Key': requestId,\r\n    },\r\n    body: JSON.stringify({ scope, score, userId: user.id, username: user.username, requestId }),\r\n  });\r\n  if (!response.ok) {\r\n    throw new Error(`Remote submit failed: ${response.status}`);\r\n  }\r\n}\r\n\r\nasync function enqueueSubmit(scope: Scope, score: number, user: AuthenticatedUser): Promise<void> {\r\n  await repos.syncQueue.enqueue({\r\n    opType: 'leaderboard:submit',\r\n    payload: {\r\n      scope,\r\n      score,\r\n      user: { id: user.id, username: user.username, token: user.token },\r\n      queuedAt: Date.now(),\r\n    },\r\n  });\r\n}\r\n\r\n// Detect if Background Sync is supported; when true, Workbox will queue failed POSTs\r\nfunction supportsBackgroundSync(): boolean {\r\n  try {\r\n    return typeof window !== 'undefined' && 'serviceWorker' in navigator && 'SyncManager' in window;\r\n  } catch {\r\n    return false;\r\n  }\r\n}\r\n\r\nclass LocalCachedLeaderboardProvider implements LeaderboardProvider {\r\n  async fetchAll(user: AuthenticatedUser): Promise<LeaderboardData> {\r\n    try {\r\n      const data = await tryRemoteFetchAll(user);\r\n      await Promise.all([\r\n        cacheWrite('global', data.global),\r\n        cacheWrite('friends', data.friends),\r\n        cacheWrite('weekly', data.weekly),\r\n        cacheWrite('monthly', data.monthly),\r\n      ]);\r\n      return data;\r\n    } catch {\r\n      const [global, friends, weekly, monthly] = await Promise.all([\r\n        cacheRead('global', true).then(v => v ?? []),\r\n        cacheRead('friends', true).then(v => v ?? []),\r\n        cacheRead('weekly', true).then(v => v ?? []),\r\n        cacheRead('monthly', true).then(v => v ?? []),\r\n      ]);\r\n      return { global, friends, weekly, monthly };\r\n    }\r\n  }\r\n\r\n  async fetchScope(user: AuthenticatedUser, scope: Scope): Promise<LeaderboardEntry[]> {\r\n    const all = await this.fetchAll(user);\r\n    return all[scope] || [];\r\n  }\r\n\r\n  async submit(user: AuthenticatedUser, scope: Scope, score: number): Promise<void> {\r\n    // Always attempt network submit first so Workbox Background Sync can capture failures\r\n    const requestId = `lb_${user.id}_${scope}_${score}_${Date.now()}`;\r\n    try {\r\n      await tryRemoteSubmit(user, scope, score, requestId);\r\n      return;\r\n    } catch {\r\n      // If Background Sync is available, Workbox will have queued the failed POST\r\n      if (supportsBackgroundSync()) return;\r\n      // Fallback to app-level IndexedDB queue (handled by syncQueueFlusher)\r\n      await enqueueSubmit(scope, score, user);\r\n    }\r\n  }\r\n}\r\n\r\nlet _instance: LeaderboardProvider | null = null;\r\n\r\nexport function getLeaderboardService(): LeaderboardProvider {\r\n  if (_instance) return _instance;\r\n  _instance = new LocalCachedLeaderboardProvider();\r\n  return _instance;\r\n}\r\n\r\nexport type { LeaderboardEntry, LeaderboardData };","// Removed unused imports: useDeckStore and useGamificationStore\r\n\r\n// Types for real-time data\r\nexport interface GlobalLearningStats {\r\n  totalLearners: number\r\n  cardsStudiedToday: number\r\n  activeStudySessions: number\r\n  languagesBeingLearned: number\r\n  topSubjects: Array<{ name: string; learners: number }>\r\n  studyTimeToday: number // in minutes\r\n  lastUpdated: string\r\n}\r\n\r\nexport interface EducationalTrends {\r\n  popularSubjects: Array<{ subject: string; growth: number; learners: number }>\r\n  learningMethods: Array<{ method: string; effectiveness: number; usage: number }>\r\n  studyPatterns: {\r\n    peakHours: Array<{ hour: number; activity: number }>\r\n    weeklyTrends: Array<{ day: string; sessions: number }>\r\n  }\r\n  lastUpdated: string\r\n}\r\n\r\nexport interface LiveUserMetrics {\r\n  onlineUsers: number\r\n  studyingSessions: number\r\n  completedToday: number\r\n  averageAccuracy: number\r\n  topPerformers: Array<{ username: string; score: number; country: string }>\r\n  lastUpdated: string\r\n}\r\n\r\nexport interface MarketInsights {\r\n  skillDemand: Array<{ skill: string; demand: number; growth: number }>\r\n  industryTrends: Array<{ industry: string; skills: string[]; growth: number }>\r\n  certificationValue: Array<{ cert: string; value: number; popularity: number }>\r\n  lastUpdated: string\r\n}\r\n\r\n// Real-time data service class\r\nexport class RealTimeDataService {\r\n  private updateInterval: number = 30000 // 30 seconds\r\n  private subscribers: Map<string, ((data: unknown) => void)[]> = new Map()\r\n  private intervalId: NodeJS.Timeout | null = null\r\n  private activeInstances: number = 0 // Reference counter for active instances\r\n\r\n  // Subscribe to real-time updates\r\n  subscribe<T = unknown>(dataType: string, callback: (data: T) => void): () => void {\r\n    if (!this.subscribers.has(dataType)) {\r\n      this.subscribers.set(dataType, [])\r\n    }\r\n    this.subscribers.get(dataType)!.push(callback as (data: unknown) => void)\r\n\r\n    // Return unsubscribe function\r\n    return () => {\r\n      const callbacks = this.subscribers.get(dataType)\r\n      if (callbacks) {\r\n        const index = callbacks.indexOf(callback as (data: unknown) => void)\r\n        if (index > -1) {\r\n          callbacks.splice(index, 1)\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // Notify subscribers\r\n  private notify(dataType: string, data: unknown): void {\r\n    const callbacks = this.subscribers.get(dataType)\r\n    if (callbacks) {\r\n      callbacks.forEach(callback => callback(data))\r\n    }\r\n  }\r\n\r\n  // Fetch global learning statistics from multiple sources\r\n  async getGlobalLearningStats(): Promise<GlobalLearningStats> {\r\n    try {\r\n      // Try to fetch from real educational APIs\r\n      const stats = await this.fetchFromMultipleSources([\r\n        () => this.fetchFromDuolingoAPI(),\r\n        () => this.fetchFromKhanAcademyAPI(),\r\n        () => this.fetchFromCourseraAPI(),\r\n        () => this.fetchFromEducationalDataAPI()\r\n      ])\r\n\r\n      if (stats) {\r\n        this.notify('globalStats', stats)\r\n        return stats as GlobalLearningStats\r\n      }\r\n    } catch (error) {\r\n      console.warn('Failed to fetch real global stats, using enhanced mock data:', error)\r\n    }\r\n\r\n    // Enhanced realistic mock data with time-based variations\r\n    return this.generateEnhancedGlobalStats()\r\n  }\r\n\r\n  // Fetch educational trends from research APIs\r\n  async getEducationalTrends(): Promise<EducationalTrends> {\r\n    try {\r\n      // Try to fetch from educational research APIs\r\n      const trends = await this.fetchEducationalTrendsFromAPIs()\r\n      if (trends) {\r\n        this.notify('educationalTrends', trends)\r\n        return trends\r\n      }\r\n    } catch (error) {\r\n      console.warn('Failed to fetch real educational trends, using enhanced mock data:', error)\r\n    }\r\n\r\n    return this.generateEnhancedEducationalTrends()\r\n  }\r\n\r\n  // Fetch live user metrics\r\n  async getLiveUserMetrics(): Promise<LiveUserMetrics> {\r\n    try {\r\n      // Try to fetch from real-time analytics APIs\r\n      const metrics = await this.fetchLiveMetricsFromAPIs()\r\n      if (metrics) {\r\n        this.notify('liveMetrics', metrics)\r\n        return metrics\r\n      }\r\n    } catch (error) {\r\n      console.warn('Failed to fetch real live metrics, using enhanced mock data:', error)\r\n    }\r\n\r\n    return this.generateEnhancedLiveMetrics()\r\n  }\r\n\r\n  // Fetch market insights from job/skill APIs\r\n  async getMarketInsights(): Promise<MarketInsights> {\r\n    try {\r\n      // Try to fetch from job market APIs\r\n      const insights = await this.fetchMarketInsightsFromAPIs()\r\n      if (insights) {\r\n        this.notify('marketInsights', insights)\r\n        return insights\r\n      }\r\n    } catch (error) {\r\n      console.warn('Failed to fetch real market insights, using enhanced mock data:', error)\r\n    }\r\n\r\n    return this.generateEnhancedMarketInsights()\r\n  }\r\n\r\n  // Attempt to fetch from Duolingo's public API\r\n  private async fetchFromDuolingoAPI(): Promise<Partial<GlobalLearningStats> | null> {\r\n    try {\r\n      // Note: Duolingo doesn't have a public API for global stats\r\n      // This is a placeholder for when such APIs become available\r\n      const response = await fetch('https://www.duolingo.com/api/1/users/show?username=duolingo', {\r\n        method: 'GET',\r\n        headers: { 'Accept': 'application/json' }\r\n      })\r\n      \r\n      if (response.ok) {\r\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n        const _data = await response.json()\r\n        // Extract relevant statistics if available\r\n        return null // Placeholder\r\n      }\r\n    } catch (error) {\r\n      console.log('Duolingo API not accessible:', error)\r\n    }\r\n    return null\r\n  }\r\n\r\n  // Attempt to fetch from Khan Academy's API\r\n  private async fetchFromKhanAcademyAPI(): Promise<Partial<GlobalLearningStats> | null> {\r\n    try {\r\n      // Khan Academy has limited public APIs\r\n      // This is a placeholder for educational statistics\r\n      return null\r\n    } catch (error) {\r\n      console.log('Khan Academy API not accessible:', error)\r\n    }\r\n    return null\r\n  }\r\n\r\n  // Attempt to fetch from Coursera's API\r\n  private async fetchFromCourseraAPI(): Promise<Partial<GlobalLearningStats> | null> {\r\n    try {\r\n      // Coursera doesn't have public global statistics API\r\n      // This is a placeholder\r\n      return null\r\n    } catch (error) {\r\n      console.log('Coursera API not accessible:', error)\r\n    }\r\n    return null\r\n  }\r\n\r\n  // Attempt to fetch from educational data APIs\r\n  private async fetchFromEducationalDataAPI(): Promise<Partial<GlobalLearningStats> | null> {\r\n    try {\r\n      // Try to fetch from open educational data sources\r\n      // This could include UNESCO, World Bank education data, etc.\r\n      return null\r\n    } catch (error) {\r\n      console.log('Educational data API not accessible:', error)\r\n    }\r\n    return null\r\n  }\r\n\r\n  // Fetch from multiple sources and combine results\r\n  private async fetchFromMultipleSources(fetchers: Array<() => Promise<unknown>>): Promise<unknown> {\r\n    const results = await Promise.allSettled(fetchers.map(fetcher => fetcher()))\r\n    \r\n    // Combine successful results\r\n    const successfulResults = results\r\n      .filter(result => result.status === 'fulfilled' && result.value)\r\n      .map(result => (result as PromiseFulfilledResult<unknown>).value)\r\n\r\n    if (successfulResults.length > 0) {\r\n      // Merge results from multiple sources\r\n      return this.mergeDataSources(successfulResults)\r\n    }\r\n\r\n    return null\r\n  }\r\n\r\n  // Merge data from multiple sources\r\n  private mergeDataSources(sources: unknown[]): unknown {\r\n    // Implement logic to combine data from multiple sources\r\n    // For now, return the first successful source\r\n    return sources[0]\r\n  }\r\n\r\n  // Generate enhanced realistic global statistics\r\n  private generateEnhancedGlobalStats(): GlobalLearningStats {\r\n    const now = new Date()\r\n    const hour = now.getHours()\r\n    const dayOfWeek = now.getDay()\r\n    \r\n    // Time-based activity simulation\r\n    const timeMultiplier = this.getTimeBasedMultiplier(hour, dayOfWeek)\r\n    \r\n    // Base numbers that feel realistic for a global learning platform\r\n    const baseLearners = 2847392\r\n    const baseCardsToday = 15847293\r\n    const baseActiveSessions = 23847\r\n    \r\n    return {\r\n      totalLearners: Math.floor(baseLearners + (Math.random() * 1000 - 500)),\r\n      cardsStudiedToday: Math.floor(baseCardsToday * timeMultiplier + (Math.random() * 10000 - 5000)),\r\n      activeStudySessions: Math.floor(baseActiveSessions * timeMultiplier + (Math.random() * 1000 - 500)),\r\n      languagesBeingLearned: 127 + Math.floor(Math.random() * 5),\r\n      topSubjects: [\r\n        { name: 'Spanish', learners: Math.floor(847392 * timeMultiplier) },\r\n        { name: 'JavaScript', learners: Math.floor(623847 * timeMultiplier) },\r\n        { name: 'French', learners: Math.floor(534829 * timeMultiplier) },\r\n        { name: 'Python', learners: Math.floor(487293 * timeMultiplier) },\r\n        { name: 'German', learners: Math.floor(392847 * timeMultiplier) }\r\n      ],\r\n      studyTimeToday: Math.floor(1847293 * timeMultiplier), // in minutes\r\n      lastUpdated: now.toISOString()\r\n    }\r\n  }\r\n\r\n  // Generate enhanced educational trends\r\n  private generateEnhancedEducationalTrends(): EducationalTrends {\r\n    const now = new Date()\r\n    \r\n    return {\r\n      popularSubjects: [\r\n        { subject: 'Artificial Intelligence', growth: 156.7, learners: 892847 },\r\n        { subject: 'Data Science', growth: 134.2, learners: 734829 },\r\n        { subject: 'Cybersecurity', growth: 128.9, learners: 623847 },\r\n        { subject: 'Cloud Computing', growth: 119.4, learners: 587293 },\r\n        { subject: 'Machine Learning', growth: 112.8, learners: 534829 },\r\n        { subject: 'Spanish Language', growth: 89.3, learners: 1247392 },\r\n        { subject: 'Digital Marketing', growth: 87.6, learners: 423847 },\r\n        { subject: 'UX/UI Design', growth: 82.4, learners: 392847 }\r\n      ],\r\n      learningMethods: [\r\n        { method: 'Spaced Repetition', effectiveness: 94.7, usage: 78.3 },\r\n        { method: 'Active Recall', effectiveness: 91.2, usage: 65.8 },\r\n        { method: 'Microlearning', effectiveness: 87.9, usage: 82.1 },\r\n        { method: 'Gamification', effectiveness: 84.6, usage: 71.4 },\r\n        { method: 'Peer Learning', effectiveness: 81.3, usage: 56.7 }\r\n      ],\r\n      studyPatterns: {\r\n        peakHours: this.generatePeakHours(),\r\n        weeklyTrends: this.generateWeeklyTrends()\r\n      },\r\n      lastUpdated: now.toISOString()\r\n    }\r\n  }\r\n\r\n  // Generate enhanced live user metrics\r\n  private generateEnhancedLiveMetrics(): LiveUserMetrics {\r\n    const now = new Date()\r\n    const hour = now.getHours()\r\n    const timeMultiplier = this.getTimeBasedMultiplier(hour, now.getDay())\r\n    \r\n    return {\r\n      onlineUsers: Math.floor(47392 * timeMultiplier + (Math.random() * 1000 - 500)),\r\n      studyingSessions: Math.floor(23847 * timeMultiplier + (Math.random() * 500 - 250)),\r\n      completedToday: Math.floor(184729 + (Math.random() * 1000 - 500)),\r\n      averageAccuracy: 87.3 + (Math.random() * 4 - 2),\r\n      topPerformers: [\r\n        { username: 'StudyMaster_Pro', score: 15847, country: 'Singapore' },\r\n        { username: 'LearningNinja', score: 14923, country: 'South Korea' },\r\n        { username: 'FlashcardWiz', score: 14756, country: 'Finland' },\r\n        { username: 'MemoryChamp', score: 14234, country: 'Japan' },\r\n        { username: 'QuizMaster', score: 13892, country: 'Canada' }\r\n      ],\r\n      lastUpdated: now.toISOString()\r\n    }\r\n  }\r\n\r\n  // Generate enhanced market insights\r\n  private generateEnhancedMarketInsights(): MarketInsights {\r\n    const now = new Date()\r\n    \r\n    return {\r\n      skillDemand: [\r\n        { skill: 'AI/Machine Learning', demand: 94.7, growth: 156.3 },\r\n        { skill: 'Cloud Architecture', demand: 91.2, growth: 134.7 },\r\n        { skill: 'Cybersecurity', demand: 89.8, growth: 128.9 },\r\n        { skill: 'Data Analysis', demand: 87.4, growth: 119.2 },\r\n        { skill: 'DevOps', demand: 84.9, growth: 112.6 },\r\n        { skill: 'Full-Stack Development', demand: 82.3, growth: 98.4 },\r\n        { skill: 'Digital Marketing', demand: 78.7, growth: 87.9 },\r\n        { skill: 'UX Design', demand: 76.2, growth: 82.1 }\r\n      ],\r\n      industryTrends: [\r\n        { \r\n          industry: 'Technology', \r\n          skills: ['AI/ML', 'Cloud Computing', 'Cybersecurity'], \r\n          growth: 145.7 \r\n        },\r\n        { \r\n          industry: 'Healthcare', \r\n          skills: ['Data Analysis', 'Digital Health', 'Telemedicine'], \r\n          growth: 123.4 \r\n        },\r\n        { \r\n          industry: 'Finance', \r\n          skills: ['Blockchain', 'FinTech', 'Risk Analysis'], \r\n          growth: 118.9 \r\n        },\r\n        { \r\n          industry: 'Education', \r\n          skills: ['EdTech', 'Online Learning', 'Digital Pedagogy'], \r\n          growth: 134.2 \r\n        }\r\n      ],\r\n      certificationValue: [\r\n        { cert: 'AWS Certified Solutions Architect', value: 98.7, popularity: 87.3 },\r\n        { cert: 'Google Cloud Professional', value: 96.2, popularity: 82.1 },\r\n        { cert: 'Certified Ethical Hacker', value: 94.8, popularity: 76.4 },\r\n        { cert: 'PMP Certification', value: 91.3, popularity: 89.7 },\r\n        { cert: 'Cisco CCNA', value: 88.9, popularity: 78.2 }\r\n      ],\r\n      lastUpdated: now.toISOString()\r\n    }\r\n  }\r\n\r\n  // Get time-based activity multiplier\r\n  private getTimeBasedMultiplier(hour: number, dayOfWeek: number): number {\r\n    // Peak hours: 9-11 AM, 2-4 PM, 7-9 PM\r\n    let hourMultiplier = 0.7 // Base activity\r\n    \r\n    if ((hour >= 9 && hour <= 11) || (hour >= 14 && hour <= 16) || (hour >= 19 && hour <= 21)) {\r\n      hourMultiplier = 1.2 // Peak hours\r\n    } else if (hour >= 6 && hour <= 23) {\r\n      hourMultiplier = 1.0 // Normal hours\r\n    }\r\n    \r\n    // Weekend vs weekday\r\n    const dayMultiplier = (dayOfWeek === 0 || dayOfWeek === 6) ? 0.8 : 1.0\r\n    \r\n    return hourMultiplier * dayMultiplier\r\n  }\r\n\r\n  // Generate realistic peak hours data\r\n  private generatePeakHours(): Array<{ hour: number; activity: number }> {\r\n    const peakHours = []\r\n    for (let hour = 0; hour < 24; hour++) {\r\n      let activity = 30 // Base activity\r\n      \r\n      // Morning peak (9-11 AM)\r\n      if (hour >= 9 && hour <= 11) activity = 85 + Math.random() * 10\r\n      // Afternoon peak (2-4 PM)\r\n      else if (hour >= 14 && hour <= 16) activity = 90 + Math.random() * 10\r\n      // Evening peak (7-9 PM)\r\n      else if (hour >= 19 && hour <= 21) activity = 95 + Math.random() * 10\r\n      // Normal hours\r\n      else if (hour >= 6 && hour <= 23) activity = 60 + Math.random() * 20\r\n      // Night hours\r\n      else activity = 20 + Math.random() * 15\r\n      \r\n      peakHours.push({ hour, activity: Math.floor(activity) })\r\n    }\r\n    return peakHours\r\n  }\r\n\r\n  // Generate weekly trends\r\n  private generateWeeklyTrends(): Array<{ day: string; sessions: number }> {\r\n    const days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']\r\n    const baseSessions = [8500, 9200, 9800, 9500, 8900, 7200, 6800] // Realistic weekly pattern\r\n    \r\n    return days.map((day, index) => ({\r\n      day,\r\n      sessions: Math.floor(baseSessions[index] + (Math.random() * 1000 - 500))\r\n    }))\r\n  }\r\n\r\n  // Placeholder methods for real API calls\r\n  private async fetchEducationalTrendsFromAPIs(): Promise<EducationalTrends | null> {\r\n    // Implement real API calls to educational research databases\r\n    return null\r\n  }\r\n\r\n  private async fetchLiveMetricsFromAPIs(): Promise<LiveUserMetrics | null> {\r\n    // Implement real API calls to analytics services\r\n    return null\r\n  }\r\n\r\n  private async fetchMarketInsightsFromAPIs(): Promise<MarketInsights | null> {\r\n    // Implement real API calls to job market APIs (LinkedIn, Indeed, etc.)\r\n    return null\r\n  }\r\n\r\n  // Start real-time updates with reference counting\r\n  startRealTimeUpdates(): () => void {\r\n    this.activeInstances++\r\n    \r\n    // Only start interval if this is the first instance\r\n    if (this.activeInstances === 1 && !this.intervalId) {\r\n      this.intervalId = setInterval(async () => {\r\n        try {\r\n          const [globalStats, trends, liveMetrics, marketInsights] = await Promise.all([\r\n            this.getGlobalLearningStats(),\r\n            this.getEducationalTrends(),\r\n            this.getLiveUserMetrics(),\r\n            this.getMarketInsights()\r\n          ])\r\n\r\n          // Notify all subscribers with fresh data\r\n          this.notify('globalStats', globalStats)\r\n          this.notify('educationalTrends', trends)\r\n          this.notify('liveMetrics', liveMetrics)\r\n          this.notify('marketInsights', marketInsights)\r\n        } catch (error) {\r\n          console.error('Error updating real-time data:', error)\r\n        }\r\n      }, this.updateInterval)\r\n    }\r\n\r\n    // Return cleanup function\r\n    return () => {\r\n      this.stopRealTimeUpdates()\r\n    }\r\n  }\r\n\r\n  // Stop real-time updates with reference counting\r\n  stopRealTimeUpdates(): void {\r\n    this.activeInstances = Math.max(0, this.activeInstances - 1)\r\n    \r\n    // Only stop interval when no more active instances\r\n    if (this.activeInstances === 0 && this.intervalId) {\r\n      clearInterval(this.intervalId)\r\n      this.intervalId = null\r\n    }\r\n  }\r\n\r\n  // Force stop all real-time updates (for cleanup)\r\n  forceStopRealTimeUpdates(): void {\r\n    this.activeInstances = 0\r\n    if (this.intervalId) {\r\n      clearInterval(this.intervalId)\r\n      this.intervalId = null\r\n    }\r\n    // Clear all subscriptions\r\n    this.subscribers.clear()\r\n  }\r\n}\r\n\r\n// Export singleton instance\r\nexport const realTimeDataService = new RealTimeDataService()","import axios from 'axios';\nimport { UnifiedSessionState, CardSelectionResult, EnhancedResponseLog } from '../../../shared/types/enhanced-types';\n\nconst apiClient = axios.create({\n  baseURL: import.meta.env.VITE_API_URL || 'http://localhost:3001/api',\n  withCredentials: true,\n});\n\nexport const uamsApiService = {\n  async initializeSession(userId: string, deckId: string): Promise<UnifiedSessionState> {\n    const response = await apiClient.post('/uams/session/initialize', { userId, deckId });\n    return response.data;\n  },\n\n  async getNextCard(sessionState: UnifiedSessionState): Promise<CardSelectionResult> {\n    const response = await apiClient.post('/uams/session/next-card', { sessionState });\n    return response.data;\n  },\n\n  async processCardResponse(sessionState: UnifiedSessionState, cardId: string, response: EnhancedResponseLog): Promise<UnifiedSessionState> {\n    const apiResponse = await apiClient.post('/uams/session/response', { sessionState, cardId, response });\n    return apiResponse.data;\n  },\n};\n","import { UnifiedSessionState, UnifiedCard, CardSelectionResult, EnhancedResponseLog, SessionContext, UserProfile } from '../../../shared/types/enhanced-types';\nimport { uamsApiService } from './uamsApiService';\n\nexport interface QueueManagerConfig {\n  lookaheadBufferSize: number;\n  emergencyBufferSize: number;\n  challengeReserveSize: number;\n  refreshThreshold: number;\n  maxSessionDurationMinutes: number;\n  adaptiveRefreshInterval: number;\n}\n\nexport interface BufferMetrics {\n  lookaheadUtilization: number;\n  emergencyBufferHealth: number;\n  challengeReserveReadiness: number;\n  overallQueueHealth: number;\n}\n\nexport class UnifiedQueueManager {\n  private config: QueueManagerConfig;\n\n  constructor(config: Partial<QueueManagerConfig> = {}) {\n    this.config = {\n      lookaheadBufferSize: 10,\n      emergencyBufferSize: 5,\n      challengeReserveSize: 5,\n      refreshThreshold: 3,\n      maxSessionDurationMinutes: 120,\n      adaptiveRefreshInterval: 5000,\n      ...config\n    };\n  }\n\n  /**\n   * Initialize a new study session\n   */\n  async initializeSession(userId: string, deckId: string): Promise<UnifiedSessionState> {\n    return uamsApiService.initializeSession(userId, deckId);\n  }\n\n  /**\n   * Get the next card for review\n   */\n  async getNextCard(sessionState: UnifiedSessionState): Promise<CardSelectionResult> {\n    return uamsApiService.getNextCard(sessionState);\n  }\n\n  /**\n   * Process user response and update session state\n   */\n  async processCardResponse(\n    sessionState: UnifiedSessionState,\n    cardId: string,\n    response: EnhancedResponseLog\n  ): Promise<UnifiedSessionState> {\n    return uamsApiService.processCardResponse(sessionState, cardId, response);\n  }\n}","import { EnvironmentalContext, SessionContext } from '../../../../shared/types/enhanced-types';\r\n\r\nexport interface DetectedContext extends EnvironmentalContext {\r\n  confidence: number; // 0-1 confidence in detection accuracy\r\n  detectionMethod: string; // How the context was detected\r\n  timestamp: string;\r\n}\r\n\r\nexport interface ContextualInsights {\r\n  optimalStudyConditions: EnvironmentalContext;\r\n  currentConditionScore: number; // 0-1 how optimal current conditions are\r\n  improvementSuggestions: string[];\r\n  historicalPerformance: PerformanceByContext[];\r\n}\r\n\r\nexport interface PerformanceByContext {\r\n  context: Partial<EnvironmentalContext>;\r\n  averageAccuracy: number;\r\n  averageResponseTime: number;\r\n  sessionCount: number;\r\n  confidenceInterval: [number, number];\r\n}\r\n\r\nexport interface EnvironmentalAdaptation {\r\n  difficultyAdjustment: number; // Adjustment based on environment (-3 to +3)\r\n  recommendedBreakFrequency: number; // Minutes between suggested breaks\r\n  visualOptimizations: {\r\n    contrastAdjustment: number; // -1 to +1\r\n    fontSizeAdjustment: number; // -1 to +1 (relative)\r\n    colorScheme: 'light' | 'dark' | 'auto';\r\n  };\r\n  audioOptimizations: {\r\n    enableSoundEffects: boolean;\r\n    volumeAdjustment: number; // 0-1\r\n  };\r\n}\r\n\r\nexport class EnvironmentalContextService {\r\n  private contextHistory: DetectedContext[] = [];\r\n  private performanceCache: Map<string, PerformanceByContext> = new Map();\r\n\r\n  /**\r\n   * Get comprehensive current environmental context\r\n   */\r\n  async getCurrentContext(): Promise<DetectedContext> {\r\n    const context: EnvironmentalContext = {\r\n      device: this.detectDevice(),\r\n      networkQuality: await this.assessNetworkQuality(),\r\n    };\r\n    \r\n    let confidence = 0.9; // Base confidence\r\n\r\n    // Enhanced mobile detection with additional context\r\n    if (context.device === 'mobile') {\r\n      try {\r\n        context.batteryLevel = await this.getBatteryLevel();\r\n        if (context.batteryLevel !== undefined) confidence += 0.05;\r\n      } catch (error) {\r\n        console.warn('Battery level detection failed:', error);\r\n      }\r\n    }\r\n\r\n    // Ambient conditions detection\r\n    try {\r\n      context.ambientNoise = await this.detectAmbientNoise();\r\n      context.lighting = await this.detectLightingConditions();\r\n      confidence += 0.05;\r\n    } catch (error) {\r\n      console.warn('Ambient conditions detection failed:', error);\r\n      confidence -= 0.1;\r\n    }\r\n\r\n    const detectedContext: DetectedContext = {\r\n      ...context,\r\n      confidence: Math.max(0.5, confidence),\r\n      detectionMethod: 'multi-sensor-fusion',\r\n      timestamp: new Date().toISOString()\r\n    };\r\n\r\n    // Store in history\r\n    this.contextHistory.push(detectedContext);\r\n    if (this.contextHistory.length > 100) {\r\n      this.contextHistory.shift(); // Keep only last 100 entries\r\n    }\r\n\r\n    return detectedContext;\r\n  }\r\n\r\n  /**\r\n   * Detect device type with enhanced accuracy\r\n   */\r\n  private detectDevice(): 'mobile' | 'desktop' | 'tablet' {\r\n    const userAgent = navigator.userAgent.toLowerCase();\r\n    const platform = navigator.platform?.toLowerCase() || '';\r\n    \r\n    // Check for mobile indicators\r\n    const mobileKeywords = ['mobile', 'android', 'iphone', 'ipod', 'blackberry', 'windows phone'];\r\n    const isMobile = mobileKeywords.some(keyword => userAgent.includes(keyword));\r\n    \r\n    // Check for tablet indicators\r\n    const tabletKeywords = ['ipad', 'tablet', 'kindle', 'playbook', 'silk'];\r\n    const isTablet = tabletKeywords.some(keyword => userAgent.includes(keyword));\r\n    \r\n    // Enhanced detection using screen size and touch capabilities\r\n    const screenWidth = window.screen.width;\r\n    const screenHeight = window.screen.height;\r\n    const maxDimension = Math.max(screenWidth, screenHeight);\r\n    const minDimension = Math.min(screenWidth, screenHeight);\r\n    \r\n    const hasTouchScreen = 'ontouchstart' in window || navigator.maxTouchPoints > 0;\r\n    \r\n    if (isTablet || (hasTouchScreen && minDimension >= 768 && maxDimension >= 1024)) {\r\n      return 'tablet';\r\n    }\r\n    \r\n    if (isMobile || (hasTouchScreen && maxDimension <= 736)) {\r\n      return 'mobile';\r\n    }\r\n    \r\n    // Additional checks for desktop\r\n    const isDesktop = platform.includes('win') || platform.includes('mac') || platform.includes('linux');\r\n    \r\n    return isDesktop || !hasTouchScreen ? 'desktop' : 'mobile';\r\n  }\r\n\r\n  /**\r\n   * Assess network quality with multiple metrics\r\n   */\r\n  private async assessNetworkQuality(): Promise<'excellent' | 'good' | 'poor' | 'offline'> {\r\n    if (!navigator.onLine) return 'offline';\r\n    \r\n    try {\r\n      // Use Connection API if available (Chrome/Edge)\r\n      const connection = (navigator as any).connection || (navigator as any).mozConnection || (navigator as any).webkitConnection;\r\n      \r\n      if (connection) {\r\n        const effectiveType = connection.effectiveType;\r\n        const downlink = connection.downlink;\r\n        const rtt = connection.rtt;\r\n        \r\n        // Advanced classification based on multiple metrics\r\n        if (effectiveType === '4g' && downlink > 10 && rtt < 100) {\r\n          return 'excellent';\r\n        } else if ((effectiveType === '4g' || effectiveType === '3g') && downlink > 2 && rtt < 300) {\r\n          return 'good';\r\n        } else if (downlink > 0.5 && rtt < 1000) {\r\n          return 'good';\r\n        } else {\r\n          return 'poor';\r\n        }\r\n      }\r\n      \r\n      // Fallback: Performance-based detection\r\n      return await this.performLatencyTest();\r\n    } catch (error) {\r\n      console.warn('Network quality assessment failed:', error);\r\n      return 'good'; // Default assumption\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Perform latency test for network quality\r\n   */\r\n  private async performLatencyTest(): Promise<'excellent' | 'good' | 'poor'> {\r\n    try {\r\n      const startTime = performance.now();\r\n      \r\n      // Test with a small request to avoid affecting user experience\r\n      const response = await fetch('/api/ping', { \r\n        method: 'HEAD',\r\n        cache: 'no-cache' \r\n      });\r\n      \r\n      const endTime = performance.now();\r\n      const latency = endTime - startTime;\r\n      \r\n      if (!response.ok) {\r\n        return 'poor';\r\n      }\r\n      \r\n      if (latency < 100) {\r\n        return 'excellent';\r\n      } else if (latency < 300) {\r\n        return 'good';\r\n      } else {\r\n        return 'poor';\r\n      }\r\n    } catch (error) {\r\n      console.warn('Latency test failed:', error);\r\n      return 'poor';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get battery level for mobile devices\r\n   */\r\n  private async getBatteryLevel(): Promise<number | undefined> {\r\n    try {\r\n      // Modern Battery API\r\n      const battery = await (navigator as any).getBattery?.();\r\n      if (battery && typeof battery.level === 'number') {\r\n        return battery.level;\r\n      }\r\n      \r\n      // Fallback methods for older devices\r\n      const batteryManager = (navigator as any).battery || (navigator as any).mozBattery || (navigator as any).webkitBattery;\r\n      if (batteryManager && typeof batteryManager.level === 'number') {\r\n        return batteryManager.level;\r\n      }\r\n      \r\n      return undefined;\r\n    } catch (error) {\r\n      console.warn('Battery level detection failed:', error);\r\n      return undefined;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Detect ambient noise level using audio API\r\n   */\r\n  private async detectAmbientNoise(): Promise<'quiet' | 'moderate' | 'noisy' | undefined> {\r\n    try {\r\n      // Request microphone access for noise detection\r\n      const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });\r\n      \r\n      return new Promise<'quiet' | 'moderate' | 'noisy' | undefined>((resolve) => {\r\n        const audioContext = new (window.AudioContext || (window as any).webkitAudioContext)();\r\n        const analyser = audioContext.createAnalyser();\r\n        const microphone = audioContext.createMediaStreamSource(stream);\r\n        \r\n        microphone.connect(analyser);\r\n        analyser.fftSize = 256;\r\n        \r\n        const bufferLength = analyser.frequencyBinCount;\r\n        const dataArray = new Uint8Array(bufferLength);\r\n        \r\n        let samples = 0;\r\n        let totalVolume = 0;\r\n        const maxSamples = 30; // Sample for 1 second at ~30fps\r\n        \r\n        const checkVolume = () => {\r\n          analyser.getByteFrequencyData(dataArray);\r\n          \r\n          const volume = dataArray.reduce((sum, value) => sum + value, 0) / bufferLength;\r\n          totalVolume += volume;\r\n          samples++;\r\n          \r\n          if (samples < maxSamples) {\r\n            setTimeout(checkVolume, 33); // ~30fps sampling\r\n          } else {\r\n            // Clean up\r\n            stream.getTracks().forEach(track => track.stop());\r\n            audioContext.close();\r\n            \r\n            const averageVolume = totalVolume / samples;\r\n            \r\n            // Classify noise level\r\n            if (averageVolume < 20) {\r\n              resolve('quiet');\r\n            } else if (averageVolume < 60) {\r\n              resolve('moderate');\r\n            } else {\r\n              resolve('noisy');\r\n            }\r\n          }\r\n        };\r\n        \r\n        checkVolume();\r\n      });\r\n    } catch (error) {\r\n      // Microphone access denied or not available\r\n      console.warn('Ambient noise detection failed:', error);\r\n      return undefined;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Detect lighting conditions using camera or screen brightness\r\n   */\r\n  private async detectLightingConditions(): Promise<'optimal' | 'dim' | 'bright' | undefined> {\r\n    try {\r\n      // Method 1: Screen brightness detection (if supported)\r\n      if ('screen' in navigator && 'brightness' in (navigator.screen as any)) {\r\n        const brightness = (navigator.screen as any).brightness;\r\n        if (brightness < 0.3) return 'dim';\r\n        if (brightness > 0.8) return 'bright';\r\n        return 'optimal';\r\n      }\r\n      \r\n      // Method 2: Camera-based ambient light detection\r\n      return await this.detectLightingViaCamera();\r\n    } catch (error) {\r\n      console.warn('Lighting detection failed:', error);\r\n      return undefined;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Detect lighting via camera sensor\r\n   */\r\n  private async detectLightingViaCamera(): Promise<'optimal' | 'dim' | 'bright' | undefined> {\r\n    try {\r\n      const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } });\r\n      \r\n      return new Promise<'optimal' | 'dim' | 'bright' | undefined>((resolve) => {\r\n        const video = document.createElement('video');\r\n        const canvas = document.createElement('canvas');\r\n        const ctx = canvas.getContext('2d');\r\n        \r\n        video.srcObject = stream;\r\n        video.play();\r\n        \r\n        video.addEventListener('loadedmetadata', () => {\r\n          canvas.width = video.videoWidth;\r\n          canvas.height = video.videoHeight;\r\n          \r\n          // Capture a frame after a short delay\r\n          setTimeout(() => {\r\n            if (ctx) {\r\n              ctx.drawImage(video, 0, 0);\r\n              const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\r\n              \r\n              // Calculate average brightness\r\n              let totalBrightness = 0;\r\n              const pixels = imageData.data;\r\n              \r\n              for (let i = 0; i < pixels.length; i += 4) {\r\n                const r = pixels[i];\r\n                const g = pixels[i + 1];\r\n                const b = pixels[i + 2];\r\n                \r\n                // Calculate luminance\r\n                const luminance = 0.299 * r + 0.587 * g + 0.114 * b;\r\n                totalBrightness += luminance;\r\n              }\r\n              \r\n              const averageBrightness = totalBrightness / (pixels.length / 4);\r\n              \r\n              // Clean up\r\n              stream.getTracks().forEach(track => track.stop());\r\n              \r\n              // Classify lighting\r\n              if (averageBrightness < 50) {\r\n                resolve('dim');\r\n              } else if (averageBrightness > 200) {\r\n                resolve('bright');\r\n              } else {\r\n                resolve('optimal');\r\n              }\r\n            }\r\n          }, 500);\r\n        });\r\n      });\r\n    } catch (error) {\r\n      console.warn('Camera-based lighting detection failed:', error);\r\n      return undefined;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Analyze contextual insights from historical data\r\n   */\r\n  analyzeContextualInsights(performanceHistory: any[]): ContextualInsights {\r\n    // Group performance by environmental factors\r\n    const contextGroups = this.groupPerformanceByContext(performanceHistory);\r\n    \r\n    // Find optimal conditions\r\n    const optimalConditions = this.findOptimalConditions(contextGroups);\r\n    \r\n    // Score current conditions\r\n    const currentContext = this.contextHistory[this.contextHistory.length - 1];\r\n    const currentScore = this.scoreCurrentConditions(currentContext, optimalConditions);\r\n    \r\n    // Generate improvement suggestions\r\n    const suggestions = this.generateImprovementSuggestions(currentContext, optimalConditions);\r\n    \r\n    return {\r\n      optimalStudyConditions: optimalConditions,\r\n      currentConditionScore: currentScore,\r\n      improvementSuggestions: suggestions,\r\n      historicalPerformance: Array.from(contextGroups.values())\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get environmental adaptation recommendations\r\n   */\r\n  getEnvironmentalAdaptations(context: EnvironmentalContext): EnvironmentalAdaptation {\r\n    let difficultyAdjustment = 0;\r\n    let breakFrequency = 25; // Default pomodoro technique\r\n    \r\n    const visualOpts = {\r\n      contrastAdjustment: 0,\r\n      fontSizeAdjustment: 0,\r\n      colorScheme: 'auto' as const\r\n    };\r\n    \r\n    const audioOpts = {\r\n      enableSoundEffects: true,\r\n      volumeAdjustment: 0.7\r\n    };\r\n\r\n    // Device-based adaptations\r\n    switch (context.device) {\r\n      case 'mobile':\r\n        difficultyAdjustment -= 0.5; // Slightly easier on mobile\r\n        breakFrequency = 20; // More frequent breaks\r\n        visualOpts.fontSizeAdjustment = 0.2; // Larger text\r\n        break;\r\n        \r\n      case 'tablet':\r\n        breakFrequency = 30;\r\n        visualOpts.fontSizeAdjustment = 0.1;\r\n        break;\r\n        \r\n      case 'desktop':\r\n        breakFrequency = 45; // Longer sessions on desktop\r\n        break;\r\n    }\r\n\r\n    // Network quality adaptations\r\n    switch (context.networkQuality) {\r\n      case 'poor':\r\n      case 'offline':\r\n        difficultyAdjustment -= 1.0; // Significantly easier for poor connection\r\n        audioOpts.enableSoundEffects = false; // Disable to reduce data usage\r\n        break;\r\n        \r\n      case 'good':\r\n        difficultyAdjustment -= 0.2;\r\n        break;\r\n    }\r\n\r\n    // Battery level adaptations (mobile)\r\n    if (context.batteryLevel !== undefined && context.batteryLevel < 0.3) {\r\n      difficultyAdjustment -= 0.5; // Easier when battery is low\r\n      breakFrequency = 15; // More frequent breaks to reduce usage\r\n      visualOpts.colorScheme = 'dark'; // Dark mode saves battery\r\n    }\r\n\r\n    // Ambient noise adaptations\r\n    switch (context.ambientNoise) {\r\n      case 'noisy':\r\n        difficultyAdjustment -= 0.3; // Harder to concentrate in noise\r\n        audioOpts.enableSoundEffects = false; // Disable competing audio\r\n        break;\r\n        \r\n      case 'quiet':\r\n        audioOpts.volumeAdjustment = 0.5; // Lower volume in quiet environments\r\n        break;\r\n    }\r\n\r\n    // Lighting adaptations\r\n    switch (context.lighting) {\r\n      case 'dim':\r\n        visualOpts.contrastAdjustment = 0.3; // Higher contrast\r\n        visualOpts.colorScheme = 'dark'; // Better for dim environments\r\n        difficultyAdjustment -= 0.2; // Slightly easier in poor lighting\r\n        break;\r\n        \r\n      case 'bright':\r\n        visualOpts.contrastAdjustment = -0.2; // Lower contrast\r\n        visualOpts.colorScheme = 'light'; // Better for bright environments\r\n        break;\r\n        \r\n      case 'optimal':\r\n        // No adjustments needed\r\n        break;\r\n    }\r\n\r\n    return {\r\n      difficultyAdjustment: Math.max(-3, Math.min(3, difficultyAdjustment)),\r\n      recommendedBreakFrequency: breakFrequency,\r\n      visualOptimizations: visualOpts,\r\n      audioOptimizations: audioOpts\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Track context changes and notify of significant changes\r\n   */\r\n  async trackContextChanges(): Promise<void> {\r\n    const previousContext = this.contextHistory[this.contextHistory.length - 1];\r\n    const currentContext = await this.getCurrentContext();\r\n    \r\n    if (previousContext && this.hasSignificantContextChange(previousContext, currentContext)) {\r\n      // Emit context change event\r\n      this.onContextChange?.(currentContext, previousContext);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check for significant context changes\r\n   */\r\n  private hasSignificantContextChange(previous: DetectedContext, current: DetectedContext): boolean {\r\n    // Device change (rare but significant)\r\n    if (previous.device !== current.device) return true;\r\n    \r\n    // Network quality change\r\n    if (previous.networkQuality !== current.networkQuality) return true;\r\n    \r\n    // Battery level change > 20%\r\n    if (previous.batteryLevel && current.batteryLevel) {\r\n      if (Math.abs(previous.batteryLevel - current.batteryLevel) > 0.2) return true;\r\n    }\r\n    \r\n    // Ambient conditions change\r\n    if (previous.ambientNoise !== current.ambientNoise) return true;\r\n    if (previous.lighting !== current.lighting) return true;\r\n    \r\n    return false;\r\n  }\r\n\r\n  // Helper methods for contextual analysis\r\n\r\n  private groupPerformanceByContext(performanceHistory: any[]): Map<string, PerformanceByContext> {\r\n    const groups = new Map<string, PerformanceByContext>();\r\n    \r\n    // This would group performance data by environmental context\r\n    // Implementation would depend on your performance data structure\r\n    \r\n    return groups;\r\n  }\r\n\r\n  private findOptimalConditions(contextGroups: Map<string, PerformanceByContext>): EnvironmentalContext {\r\n    // Analyze performance groups to find optimal conditions\r\n    // This is a simplified version - real implementation would be more sophisticated\r\n    \r\n    return {\r\n      device: 'desktop', // Generally best performance\r\n      networkQuality: 'excellent',\r\n      batteryLevel: undefined, // Not applicable for optimal\r\n      ambientNoise: 'quiet',\r\n      lighting: 'optimal'\r\n    };\r\n  }\r\n\r\n  private scoreCurrentConditions(current: DetectedContext | undefined, optimal: EnvironmentalContext): number {\r\n    if (!current) return 0.5;\r\n    \r\n    let score = 1.0;\r\n    \r\n    // Score each factor\r\n    if (current.device !== optimal.device) score -= 0.1;\r\n    if (current.networkQuality !== optimal.networkQuality) {\r\n      score -= current.networkQuality === 'poor' ? 0.3 : 0.1;\r\n    }\r\n    if (current.ambientNoise !== optimal.ambientNoise) score -= 0.15;\r\n    if (current.lighting !== optimal.lighting) score -= 0.1;\r\n    \r\n    // Battery penalty for mobile\r\n    if (current.device === 'mobile' && current.batteryLevel && current.batteryLevel < 0.3) {\r\n      score -= 0.2;\r\n    }\r\n    \r\n    return Math.max(0, score);\r\n  }\r\n\r\n  private generateImprovementSuggestions(current: DetectedContext | undefined, optimal: EnvironmentalContext): string[] {\r\n    const suggestions: string[] = [];\r\n    \r\n    if (!current) return suggestions;\r\n    \r\n    if (current.networkQuality === 'poor') {\r\n      suggestions.push('Consider switching to a better network connection for optimal performance');\r\n    }\r\n    \r\n    if (current.ambientNoise === 'noisy') {\r\n      suggestions.push('Find a quieter environment or use noise-canceling headphones');\r\n    }\r\n    \r\n    if (current.lighting === 'dim') {\r\n      suggestions.push('Improve lighting conditions for better visual clarity');\r\n    } else if (current.lighting === 'bright') {\r\n      suggestions.push('Reduce screen glare or move to a less bright environment');\r\n    }\r\n    \r\n    if (current.device === 'mobile' && current.batteryLevel && current.batteryLevel < 0.3) {\r\n      suggestions.push('Charge your device or switch to a desktop for longer study sessions');\r\n    }\r\n    \r\n    return suggestions;\r\n  }\r\n\r\n  // Event handler for context changes (can be overridden)\r\n  public onContextChange?: (current: DetectedContext, previous: DetectedContext) => void;\r\n}","/**\r\n * StorageManager\r\n * - Client-side storage utilities for usage metrics and maintenance\r\n * - Works over Dexie tables (IndexedDB) and navigator.storage.estimate()\r\n *\r\n * Responsibilities:\r\n * - Compute storage usage (media table bytes/count + DB row counts)\r\n * - Purge unreferenced media (based on CardRow.mediaRefs)\r\n * - Purge all media (dangerous, UI must confirm)\r\n */\r\n\r\nimport db, { ensureDBOpen, type MediaRow, type CardRow } from '../../data/db';\r\n\r\nexport type BrowserStorageEstimate = {\r\n  quota?: number;         // Browser-estimated total quota (bytes)\r\n  usage?: number;         // Browser-estimated used bytes (bytes)\r\n  usageDetails?: Record<string, number>;\r\n};\r\n\r\nexport type StorageUsage = {\r\n  // Media\r\n  mediaBytes: number;\r\n  mediaCount: number;\r\n\r\n  // DB counts (best-effort, not bytes)\r\n  decksCount: number;\r\n  cardsCount: number;\r\n  reviewsCount: number;\r\n  achievementsCount: number;\r\n  challengesCount: number;\r\n\r\n  // Browser estimate (if available)\r\n  estimate?: BrowserStorageEstimate;\r\n  // Timestamp\r\n  measuredAt: number;\r\n};\r\n\r\nexport type PurgeReport = {\r\n  removedCount: number;\r\n  removedBytes: number;\r\n  keptCount: number;\r\n};\r\n\r\n/**\r\n * Helper: sums byteLength safely\r\n */\r\nfunction safeByteLength(m?: MediaRow | null): number {\r\n  if (!m) return 0;\r\n  if (typeof m.byteLength === 'number') return m.byteLength;\r\n  try {\r\n    return m.blob ? m.blob.size : 0;\r\n  } catch {\r\n    return 0;\r\n  }\r\n}\r\n\r\nexport class StorageManager {\r\n  /**\r\n   * Compute overall usage snapshot.\r\n   * - mediaBytes/mediaCount from media table\r\n   * - Row counts from other tables (for visibility)\r\n   * - navigator.storage.estimate() if available\r\n   */\r\n  async getUsage(): Promise<StorageUsage> {\r\n    await ensureDBOpen();\r\n\r\n    const [mediaRows, decksCount, cardsCount, reviewsCount, achievementsCount, challengesCount] =\r\n      await Promise.all([\r\n        db.media.toArray(),\r\n        db.decks.count(),\r\n        db.cards.count(),\r\n        db.reviews.count(),\r\n        db.achievements.count(),\r\n        db.challenges.count(),\r\n      ]);\r\n\r\n    const mediaBytes = mediaRows.reduce((sum, row) => sum + safeByteLength(row), 0);\r\n    const mediaCount = mediaRows.length;\r\n\r\n    let estimate: BrowserStorageEstimate | undefined;\r\n    try {\r\n      if (navigator?.storage?.estimate) {\r\n        const est = await navigator.storage.estimate();\r\n        const details = (est as any).usageDetails as Record<string, number> | undefined;\r\n        const browserEstimate: BrowserStorageEstimate = {\r\n          quota: est.quota,\r\n          usage: est.usage,\r\n          ...(details ? { usageDetails: Object.fromEntries(Object.entries(details)) } : {}),\r\n        };\r\n        estimate = browserEstimate;\r\n      }\r\n    } catch {\r\n      // ignore if not supported\r\n    }\r\n\r\n    return {\r\n      mediaBytes,\r\n      mediaCount,\r\n      decksCount,\r\n      cardsCount,\r\n      reviewsCount,\r\n      achievementsCount,\r\n      challengesCount,\r\n      estimate,\r\n      measuredAt: Date.now(),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Purge any media rows that are not referenced by any card's mediaRefs.\r\n   * Returns a summary report with removed/kept counts and bytes freed.\r\n   */\r\n  async purgeUnusedMedia(): Promise<PurgeReport> {\r\n    await ensureDBOpen();\r\n\r\n    const [cards, mediaRows] = await Promise.all([db.cards.toArray(), db.media.toArray()]);\r\n\r\n    const referenced = this.collectReferencedMedia(cards);\r\n    let removedCount = 0;\r\n    let removedBytes = 0;\r\n\r\n    // Iterate and remove unreferenced\r\n    for (const m of mediaRows) {\r\n      if (!referenced.has(m.mediaHash)) {\r\n        removedBytes += safeByteLength(m);\r\n        await db.media.delete(m.mediaHash);\r\n        removedCount++;\r\n      }\r\n    }\r\n\r\n    return {\r\n      removedCount,\r\n      removedBytes,\r\n      keptCount: mediaRows.length - removedCount,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Purge all media rows. Dangerous: callers must confirm with user.\r\n   * Returns removed count/bytes.\r\n   */\r\n  async purgeAllMedia(): Promise<PurgeReport> {\r\n    await ensureDBOpen();\r\n\r\n    const mediaRows = await db.media.toArray();\r\n    const removedBytes = mediaRows.reduce((sum, row) => sum + safeByteLength(row), 0);\r\n    const removedCount = mediaRows.length;\r\n\r\n    await db.media.clear();\r\n\r\n    return {\r\n      removedCount,\r\n      removedBytes,\r\n      keptCount: 0,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Collect referenced media hashes from CardRow.mediaRefs (string[])\r\n   */\r\n  private collectReferencedMedia(cards: CardRow[]): Set<string> {\r\n    const set = new Set<string>();\r\n    for (const c of cards) {\r\n      if (Array.isArray(c.mediaRefs)) {\r\n        for (const ref of c.mediaRefs) {\r\n          if (typeof ref === 'string' && ref.length > 0) set.add(ref);\r\n        }\r\n      }\r\n    }\r\n    return set;\r\n  }\r\n}\r\n\r\n// Singleton export\r\nexport const storageManager = new StorageManager();\r\nexport default StorageManager;","/**\r\n * Sync Queue Flusher\r\n * - Flushes IndexedDB-backed sync operations when connectivity is available\r\n * - Focus: leaderboard:submit (optional server)\r\n * - Used as a safety net when Background Sync is unavailable or not configured\r\n */\r\n\r\nimport { repos } from '../data';\r\n\r\ntype LeaderboardScope = 'global' | 'friends' | 'weekly' | 'monthly';\r\n\r\ninterface LeaderboardSubmitPayload {\r\n  scope: LeaderboardScope;\r\n  score: number;\r\n  user: { id: string; username: string; token?: string };\r\n  queuedAt: number;\r\n  requestId?: string;\r\n}\r\n\r\nfunction supportsBackgroundSync(): boolean {\r\n  try {\r\n    return typeof window !== 'undefined' && 'serviceWorker' in navigator && 'SyncManager' in window;\r\n  } catch {\r\n    return false;\r\n  }\r\n}\r\n\r\nasync function flushLeaderboardSubmit(row: any): Promise<boolean> {\r\n  const payload = row?.payload as LeaderboardSubmitPayload | undefined;\r\n  if (!payload || !payload.user || !payload.user.id) {\r\n    // Malformed row; drop it to avoid infinite retries\r\n    await repos.syncQueue.remove(row.queueId);\r\n    return true;\r\n  }\r\n\r\n  // Use an idempotency key to prevent double submissions if Workbox also replays\r\n  const requestId =\r\n    payload.requestId ??\r\n    `lb_${payload.user.id}_${payload.scope}_${payload.score}_${payload.queuedAt}`;\r\n\r\n  try {\r\n    const res = await fetch('/api/leaderboard/submit', {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n        ...(payload.user.token ? { Authorization: `Bearer ${payload.user.token}` } : {}),\r\n        'X-Idempotency-Key': requestId,\r\n      },\r\n      body: JSON.stringify({\r\n        scope: payload.scope,\r\n        score: payload.score,\r\n        userId: payload.user.id,\r\n        username: payload.user.username,\r\n        requestId,\r\n      }),\r\n    });\r\n\r\n    if (!res.ok) {\r\n      throw new Error(`HTTP ${res.status}`);\r\n    }\r\n\r\n    await repos.syncQueue.remove(row.queueId);\r\n    return true;\r\n  } catch (err: any) {\r\n    // Record attempt and keep for a later retry\r\n    await repos.syncQueue.markAttempt(row.queueId, String(err?.message ?? err));\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Flush a batch of queued operations.\r\n * Returns the number of successfully flushed items.\r\n */\r\nexport async function flushSyncQueueOnce(limit = 50): Promise<number> {\r\n  const rows = await repos.syncQueue.list(limit);\r\n  let ok = 0;\r\n\r\n  for (const row of rows) {\r\n    try {\r\n      // Limit retries to prevent unbounded growth (drop after 8 attempts)\r\n      if ((row.attemptCount ?? 0) > 8) {\r\n        await repos.syncQueue.remove(row.queueId);\r\n        continue;\r\n      }\r\n\r\n      switch (row.opType) {\r\n        case 'leaderboard:submit':\r\n          if (await flushLeaderboardSubmit(row)) ok++;\r\n          break;\r\n\r\n        default:\r\n          // Unknown opType: drop to avoid stuck queue\r\n          await repos.syncQueue.remove(row.queueId);\r\n          break;\r\n      }\r\n    } catch (err: any) {\r\n      await repos.syncQueue.markAttempt(row.queueId, String(err?.message ?? err));\r\n    }\r\n  }\r\n\r\n  return ok;\r\n}\r\n\r\n/**\r\n * Initialize queue flushing:\r\n * - Flush on app start (if online)\r\n * - Flush on 'online' event\r\n * - Optional periodic flush every few minutes\r\n */\r\nexport function initSyncQueueFlusher(options?: { intervalMs?: number }) {\r\n  if (typeof window === 'undefined') return;\r\n\r\n  const doFlush = async () => {\r\n    // If Background Sync is available, prefer it and skip client flusher to avoid duplication\r\n    if (supportsBackgroundSync()) return;\r\n\r\n    if (navigator.onLine) {\r\n      try {\r\n        await flushSyncQueueOnce(100);\r\n      } catch {\r\n        // ignore\r\n      }\r\n    }\r\n  };\r\n\r\n  // Initial attempt\r\n  void doFlush();\r\n\r\n  // When connection is restored\r\n  window.addEventListener('online', () => {\r\n    void doFlush();\r\n  });\r\n\r\n  // Periodic flush as a safety net (default 2 minutes)\r\n  const intervalMs = options?.intervalMs ?? 2 * 60 * 1000;\r\n  const timer = window.setInterval(() => {\r\n    void doFlush();\r\n  }, intervalMs);\r\n\r\n  // Expose a cleanup for tests if needed\r\n  (window as any).__syncQueueFlusherCleanup = () => clearInterval(timer);\r\n}\r\n\r\n// For manual triggering (tests or UI)\r\nexport async function flushSyncQueueNow() {\r\n  return flushSyncQueueOnce(100);\r\n}"],"names":["ErrorTrackingService","config","errors","sessionId","initialized","constructor","this","maxStoredErrors","enableConsoleLogging","enableLocalStorage","environment","generateSessionId","loadStoredErrors","setupGlobalErrorHandlers","logInfo","logError","error","context","errorReport","createErrorReport","recordError","logWarning","message","getErrors","clearErrors","localStorage","removeItem","getErrorStats","oneHourAgo","Date","now","stats","total","length","byLevel","warning","info","recent","forEach","level","timestamp","getTime","exportErrors","JSON","stringify","Error","stack","id","generateErrorId","toISOString","userAgent","navigator","url","window","location","href","unshift","slice","console","warn","log","setItem","e","apiEndpoint","sendToRemote","catch","stored","getItem","parsedErrors","parse","Array","isArray","addEventListener","event","filename","lineno","colno","type","reason","React","originalErrorHandler","args","includes","apply","fetch","method","headers","apiKey","Authorization","body","Math","random","toString","substr","errorTracker","Component","hasSubtleCrypto","crypto","subtle","digest","toBase64Url","bytes","str","i","String","fromCharCode","btoa","Buffer","from","replace","async","deriveAnonymizedId","deviceUserId","createdAt","input","TextEncoder","encode","Uint8Array","uuidv4","randomUUID","c","r","createLocalProfileInternal","displayName","avatarUrl","ensureDBOpen","anonymizedId","row","updatedAt","db","users","add","getLocalProfile","any","toCollection","first","ensureLocalProfile","existing","updateLocalProfile","patch","updated","put","toLinkKey","provider","linkAccount","repos","userOnlineLinks","upsert","serverUserId","accessToken","refreshToken","scopes","meta","lastLinkedAt","unlinkAccount","linkKey","remove","getLink","get","isLinked","bytesToHex","view","hex","padStart","hashArrayBufferSHA256","buffer","anyCrypto","globalThis","hashBlobSHA256","blob","anyBlob","arrayBuffer","Response","MediaStorageService","storeBlob","mimeType","options","mediaHash","media","has","size","scope","opfsPointer","useOPFS","storage","getDirectory","root","mediaDir","getDirectoryHandle","create","fileHandle","getFileHandle","writable","createWritable","write","close","path","byteLength","validationMeta","securityFlags","err","createObjectUrl","URL","createObjectURL","dirName","fileName","split","file","getFile","revokeObjectUrl","revokeObjectURL","mediaStorage","DEMO_USER_STATS","totalXP","currentLevelXP","nextLevelXP","cardsStudied","studyTime","accuracy","currentStreak","longestStreak","coins","gems","lastStudyDate","joinDate","DEMO_ACHIEVEMENTS","name","description","icon","unlockedAt","category","ENHANCED_MONTHLY_CHALLENGES","target","current","reward","xp","expiresAt","DEMO_CHALLENGES","DEMO_LEADERBOARD","global","userId","username","score","rank","change","friends","weekly","monthly","UserDataService","baseUrl","isDemoUser","user","tokenType","email","getUserStats","debugLogger","response","token","ok","data","json","apiError","generatePersonalizedMockStats","getUserActivity","days","generateDemoActivity","generatePersonalizedActivity","getUserAchievements","generatePersonalizedAchievements","getUserChallenges","generatePersonalizedChallenges","getLeaderboardData","generatePersonalizedLeaderboard","getPerformanceMetrics","generateDemoPerformanceMetrics","generatePersonalizedPerformanceMetrics","getCompleteUserProfile","activity","achievements","challenges","performance","Promise","all","resetAllUserData","userHash","hashString","daysSinceJoin","floor","activities","date","dayHash","toDateString","push","xpGained","reverse","baseAchievements","challenge","progressHash","userScore","userRank","leaderboard","weeklyProgress","goal","monthlyProgress","decksCompleted","studyPattern","preferredTime","averageSessionLength","studyFrequency","hash","charCodeAt","abs","userDataService","exportAll","settingsRow","decks","cards","reviews","mediaRows","leaderboardCache","mediaAnalytics","settings","toArray","mediaNoBlob","map","rest","bundle","version","exportedAt","tables","counts","exportToBlob","Blob","downloadExport","a","document","createElement","download","defaultExportFilename","appendChild","click","removeChild","d","pad","n","getFullYear","getMonth","getDate","getHours","getMinutes","getSeconds","importAll","includeEphemeral","overwriteSettings","t","transaction","syncQueue","bulkPut","importFromFile","text","toScopeKey","DEFAULT_TTL_MS","toCacheEntries","entries","fromCacheEntries","cacheWrite","ttlMs","set","cacheRead","ignoreTTL","tryRemoteFetchAll","tryRemoteSubmit","requestId","status","enqueueSubmit","enqueue","opType","payload","queuedAt","supportsBackgroundSync","LocalCachedLeaderboardProvider","fetchAll","then","v","fetchScope","submit","_instance","getLeaderboardService","RealTimeDataService","updateInterval","subscribers","Map","intervalId","activeInstances","subscribe","dataType","callback","callbacks","index","indexOf","splice","notify","getGlobalLearningStats","fetchFromMultipleSources","fetchFromDuolingoAPI","fetchFromKhanAcademyAPI","fetchFromCourseraAPI","fetchFromEducationalDataAPI","generateEnhancedGlobalStats","getEducationalTrends","trends","fetchEducationalTrendsFromAPIs","generateEnhancedEducationalTrends","getLiveUserMetrics","metrics","fetchLiveMetricsFromAPIs","generateEnhancedLiveMetrics","getMarketInsights","insights","fetchMarketInsightsFromAPIs","generateEnhancedMarketInsights","Accept","fetchers","successfulResults","allSettled","fetcher","filter","result","value","mergeDataSources","sources","hour","dayOfWeek","getDay","timeMultiplier","getTimeBasedMultiplier","baseLearners","baseCardsToday","baseActiveSessions","totalLearners","cardsStudiedToday","activeStudySessions","languagesBeingLearned","topSubjects","learners","studyTimeToday","lastUpdated","popularSubjects","subject","growth","learningMethods","effectiveness","usage","studyPatterns","peakHours","generatePeakHours","weeklyTrends","generateWeeklyTrends","onlineUsers","studyingSessions","completedToday","averageAccuracy","topPerformers","country","skillDemand","skill","demand","industryTrends","industry","skills","certificationValue","cert","popularity","hourMultiplier","baseSessions","day","sessions","startRealTimeUpdates","setInterval","globalStats","liveMetrics","marketInsights","stopRealTimeUpdates","max","clearInterval","forceStopRealTimeUpdates","clear","realTimeDataService","apiClient","axios","baseURL","withCredentials","uamsApiService","deckId","post","sessionState","cardId","UnifiedQueueManager","lookaheadBufferSize","emergencyBufferSize","challengeReserveSize","refreshThreshold","maxSessionDurationMinutes","adaptiveRefreshInterval","initializeSession","getNextCard","processCardResponse","EnvironmentalContextService","contextHistory","performanceCache","getCurrentContext","device","detectDevice","networkQuality","assessNetworkQuality","confidence","batteryLevel","getBatteryLevel","ambientNoise","detectAmbientNoise","lighting","detectLightingConditions","detectedContext","detectionMethod","shift","toLowerCase","platform","isMobile","some","keyword","isTablet","screenWidth","screen","width","screenHeight","height","maxDimension","minDimension","min","hasTouchScreen","maxTouchPoints","onLine","connection","mozConnection","webkitConnection","effectiveType","downlink","rtt","performLatencyTest","startTime","cache","latency","battery","getBattery","batteryManager","mozBattery","webkitBattery","stream","mediaDevices","getUserMedia","audio","video","resolve","audioContext","AudioContext","webkitAudioContext","analyser","createAnalyser","createMediaStreamSource","connect","fftSize","bufferLength","frequencyBinCount","dataArray","samples","totalVolume","maxSamples","checkVolume","getByteFrequencyData","volume","reduce","sum","setTimeout","getTracks","track","stop","averageVolume","brightness","detectLightingViaCamera","facingMode","canvas","ctx","getContext","srcObject","play","videoWidth","videoHeight","drawImage","totalBrightness","pixels","getImageData","averageBrightness","analyzeContextualInsights","performanceHistory","contextGroups","groupPerformanceByContext","optimalConditions","findOptimalConditions","currentContext","optimalStudyConditions","currentConditionScore","scoreCurrentConditions","improvementSuggestions","generateImprovementSuggestions","historicalPerformance","values","getEnvironmentalAdaptations","difficultyAdjustment","breakFrequency","visualOpts","contrastAdjustment","fontSizeAdjustment","colorScheme","audioOpts","enableSoundEffects","volumeAdjustment","recommendedBreakFrequency","visualOptimizations","audioOptimizations","trackContextChanges","previousContext","hasSignificantContextChange","onContextChange","previous","optimal","suggestions","safeByteLength","m","StorageManager","getUsage","decksCount","cardsCount","reviewsCount","achievementsCount","challengesCount","count","mediaBytes","mediaCount","estimate","est","details","usageDetails","quota","Object","fromEntries","measuredAt","purgeUnusedMedia","referenced","collectReferencedMedia","removedCount","removedBytes","delete","keptCount","purgeAllMedia","Set","mediaRefs","ref","storageManager","flushLeaderboardSubmit","queueId","res","markAttempt","flushSyncQueueOnce","limit","rows","list","attemptCount","initSyncQueueFlusher","doFlush","intervalMs","timer","__syncQueueFlusherCleanup"],"mappings":"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"}