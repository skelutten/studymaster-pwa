{"version":3,"mappings":";y2CAKO,SAASA,cACdC,EACAC,EACAC,EAAqB,CAAEC,KAAM,SAC7BC,EAA8B,IAE9B,MAAO,CACLJ,eACAC,cACAC,WACAE,YAGAC,MAAO,MACPC,MAAO,EACPC,IAAK,EACLC,IAAK,EACLC,OAAQ,KACRC,KAAM,EACNC,OAAQ,EACRC,KAAM,EAGNC,aAAc,EACdC,mBAAoB,EACpBC,aAAc,EAGdC,eAAgB,EAChBC,kBAAmB,EAGnBC,MAAO,EACPC,YAAa,EACbC,aAAc,GAGdC,UAAW,EACXC,iBAAkB,EAEtB,CCrCA,SAASC,OACP,IACE,MAAMC,EAAaC,WAAmBC,OACtC,GAAIF,GAA6C,mBAAzBA,EAAUG,WAChC,OAAOH,EAAUG,YAErB,OAAS,CAET,MAAO,MAAQC,KAAKC,SAASC,SAAS,IAAIC,MAAM,EAAG,GACrD,CAKO,SAASC,uBAAuBC,GACrC,MAAO,CACLC,OAAQX,OACRY,KAAMF,EAAKG,MACXC,YAAaJ,EAAKI,YAClBC,KAAM,CACJC,OAAQN,EAAKM,OACbC,KAAMP,EAAKO,MAAQ,GACnBC,SAAUR,EAAKQ,UAAY,KAC3BC,SAAUT,EAAKS,UAAY,KAC3BC,iBAAkBV,EAAKU,kBAAoB,KAC3CC,SAAUX,EAAKW,WAAY,GAGjC,CAMO,SAASC,uBAAuBC,GAUrC,MACMC,MADcC,IAAI,CAAC,MAAO,WAAY,SAAU,eAE5CC,IAAIH,EAAMzC,OACbyC,EAAMzC,MACP,MAEN,MAAO,CACL6C,OAAQ3B,OACRW,OAAQY,EAAMZ,OACdiB,OAAQ,CACNC,MAAON,EAAM9C,aACbqD,KAAMP,EAAM7C,aAGdG,WAAY0C,EAAM1C,WAAa,IAAIkD,IAAKC,GAAMA,EAAEC,IAAIC,OAAOC,SAC3DrD,MAAO0C,EACPY,KAAMb,EAAMc,YAAc,IAC1BC,SAAUf,EAAMgB,cAAgB,EAChCC,MAAO,KACPpD,OAAQ,EAEZ,CAKO,SAASqD,qBAAqBC,GACnC,MAAMC,EAAqB,GACE,iBAAlBD,EAAQ7B,QAAoB8B,EAAO/B,KAAO8B,EAAQ7B,OAC1B,iBAAxB6B,EAAQ5B,cAA0B6B,EAAO7B,YAAc4B,EAAQ5B,aAC1E,MAAMC,EAAgC,GAMtC,OALI2B,EAAQzB,OAAMF,EAAKE,KAAOyB,EAAQzB,MAClCyB,EAAQxB,WAAUH,EAAKG,SAAWwB,EAAQxB,UAC1CwB,EAAQvB,WAAUJ,EAAKI,SAAWuB,EAAQvB,UAC1CuB,EAAQtB,mBAAkBL,EAAKK,iBAAmBsB,EAAQtB,kBAC1DwB,OAAOC,KAAK9B,GAAM+B,WAAe/B,KAAOA,GACrC4B,CACT,CCdA,MAAMI,EAAoC,CACxCC,eAAgB,GAChBC,iBAAkB,IAClBC,UAAW,IACXC,iBAAkB,EAClBC,gBAAiB,MACjBC,gBAAiB,GAInBC,eAAeC,kBAAkBC,GAC/B,UACQC,EAAMC,MAAMC,OAAOlD,uBAAuB+C,GAClD,OAASI,GAEPC,QAAQC,KAAK,qCAAsCF,EACrD,CACF,CAEAN,eAAeS,eAAepD,EAAgBqD,GAC5C,UACQP,EAAMQ,MAAMN,OAChBrC,uBAAuB,CACrBX,SACAlC,aAAcuF,EAAKvF,aACnBC,YAAasF,EAAKtF,YAClBG,UAAWmF,EAAKnF,UAChBC,MAAOkF,EAAKlF,MACZuD,WAAY2B,EAAK3B,WACjBE,aAAcyB,EAAKzB,eAGzB,OAASqB,GACPC,QAAQC,KAAK,kCAAmCF,EAClD,CACF,CAGA,MAAMM,kBAAqBC,GAClBA,EACJC,QAAQ,UAAW,KACnBA,QAAQ,QAAS,KACjBA,QAAQ,QAAS,KACjBA,QAAQ,SAAU,KAClBC,OAICC,iBAAoBH,GACjBA,EACJC,QAAQ,WAAY,IACpBA,QAAQ,oBAAqB,IAC7BA,QAAQ,UAAW,KACnBA,QAAQ,QAAS,KACjBA,QAAQ,QAAS,KACjBA,QAAQ,SAAU,KAClBC,OAICE,2BAA8BC,IAClC,GAA4B,IAAxBA,EAAa1B,OACf,MAAO,CAAE2B,WAAY,EAAGC,UAAW,GAGrC,MAAMC,EAAaH,EAAa,GAAG1B,OAC7B8B,EAAgF,GAGtF,QAAS/C,EAAQ,EAAGA,EAAQ8C,EAAY9C,IACtC,QAASC,EAAOD,EAAQ,EAAGC,EAAO6C,EAAY7C,IAAQ,CACpD,IAAI+C,EAAQ,EACRC,EAAa,EAEjB,UAAWlD,KAAU4C,EAAc,CACjC,MAAM/F,EAAe6F,iBAAiB1C,EAAOC,IAAU,IACjDnD,EAAc4F,iBAAiB1C,EAAOE,IAAS,IAGjDrD,GAAgBC,IAClBoG,IAGIrG,EAAaqE,OAAS,GAAKpE,EAAYoE,OAAS,IAClD+B,GAAS,IAIPpG,IAAiBC,IACnBmG,GAAS,GAINpG,EAAasG,MAAM,cAAiBrG,EAAYqG,MAAM,eACzDF,GAAS,GAGNpG,EAAasG,MAAM,UAAarG,EAAYqG,MAAM,WACrDF,GAAS,GAGf,CAGA,MAAMG,EAAkBF,EAAa,EAAID,EAAQC,EAAa,EAC9DF,EAAaK,KAAK,CAAER,WAAY5C,EAAO6C,UAAW5C,EAAM+C,MAAOG,GACjE,CAMF,OAFAJ,EAAaM,KAAK,CAACC,EAAGC,IAAMA,EAAEP,MAAQM,EAAEN,OAEpCD,EAAa9B,OAAS,GAAK8B,EAAa,GAAGC,MAAQ,GACrDhB,QAAQwB,IAAI,2BAA2BT,EAAa,GAAGH,iBAAiBG,EAAa,GAAGF,qBAAqBE,EAAa,GAAGC,UACtH,CAAEJ,WAAYG,EAAa,GAAGH,WAAYC,UAAWE,EAAa,GAAGF,YAI1EC,GAAc,EACT,CAAEF,WAAY,EAAGC,UAAW,GAE9B,CAAED,WAAY,EAAGC,UAAW,IAU/BY,wBAA2BC,IAEW,CACxCC,IAAO,aACPC,KAAQ,aACRC,IAAO,YACPC,IAAO,YACPC,IAAO,gBACPC,IAAO,aACPC,IAAO,YACPC,IAAO,YACPC,IAAO,YACPC,KAAQ,cAXEV,EAASW,cAAcC,MAAM,KAAKC,OAAS,KAa9B,4BAGrBC,cAAgB/C,MAAOgD,IAK3B,IAEE,OAASC,QAASC,IAAWD,QAASE,UAAqBC,QAAQC,IAAI,CAAAC,EAAA,IACrEC,OAAO,4BAAOC,KAAAC,KAAAC,GAAAC,4BAAAL,EAAA,IACdC,OAAO,4BAAQC,KAAAC,KAAAG,GAAAD,8BAIXE,QAAYV,EAAU,CAC1BW,WAAad,GACPA,EAAKe,SAAS,SACT,iBAEF,IAAIf,MAKTgB,QAAoBhB,EAAKgB,cAGzBC,EAAM,IAAIf,EACVgB,QAAmBD,EAAIE,UAAUH,GAGjCI,EAASF,EAAWlB,KAAK,oBAC/B,IAAKoB,EACH,MAAM,IAAIC,MAAM,kDAIlB,MAAMC,QAAsBF,EAAOpE,MAAM,eACnCuE,EAAK,IAAIV,EAAIW,SAAS,IAAIC,WAAWH,IAGrCI,EAAYH,EAAGI,KAAK,iCAC1B,IAAIC,EAAW5B,EAAK1F,KAAKwD,QAAQ,UAAW,IAC5C,GAAI4D,EAAUlF,OAAS,GAAKkF,EAAU,GAAGG,OAAOrF,OAAS,EACvD,IACE,MAAMsF,EAAYJ,EAAU,GAAGG,OAAO,GAAG,GACnCzE,EAAQ2E,KAAKC,MAAMF,GAEnBG,EAAU3F,OAAOC,KAAKa,GAAOxB,OAAOD,GAAa,MAAPA,GAC5CsG,EAAQzF,OAAS,IACnBoF,EAAWxE,EAAM6E,EAAQ,IAAI3H,MAAQsH,EAEzC,OAASM,GACP3E,QAAQC,KAAK,6DACf,CAIF,MAAM2E,EAAaZ,EAAGI,KAAK,qJAQrBhE,EAAgD,GAEtD,GAAIwE,EAAW3F,OAAS,EAAG,CAEzB,MAAM4F,EAAarI,KAAKsI,IAAI,GAAIF,EAAW,GAAGN,OAAOrF,QAC/C0B,EAA2B,GAEjC,QAASoE,EAAI,EAAGA,EAAIF,EAAYE,IAAK,CACnC,MAAMhH,EAAU6G,EAAW,GAAGN,OAAOS,GAAG,GAAczC,MAAM,KAC5D3B,EAAaS,KAAKrD,EACpB,CAGA,MAAM6C,WAAEA,EAAAC,UAAYA,GAAcH,2BAA2BC,GAC7DX,QAAQwB,IAAI,4BAA4BZ,gBAAyBC,YAGjE,UAAWmE,KAAOJ,EAAW,GAAGN,OAAQ,CACtC,MAAMvG,EAAUiH,EAAI,GAAc1C,MAAM,KAExC,GAAIvE,EAAOkB,OAASzC,KAAKyI,IAAIrE,EAAYC,GAAY,CACnD,MAAM7C,EAAQqC,kBAAkBtC,EAAO6C,IAAe,IAChD3C,EAAOoC,kBAAkBtC,EAAO8C,IAAc,IAEhD7C,GAASC,GAAQD,IAAUC,GAC7BmC,EAAMgB,KAAK,CAAEpD,QAAOC,QAExB,CACF,CACF,CAIA,GAFA+F,EAAGkB,QAEkB,IAAjB9E,EAAMnB,OACR,MAAM,IAAI6E,MAAM,0CAKlB,MAAMqB,EAA0B,GAG1BC,EAAezB,EAAWlB,KAAK,SACrC,IAAI4C,EAAmC,GAEvC,GAAID,EACF,IACE,MAAME,QAAqBF,EAAa3F,MAAM,QAC9C4F,EAAWb,KAAKC,MAAMa,GACtBtF,QAAQwB,IAAI,4BAA4BzC,OAAOC,KAAKqG,GAAUpG,iBAChE,OAASc,GACPC,QAAQC,KAAK,iCAAkCF,EACjD,CAIF,UAAY2B,EAAU6D,KAAaxG,OAAOyG,QAAQ7B,EAAW8B,OAAQ,CAEnE,GAAIF,EAASG,KAAoB,qBAAbhE,GAAgD,UAAbA,EACrD,SAIF,MAAMiE,EAAiB,QAAQC,KAAKlE,GAC9BmE,EAAc,kDAAkDD,KAAKlE,GAE3E,GAAIiE,GAAkBE,EACpB,IACE,MAAMC,QAAaP,EAAS9F,MAAM,QAG5BsG,EAAmBV,EAAS3D,IAAaA,EAE/CyD,EAAW/D,KAAK,CACdM,SAAUqE,EACVC,KAAMF,IAGR9F,QAAQwB,IAAI,oBAAoBE,QAAeqE,MAAqBD,EAAKG,cAC3E,OAASlG,GACPC,QAAQC,KAAK,iCAAiCyB,IAAY3B,EAC5D,CAEJ,CAGA,OADAC,QAAQwB,IAAI,uBAAuBpB,EAAMnB,oBAAoBkG,EAAWlG,iCACjE,CAAElC,KAAMsH,EAAUjE,QAAO+E,aAClC,OAASe,GAEP,MADAlG,QAAQkG,MAAM,4BAA6BA,GACrC,IAAIpC,MAAM,+BAA+BoC,aAAiBpC,MAAQoC,EAAMC,QAAU,kBAC1F,GAGWC,EAAetG,IAC1BuG,EACE,CAACC,EAAKC,KAAA,CACJ1G,MAAO,GACPO,MAAO,GACPoG,oBAAqB,KACrBC,WAAW,EACXP,MAAO,KACPQ,eAAgB,EAChBC,aAAc,KACdC,UAAU,EACVC,cAAe,KAEfC,WAAYrH,MAAOE,IACjB2G,EAAI,CAAEG,WAAW,EAAMP,MAAO,OAC9B,IACE,MAAMa,KAAEA,GAASC,EAAaC,WACxB9J,EAAS4J,GAAM3I,IAAM,aAErBvB,EAAa,IACd8C,EACHxC,SACAiB,GAAI9B,OAAOC,aACX2K,WAAA,IAAeC,MAAOC,cACtBC,WAAA,IAAeF,MAAOC,cACtB9J,SAAU,IAAK4B,KAAwBS,EAASrC,WAYlD,OATAgJ,EAAIrL,IAAA,CACF4E,MAAO,IAAI5E,EAAM4E,MAAOhD,GACxBuD,MAAO,IAAKnF,EAAMmF,MAAO,CAACvD,EAAKuB,IAAK,IACpCqI,WAAW,KAIR/G,kBAAkBC,GAEhB9C,CACT,OAASqJ,GAEP,MADAI,EAAI,CAAEJ,MAAO,wBAAyBO,WAAW,IAC3CP,CACR,GAGFoB,WAAY7H,MAAOrB,EAAIS,KACrByH,EAAI,CAAEG,WAAW,EAAMP,MAAO,OAC9B,IACEI,EAAIrL,IAAA,CACF4E,MAAO5E,EAAM4E,MAAM3B,IAAIrB,GACrBA,EAAKuB,KAAOA,EACR,IAAKvB,KAASgC,EAASwI,eAAeF,MAAOC,eAC7CvK,GAEN4J,WAAW,KAIb,IACO7G,EAAMC,MAAM0H,OAAOnJ,EAAIQ,qBAAqBC,GACnD,OAAS8F,GACP3E,QAAQC,KAAK,qCAAsC0E,EACrD,CACF,OAASuB,GAEP,MADAI,EAAI,CAAEJ,MAAO,wBAAyBO,WAAW,IAC3CP,CACR,GAGFsB,WAAY/H,MAAOrB,IACjBkI,EAAI,CAAEG,WAAW,EAAMP,MAAO,OAC9B,IACEI,EAAIrL,IAEF,MAAQmD,CAACA,GAAKqJ,KAAkBC,GAAmBzM,EAAMmF,MACzD,MAAO,CACLP,MAAO5E,EAAM4E,MAAMxB,OAAOxB,GAAQA,EAAKuB,KAAOA,GAC9CgC,MAAOsH,EACPjB,WAAW,KAIf,IACO7G,EAAMC,MAAM8H,OAAOvJ,EAC1B,OAASuG,GACP3E,QAAQC,KAAK,qCAAsC0E,EACrD,CACF,OAASuB,GAEP,MADAI,EAAI,CAAEJ,MAAO,wBAAyBO,WAAW,IAC3CP,CACR,GAGF0B,QAAUxJ,GACDmI,IAAM1G,MAAMgI,KAAKhL,GAAQA,EAAKuB,KAAOA,GAG9C0J,QAASrI,MAAO3C,EAAQiL,KACtBzB,EAAI,CAAEG,WAAW,EAAMP,MAAO,OAC9B,IACE,MAAM/F,EAAa,IACd4H,EACH3J,GAAI9B,OAAOC,aACXO,SACAoK,WAAA,IAAeC,MAAOC,cACtB5I,WAAY,IACZE,aAAc,EACdsJ,YAAA,IAAgBb,MAAOC,cACvBa,YAAa,EACbC,WAAY,GAqBd,OAlBA5B,EAAIrL,IACF,MACMkN,EAAe,IADHlN,EAAMmF,MAAMtD,IAAW,GACLqD,GAEpC,MAAO,CACLC,MAAO,IAAKnF,EAAMmF,MAAOtD,CAACA,GAASqL,GACnCtI,MAAO5E,EAAM4E,MAAM3B,OACjBrB,EAAKuB,KAAOtB,EACR,IAAKD,EAAMuL,UAAWD,EAAalJ,OAAQoI,eAAeF,MAAOC,eACjEvK,GAEN4J,WAAW,KAKVvG,eAAepD,EAAQqD,GAErBA,CACT,OAAS+F,GAEP,MADAI,EAAI,CAAEJ,MAAO,qBAAsBO,WAAW,IACxCP,CACR,GAGFmC,YAAa5I,MAAO3C,EAAQiL,KAC1B,IACE,MACMO,EADQ/B,IACcnG,MAAMtD,IAAW,GAGvCyL,EAAU,GAAGR,EAASnN,aAAa4F,OAAO6B,iBAAiB0F,EAASlN,YAAY2F,OAAO6B,gBAK7F,GAJoBiG,EAAcE,KAAKrI,GACrC,GAAGA,EAAKvF,aAAa4F,OAAO6B,iBAAiBlC,EAAKtF,YAAY2F,OAAO6B,kBAAoBkG,GAMzF,OAFAvI,QAAQwB,IAAI,2BAA4BuG,EAASnN,cAE1C,IACFmN,EACH3J,GAAI,oBACJtB,SACAoK,WAAA,IAAeC,MAAOC,cACtB5I,WAAY,IACZE,aAAc,EACdsJ,YAAA,IAAgBb,MAAOC,cACvBa,YAAa,EACbC,WAAY,GAIhB,MAAM/H,EAAa,IACd4H,EACH3J,GAAI9B,OAAOC,aACXO,SACAoK,WAAA,IAAeC,MAAOC,cACtB5I,WAAY,IACZE,aAAc,EACdsJ,YAAA,IAAgBb,MAAOC,cACvBa,YAAa,EACbC,WAAY,GAsBd,OAnBA5B,EAAIrL,IACF,MACMkN,EAAe,IADHlN,EAAMmF,MAAMtD,IAAW,GACLqD,GAEpC,MAAO,CACLC,MAAO,IAAKnF,EAAMmF,MAAOtD,CAACA,GAASqL,GACnCtI,MAAO5E,EAAM4E,MAAM3B,OACjBrB,EAAKuB,KAAOtB,EACR,IAAKD,EAAMuL,UAAWD,EAAalJ,OAAQoI,eAAeF,MAAOC,eACjEvK,MAMM,sBAAZsD,EAAK/B,IACF8B,eAAepD,EAAQqD,GAGvBA,CACT,OAAS+F,GAEP,MADAlG,QAAQkG,MAAM,yCAA0CA,GAClDA,CACR,GAGFuC,eAAgBhJ,MAAOE,IACrB,IACE,MAAMoH,KAAEA,GAASC,EAAaC,WACxB9J,EAAS4J,GAAM3I,IAAM,aAErBvB,EAAa,IACd8C,EACHxC,SACAiB,GAAI9B,OAAOC,aACX2K,WAAA,IAAeC,MAAOC,cACtBC,WAAA,IAAeF,MAAOC,cACtB9J,SAAU,IAAK4B,KAAwBS,EAASrC,WAWlD,OARAgJ,EAAIrL,IAAA,CACF4E,MAAO,IAAI5E,EAAM4E,MAAOhD,GACxBuD,MAAO,IAAKnF,EAAMmF,MAAO,CAACvD,EAAKuB,IAAK,OAIjCsB,kBAAkBC,GAEhB9C,CACT,OAASqJ,GAEP,MADAlG,QAAQkG,MAAM,4CAA6CA,GACrDA,CACR,GAGFwC,cAAejJ,MAAO3C,EAAQ6L,KAC5B,IACE,MACML,EADQ/B,IACcnG,MAAMtD,IAAW,GAGvC8L,EAAkB,IAAIhL,IAC1B0K,EAAcpK,IAAIiC,GAAQ,GAAGA,EAAKvF,aAAa4F,OAAO6B,iBAAiBlC,EAAKtF,YAAY2F,OAAO6B,kBAI3FwG,EAAkBF,EAAUtK,OAAO0J,IACvC,MAAMQ,EAAU,GAAGR,EAASnN,aAAa4F,OAAO6B,iBAAiB0F,EAASlN,YAAY2F,OAAO6B,gBAC7F,OAAQuG,EAAgB/K,IAAI0K,KAK9B,GAFAvI,QAAQwB,IAAI,qBAAqBmH,EAAU1J,2BAA2B4J,EAAgB5J,8BAEvD,IAA3B4J,EAAgB5J,OAElB,OADAe,QAAQwB,IAAI,4CACL,GAGT,MAAMpB,EAAgByI,EAAgB3K,IAAI6J,IAAA,IACrCA,EACH3J,GAAI9B,OAAOC,aACXO,SACAoK,WAAA,IAAeC,MAAOC,cACtB5I,WAAY,IACZE,aAAc,EACdsJ,YAAA,IAAgBb,MAAOC,cACvBa,YAAa,EACbC,WAAY,KAGd5B,EAAIrL,IACF,MACMkN,EAAe,IADHlN,EAAMmF,MAAMtD,IAAW,MACFsD,GAEvC,MAAO,CACLA,MAAO,IAAKnF,EAAMmF,MAAOtD,CAACA,GAASqL,GACnCtI,MAAO5E,EAAM4E,MAAM3B,OACjBrB,EAAKuB,KAAOtB,EACR,IAAKD,EAAMuL,UAAWD,EAAalJ,OAAQoI,eAAeF,MAAOC,eACjEvK,MAMV,UAAWiM,KAAK1I,EACTF,eAAepD,EAAQgM,GAG9B,OAAO1I,CACT,OAAS8F,GAEP,MADAlG,QAAQkG,MAAM,2CAA4CA,GACpDA,CACR,GAGF6C,WAAYtJ,MAAO3B,EAAQe,KACzByH,EAAI,CAAEG,WAAW,EAAMP,MAAO,OAC9B,IACEI,EAAIrL,IACF,MAAM+N,EAAW,IAAK/N,EAAMmF,OAC5B,UAAWtD,KAAUkM,EACnBA,EAASlM,GAAUkM,EAASlM,GAAQoB,IAAIiC,GACtCA,EAAK/B,KAAON,EAAS,IAAKqC,KAAStB,GAAYsB,GAGnD,MAAO,CAAEC,MAAO4I,EAAUvC,WAAW,IAEzC,OAASP,GAEP,MADAI,EAAI,CAAEJ,MAAO,wBAAyBO,WAAW,IAC3CP,CACR,GAGF+C,WAAYxJ,MAAO3B,IACjBwI,EAAI,CAAEG,WAAW,EAAMP,MAAO,OAC9B,IACE,IAAIgD,EAAiB,GACrB5C,EAAIrL,IACF,MAAM+N,EAAW,IAAK/N,EAAMmF,OAC5B,UAAWtD,KAAUkM,EAAU,CAE7B,IAAkB,IADAA,EAASlM,GAAQqM,UAAUhJ,GAAQA,EAAK/B,KAAON,GAC3C,CACpBkL,EAASlM,GAAUkM,EAASlM,GAAQuB,OAAO8B,GAAQA,EAAK/B,KAAON,GAC/DoL,EAAiBpM,EACjB,KACF,CACF,CAEA,MAAO,CACLsD,MAAO4I,EACPnJ,MAAO5E,EAAM4E,MAAM3B,OACjBrB,EAAKuB,KAAO8K,EACR,IAAKrM,EAAMuL,UAAWY,EAASE,GAAgBjK,OAAQoI,WAAA,IAAeF,MAAOC,eAC7EvK,GAEN4J,WAAW,KAIf,IACO7G,EAAMQ,MAAMuH,OAAO7J,EAC1B,OAAS6G,GACP3E,QAAQC,KAAK,qCAAsC0E,EACrD,CACF,OAASuB,GAEP,MADAI,EAAI,CAAEJ,MAAO,wBAAyBO,WAAW,IAC3CP,CACR,GAGFkD,iBAAkB3J,MAAO3C,EAAQuM,KAC/B/C,EAAI,CAAEG,WAAW,EAAMP,MAAO,OAC9B,IACEI,EAAIrL,IACF,MAAM+N,EAAW,IAAK/N,EAAMmF,OAEtBkJ,GADmBN,EAASlM,IAAW,IACHuB,OAAO8B,IAASkJ,EAAQE,SAASpJ,EAAK/B,KAIhF,OAFA4K,EAASlM,GAAUwM,EAEZ,CACLlJ,MAAO4I,EACPnJ,MAAO5E,EAAM4E,MAAM3B,OACjBrB,EAAKuB,KAAOtB,EACR,IAAKD,EAAMuL,UAAWkB,EAAiBrK,OAAQoI,eAAeF,MAAOC,eACrEvK,GAEN4J,WAAW,KAKf,UAAW3I,KAAUuL,EACnB,IACOzJ,EAAMQ,MAAMuH,OAAO7J,EAC1B,OAAS6G,GACP3E,QAAQC,KAAK,qDAAqDnC,IAAU6G,EAC9E,CAEJ,OAASuB,GAEP,MADAI,EAAI,CAAEJ,MAAO,kCAAmCO,WAAW,IACrDP,CACR,GAGFsD,SAAW1M,GACFyJ,IAAMnG,MAAMtD,IAAW,GAGhC2M,eAAgBhK,MAAOgD,IACrB,MAAMiH,kBAAEA,EAAAC,oBAAmBA,GAAwBpD,IACnDD,EAAI,CAAEG,WAAW,EAAMP,MAAO,OAC9ByD,IAEA,IACE,MAAMC,EAAWnH,EAAK1F,KAAKsF,cAG3B,GAAIuH,EAASpG,SAAS,SAAU,CAC9BkG,EAAkB,GAAI,mBAGtB,MAAM3M,KAAEA,EAAAqD,MAAMA,EAAA+E,WAAOA,SAAqB3C,cAAcC,GAExDzC,QAAQwB,IAAI,iBAAiBzE,UAAaqD,EAAMnB,oBAAoBkG,EAAWlG,sBAG/E,MAAM8H,KAAEA,GAASC,EAAaC,WACxB9J,EAAS4J,GAAM3I,IAAM,aAE3B,GADqBmI,IAAM1G,MAAMgI,KAAKgC,GAAKA,EAAE7M,QAAUD,GAAQ8M,EAAE1M,SAAWA,GAE1E,MAAM,IAAI2G,MAAM,iBAAiB/G,2EAGnC2M,EAAkB,GAAI,oBAGtB,MAAM7M,QAAa0J,IAAMkC,eAAe,CACtCtL,SACAH,MAAOD,EACPE,YAAa,2BAA2BmD,EAAMnB,eAC9CmJ,UAAW,EACX5K,UAAU,EACVF,SAAU4B,EACV7B,SAAU,aAIZ,GAAI8H,EAAWlG,OAAS,EAAG,CACzBe,QAAQwB,IAAI,uCAAuC2D,EAAWlG,gBAC9DyK,EAAkB,GAAI,WAAWvE,EAAWlG,yBAE5C,MAAM6K,EAAsBC,IACtBC,EAMD,GAEL,QAASjF,EAAI,EAAGA,EAAII,EAAWlG,OAAQ8F,IAAK,CAC1C,MAAMkF,EAAY9E,EAAWJ,GAC7B,IAEE,MAAMmF,EAAWD,EAAUjE,KAAKjL,MAAQ0G,wBAAwBwI,EAAUvI,UAE1E1B,QAAQwB,IAAI,0BAA0BuD,EAAI,KAAKI,EAAWlG,WAAWgL,EAAUvI,aAAawI,MAAaD,EAAUjE,KAAKC,eAGxH,MAAMkE,QAAkBC,EAAaC,UAAUJ,EAAUjE,KAAMkE,GAE/DlK,QAAQwB,IAAI,mBAAmByI,EAAUvI,uBAAuByI,KAGhEH,EAAiB5I,KAAK,CACpBhD,GAAI+L,EACJpE,iBAAkBkE,EAAUvI,SAC5BA,SAAUuI,EAAUvI,SACpBwI,WACApE,KAAMmE,EAAUjE,OAGdjB,EAAI,IAAO,GACb2E,EAAkB,GAAM,EAAI3E,EAAII,EAAWlG,OAAS,UAAU8F,KAAKI,EAAWlG,wBAElF,OAASc,GACPC,QAAQkG,MAAM,wCAAwC+D,EAAUvI,WAAY3B,EAC9E,CACF,CAEAC,QAAQwB,IAAI,mBAAmBwI,EAAiB/K,kDAAkDpC,EAAKuB,YAGjG0L,EAAoBQ,wBAAwBzN,EAAKuB,GAAI4L,EAAkB7M,GAE7E6C,QAAQwB,IAAI,0CAA0C3E,EAAKuB,MAC3D4B,QAAQwB,IAAI,wCAA0CsI,EAA4BS,YAAYhE,IAAI1J,EAAKuB,KAAK6H,MAAQ,EACtH,MACEjG,QAAQwB,IAAI,0CAGdkI,EAAkB,GAAI,aAAatJ,EAAMnB,mBAGzC,MAAMuL,EAA4B,GAC5BC,MAAgB7M,IAEtB,UAAWuC,KAAQC,EAAO,CACxB,MAAMmI,EAAU,GAAGpI,EAAKnC,MAAMwC,OAAO6B,iBAAiBlC,EAAKlC,KAAKuC,OAAO6B,gBAClEoI,EAAU5M,IAAI0K,KACjBkC,EAAUC,IAAInC,GACdiC,EAAYpJ,KAAKjB,GAErB,CAEAH,QAAQwB,IAAI,WAAWpB,EAAMnB,OAASuL,EAAYvL,iDAAiDuL,EAAYvL,wBAG/G,MAAM0L,EAAY,IAClB,IAAIC,EAAoB,EACxB,MAAMC,EAAaL,EAAYvL,OAE/Be,QAAQwB,IAAI,4BAA4BqJ,kBAExC,QAAS9F,EAAI,EAAGA,EAAI8F,EAAY9F,GAAK4F,EAAW,CAC9C,MAAMG,EAAQN,EAAY7N,MAAMoI,EAAGA,EAAI4F,GACjCI,EAAaD,EAAM5M,IAAI6J,GAAYpN,cACvCoN,EAAS/J,MACT+J,EAAS9J,KACT,CAAElD,KAAM,SACR,KAGF,IACEiF,QAAQwB,IAAI,oBAAoBhF,KAAKwO,MAAMjG,EAAI4F,GAAa,KAAKnO,KAAKyO,KAAKJ,EAAaF,OAAeG,EAAM7L,uBACvGsH,IAAMmC,cAAc7L,EAAKuB,GAAI2M,GACnCH,GAAqBE,EAAM7L,OAG3B,MAAMiM,EAAe,GAAM,GAAK1O,KAAKsI,IAAIC,EAAI4F,EAAWE,GAAcA,EACtEnB,EAAkBwB,EAAc,YAAYN,KAAqBC,cAEjE7K,QAAQwB,IAAI,8BAA8B0J,EAAaC,QAAQ,aAGzD,IAAItI,QAAQuI,GAAWC,WAAWD,EAAS,IACnD,OAASE,GACPtL,QAAQkG,MAAM,0BAA2BoF,GAEzC,UAAWC,KAAgBT,EACzB,UACQvE,IAAM8B,YAAYxL,EAAKuB,GAAIzD,cAC/B4Q,EAAavN,MACbuN,EAAatN,KACb,CAAElD,KAAM,SACR,KAEF6P,GACF,OAASY,GACPxL,QAAQC,KAAK,oCAAqCsL,EAAcC,EAClE,CAKF9B,EADqB,GAAM,GAAKlN,KAAKsI,IAAIC,EAAI4F,EAAWE,GAAcA,EACtC,YAAYD,KAAqBC,aACnE,CACF,CAmBA,OAjBA7K,QAAQwB,IAAI,6CAA6CoJ,KAEzDlB,EAAkB,GAAI,8BAGhBnD,IAAMe,WAAWzK,EAAKuB,GAAI,CAC9BnB,YAAa,2BAA2B2N,YAG1ClB,EAAkB,IAAK,qBAGvB2B,WAAW,KACT1B,KACC,KAEHrD,EAAI,CAAEG,WAAW,IACV5J,CACT,IAAW+M,EAASpG,SAAS,SAAWoG,EAASpG,SAAS,SAAWoG,EAASpG,SAAS,QAAS,CAC9FkG,EAAkB,GAAI,wBAGtB,MAAM+B,QAAahJ,EAAKgJ,OAGxB,IAAIC,EAAY,KACZ9B,EAASpG,SAAS,UACpBkI,EAAY,KAGdhC,EAAkB,GAAI,8BAGtB,MAAMiC,EAAYF,EACflL,QAAQ,QAAS,MACjBA,QAAQ,MAAO,MACfC,OAEG3D,QAAa0J,IAAMqF,eACvBnJ,EAAK1F,KAAKwD,QAAQ,YAAa,IAC/BoL,EACAD,GAGF,OADApF,EAAI,CAAEG,WAAW,IACV5J,CACT,CAAO,CACL6M,EAAkB,GAAI,2BAGtB,MAAM+B,QAAahJ,EAAKgJ,OAExB/B,EAAkB,GAAI,yBAEtB,MAAMiC,EAAYF,EACflL,QAAQ,QAAS,MACjBA,QAAQ,MAAO,MACfC,OAEG3D,QAAa0J,IAAMqF,eACvBnJ,EAAK1F,KAAKwD,QAAQ,YAAa,IAC/BoL,EACA,MAGF,OADArF,EAAI,CAAEG,WAAW,IACV5J,CACT,CACF,OAASqJ,GACP,MAAM2F,EAAe3F,aAAiBpC,MAAQoC,EAAMC,QAAU,6BAG9D,MAFAG,EAAI,CAAEJ,MAAO2F,EAAcpF,WAAW,IACtCkD,IACMzD,CACR,GAGF0F,eAAgBnM,MAAO4E,EAAUoH,EAAMC,EAAY,QACjD,MAAMhC,kBAAEA,EAAAC,oBAAmBA,GAAwBpD,IACnDD,EAAI,CAAEG,WAAW,EAAMP,MAAO,OAE9B,IACEwD,EAAkB,GAAI,8BAGtB,MAOMoC,EAPYL,EACflL,QAAQ,QAAS,MACjBA,QAAQ,MAAO,MACfA,QAAQ,WAAY,IACpBA,QAAQ,yDAA0D,IAClEC,OAGA8B,MAAM,MACNpE,IAAI6N,GAAQA,EAAKvL,QACjBnC,OAAO0N,GAAQA,EAAK9M,OAAS,GAEhC,GAAqB,IAAjB6M,EAAM7M,OACR,MAAM,IAAI6E,MAAM,sCAGlB4F,EAAkB,GAAI,oBAEtB,MAAM3C,KAAEA,GAASC,EAAaC,WACxB9J,EAAS4J,GAAM3I,IAAM,aAErBvB,QAAa0J,IAAMkC,eAAe,CACtCtL,SACAH,MAAOqH,EACPpH,YAAa,sBAAsB6O,EAAM7M,eACzCmJ,UAAW,EACX5K,UAAU,EACVF,SAAU4B,EACV7B,SAAU,aAGZqM,EAAkB,GAAI,aAAaoC,EAAM7M,mBAGzC,MAAM+M,EAA6I,GACnJ,IAAIC,EAAe,EAGnB,QAASlH,EAAI,EAAGA,EAAI+G,EAAM7M,OAAQ8F,IAAK,CACrC,MAAMgH,EAAOD,EAAM/G,GACnB,IAEE,IAAImH,EAUJ,GAPEA,EAFgB,MAAdR,GAAqBK,EAAKxC,SAAS,KAE7BwC,EAAKzJ,MAAM,KAAKpE,OACtBiO,EAAK5L,QAAQ,WAAY,MAAMC,QAGzBuL,EAAKzJ,MAAMoJ,GAGjBQ,EAAMjN,QAAU,EAAG,CACrB,MAAMjB,EAAQkO,EAAM,GAAG1L,OACjBvC,EAAOiO,EAAM,GAAG1L,OAGlBxC,GAASC,EACX+N,EAAW5K,KAAKzG,cACdqD,EACAC,EACA,CAAElD,KAAM,SACR,KAGFkR,GAEJ,MACEA,GAEJ,OAASX,GACPtL,QAAQC,KAAK,wBAAyB8L,EAAMT,GAC5CW,GACF,CACF,CAGA,MAAMG,EAAsC,GACtC3B,MAAgB7M,IAEtB,UAAWuC,KAAQ6L,EAAY,CAC7B,MAAMzD,EAAU,GAAGpI,EAAKvF,aAAa4F,OAAO6B,iBAAiBlC,EAAKtF,YAAY2F,OAAO6B,gBAChFoI,EAAU5M,IAAI0K,KACjBkC,EAAUC,IAAInC,GACd6D,EAAiBhL,KAAKjB,GAE1B,CAEAH,QAAQwB,IAAI,WAAWwK,EAAW/M,OAASmN,EAAiBnN,mDAAmDmN,EAAiBnN,wBAGhI,MAAM0L,EAAY,IAClB,IAAIC,EAAoB,EAExB5K,QAAQwB,IAAI,4CAA4C4K,EAAiBnN,uBAEzE,QAAS8F,EAAI,EAAGA,EAAIqH,EAAiBnN,OAAQ8F,GAAK4F,EAAW,CAC3D,MAAMG,EAAQsB,EAAiBzP,MAAMoI,EAAGA,EAAI4F,GAE5C,IACE3K,QAAQwB,IAAI,yBAAyBhF,KAAKwO,MAAMjG,EAAI4F,GAAa,KAAKnO,KAAKyO,KAAKmB,EAAiBnN,OAAS0L,OAAeG,EAAM7L,iBAC/H,MAAMoN,QAAmB9F,IAAMmC,cAAc7L,EAAKuB,GAAI0M,GACtDF,GAAqByB,EAAWpN,OAGhC,MAAMiM,EAAe,GAAM,GAAK1O,KAAKsI,IAAIC,EAAI4F,EAAWyB,EAAiBnN,QAAUmN,EAAiBnN,OACpGyK,EAAkBwB,EAAc,YAAYN,KAAqBwB,EAAiBnN,mBAElFe,QAAQwB,IAAI,mCAAmC0J,EAAaC,QAAQ,eAAekB,EAAWpN,sBAGxF,IAAI4D,QAAQuI,GAAWC,WAAWD,EAAS,IACnD,OAASE,GACPtL,QAAQkG,MAAM,+BAAgCoF,GAE9C,UAAWvD,KAAY+C,EACrB,IAEuB,6BADGvE,IAAM8B,YAAYxL,EAAKuB,GAAI2J,IACrC3J,IACZwM,GAEJ,OAASY,GACPxL,QAAQC,KAAK,yCAA0C8H,EAAUyD,EACnE,CAKF9B,EADqB,GAAM,GAAKlN,KAAKsI,IAAIC,EAAI4F,EAAWyB,EAAiBnN,QAAUmN,EAAiBnN,OACpE,YAAY2L,KAAqBwB,EAAiBnN,kBACpF,CACF,CAWA,GATAe,QAAQwB,IAAI,6DAA6DoJ,KAEzElB,EAAkB,GAAI,8BAGhBnD,IAAMe,WAAWzK,EAAKuB,GAAI,CAC9BnB,YAAa,sBAAsB2N,UAA0BqB,EAAe,EAAI,KAAKA,mBAAgC,OAG7F,IAAtBrB,EACF,MAAM,IAAI9G,MAAM,mEAWlB,OARA4F,EAAkB,IAAK,qBAGvB2B,WAAW,KACT1B,KACC,KAEHrD,EAAI,CAAEG,WAAW,IACV5J,CACT,OAASqJ,GAGP,MAFAI,EAAI,CAAEJ,MAAO,6BAA8BO,WAAW,IACtDkD,IACMzD,CACR,GAGFoG,iBAAkB7M,UAChB6G,EAAI,CAAEG,WAAW,EAAMP,MAAO,OAC9B,IACE,MAAMjL,EAAQsL,IAGRgG,EAAiB,IAAI3O,IAAI3C,EAAM4E,MAAM3B,IAAIrB,GAAQA,EAAKG,QAI5D,GAHsB,CAAC,qBAAsB,sBAAuB,kBAGlDwL,KAAKxL,GAASuP,EAAe1O,IAAIb,IAGjD,OAFAgD,QAAQwB,IAAI,mDACZ8E,EAAI,CAAEG,WAAW,IAInB,MAAM+F,EAAe,CACnB,CACExP,MAAO,qBACPC,YAAa,wCACbI,SAAU,WACV+C,MAAO,CACL,CAAEpC,MAAO,QAASC,KAAM,QACxB,CAAED,MAAO,UAAWC,KAAM,SAC1B,CAAED,MAAO,YAAaC,KAAM,WAC5B,CAAED,MAAO,SAAUC,KAAM,aACzB,CAAED,MAAO,MAAOC,KAAM,MACtB,CAAED,MAAO,KAAMC,KAAM,MACrB,CAAED,MAAO,QAASC,KAAM,QACxB,CAAED,MAAO,OAAQC,KAAM,UACvB,CAAED,MAAO,QAASC,KAAM,QACxB,CAAED,MAAO,MAAOC,KAAM,WAG1B,CACEjB,MAAO,sBACPC,YAAa,4CACbI,SAAU,cACV+C,MAAO,CACL,CAAEpC,MAAO,qBAAsBC,KAAM,mIACrC,CAAED,MAAO,oBAAqBC,KAAM,+FACpC,CAAED,MAAO,8CAA+CC,KAAM,qGAC9D,CAAED,MAAO,qBAAsBC,KAAM,wGACrC,CAAED,MAAO,uBAAwBC,KAAM,yHAG3C,CACEjB,MAAO,iBACPC,YAAa,+CACbI,SAAU,YACV+C,MAAO,CACL,CAAEpC,MAAO,SAAUC,KAAM,SACzB,CAAED,MAAO,UAAWC,KAAM,UAC1B,CAAED,MAAO,QAASC,KAAM,QACxB,CAAED,MAAO,QAASC,KAAM,UACxB,CAAED,MAAO,iBAAkBC,KAAM,UACjC,CAAED,MAAO,QAASC,KAAM,SACxB,CAAED,MAAO,QAASC,KAAM,WACxB,CAAED,MAAO,YAAaC,KAAM,YAC5B,CAAED,MAAO,SAAUC,KAAM,YACzB,CAAED,MAAO,SAAUC,KAAM,aAK/B+B,QAAQwB,IAAI,4BACZ,MAAMuF,KAAEA,GAASC,EAAaC,WACxB9J,EAAS4J,GAAM3I,IAAM,aAE3B,UAAWuB,KAAY6M,EAAc,CACnC,MAAM3P,QAAa0J,IAAMO,WAAW,CAClC3J,SACAH,MAAO2C,EAAS3C,MAChBC,YAAa0C,EAAS1C,YACtBmL,UAAW,EACX5K,UAAU,EACVF,SAAU4B,EACV7B,SAAUsC,EAAStC,SACnBD,KAAM,CAACuC,EAAStC,YAGlB,UAAW0K,KAAYpI,EAASS,YACxBmG,IAAMuB,QAAQjL,EAAKuB,GAAIzD,cAC3BoN,EAAS/J,MACT+J,EAAS9J,KACT,CAAElD,KAAM,SACR,IAGN,CAEAiF,QAAQwB,IAAI,qCACZ8E,EAAI,CAAEG,WAAW,GACnB,OAASP,GAEP,MADAI,EAAI,CAAEJ,MAAO,+BAAgCO,WAAW,IAClDP,CACR,GAGFuG,WAAY,IAAMnG,EAAI,CAAEJ,MAAO,OAC/BwG,WAAaC,GAAYrG,EAAI,CAAEG,UAAWkG,IAC1CC,qBAAsBnN,MAAO3C,IAC3B,IACE,MACM+P,EADQtG,IACUnG,MAAMtD,IAAW,GAEzC,GAAyB,IAArB+P,EAAU5N,OACZ,OAAO,EAIT,MAAM6N,MAAqBC,IAC3B,IAAIC,EAAoB,EAExB,UAAW7M,KAAQ0M,EAAW,CAC5B,MAAMtE,EAAU,GAAGpI,EAAKvF,aAAa4F,OAAO6B,iBAAiBlC,EAAKtF,YAAY2F,OAAO6B,gBAEhFyK,EAAejP,IAAI0K,IAGtByE,IACAhN,QAAQwB,IAAI,4BAA4BrB,EAAKvF,iBAH7CkS,EAAexG,IAAIiC,EAASpI,EAKhC,CAEA,MAAMqK,EAAcyC,MAAMC,KAAKJ,EAAexI,UAe9C,OAbI0I,EAAoB,IACtB1G,EAAIrL,KACFmF,MAAO,IAAKnF,EAAMmF,MAAOtD,CAACA,GAAS0N,GACnC3K,MAAO5E,EAAM4E,MAAM3B,OACjBrB,EAAKuB,KAAOtB,EACR,IAAKD,EAAMuL,UAAWoC,EAAYvL,OAAQoI,eAAeF,MAAOC,eAChEvK,MAIRmD,QAAQwB,IAAI,WAAWwL,gCAAgDxC,EAAYvL,mCAG9E+N,CACT,OAAS9G,GAEP,MADAlG,QAAQkG,MAAM,oCAAqCA,GAC7CA,CACR,GAGFwD,kBAAmB,CAACyD,EAAUC,IAAW9G,EAAI,CAAEI,eAAgByG,EAAUxG,aAAcyG,IACvFzD,oBAAqB,IAAMrD,EAAI,CAAEI,eAAgB,EAAGC,aAAc,OAGlE0G,qBAAsB5N,UACpB,MAAMxE,EAAQsL,IACd,IAAItL,EAAM2L,SAAV,CACAN,EAAI,CAAEG,WAAW,IACjB,IAEE,MAAM6G,QAAiB1N,EAAMC,MAAM0N,OAC7BC,EAAsC,GAG5C,UAAW3D,KAAKyD,EAAU,CACxB,MACMlN,SADaR,EAAMQ,MAAMqN,WAAW5D,EAAE/M,SACjBoB,IAAKwP,IAC9B,MAAMC,GAAA,IAAaxG,MAAOC,cACpBwG,EAAa,IAAIzG,KAAKuG,EAAExG,WAAWE,iBAAmBuG,EACtDE,EAASH,EAAE/O,MAAQnC,KAAKwO,MAAM0C,EAAE/O,MAAQ,OAAYnC,KAAKwO,MAAM7D,KAAK2G,MAAQ,OAClF,MAAO,CACL1P,GAAIsP,EAAE5P,OACNhB,OAAQ4Q,EAAE5Q,OACVlC,aAAcmT,OAAQL,EAAE3P,QAAgBC,OAAS,IACjDnD,YAAakT,OAAQL,EAAE3P,QAAgBE,MAAQ,IAC/CnD,SAAU,CAAEC,KAAM,SAClBC,UAAW,GAGXwD,WAA8B,iBAAXkP,EAAEnP,KAAqBmP,EAAEnP,KAAO,IAAO,IAC1DG,aAAcgP,EAAEjP,UAAY,EAC5BuJ,WAAY0F,EAAE/O,MAAQ,IAAIwI,KAAKuG,EAAE/O,OAAOyI,cAAgBuG,EACxDzG,UAAW0G,EACX3F,YAAa,EACbC,WAAYwF,EAAEnS,QAAU,EAGxBN,MAAQyS,EAAEzS,OAA2B,MACrCC,MAAO,EACPC,IAAK0S,EACLzS,IAAKsS,EAAEjP,UAAY,EACnBpD,OAA0B,iBAAXqS,EAAEnP,KAAoBmP,EAAEnP,KAAO,IAC9CjD,KAAM,EACNC,OAAQmS,EAAEnS,QAAU,EACpBC,KAAM,EAENC,aAAc,EACdC,mBAAoB,EACpBC,aAAc,EAEdC,eAAgB,EAChBC,kBAAmB,EACnBC,MAAO,EACPC,YAAa,EACbC,aAAc0R,EAAE5Q,OAChBb,UAAW,EACXC,iBAAkB,KAGtBsR,EAAY3D,EAAE/M,QAAUsD,CAC1B,CAGA,MAAMyG,EAAgB5L,EAAM4L,eAAiBG,EAAaC,WAAWF,MAAM3I,IAAM,aAG3EyB,EAAgB,GACtB,UAAWgK,KAAKyD,EAAU,CACxB,MAAMpQ,EAAQ2M,EAAE3M,MAAQ,GAClB8Q,EAAa9Q,EAAKC,QAAU0J,EAGlC,IAAK3J,EAAKC,QAAU6Q,EAAY,CAC9B,MAAMC,EAAc,IAAK/Q,EAAMC,OAAQ6Q,GAEvCpO,EAAMC,MAAM0G,IAAIsD,EAAE/M,QAAQmG,KAAKiL,IAC7B,GAAIA,EACF,OAAOtO,EAAMC,MAAM0H,OAAOsC,EAAE/M,OAAQ,CAAEI,KAAM+Q,MAE7CE,MAAMpO,IAEFA,EAAIoG,SAASoD,SAAS,mBACzBvJ,QAAQC,KAAK,gDAAiD4J,EAAE/M,OAAQiD,IAG9E,CAEAF,EAAMuB,KAAK,CACThD,GAAIyL,EAAE/M,OACNK,OAAQ6Q,EACRhR,MAAO6M,EAAE9M,KACTE,YAAa4M,EAAE5M,aAAe,GAC9BmL,UAAYoF,EAAY3D,EAAE/M,SAASmC,QAAU4K,EAAEzB,WAAa,EAC5D5K,SAAUN,EAAKM,WAAY,EAC3BF,SAAUJ,EAAKI,UAAY,IAAK4B,GAChC3B,iBAAkBL,EAAKK,iBACvB2J,UAAW,IAAIC,KAAK0C,EAAE3C,WAAWE,cACjCC,UAAW,IAAIF,KAAK0C,EAAExC,WAAWD,cACjChK,KAAMF,EAAKE,MAAQ,GACnBC,SAAUH,EAAKG,eAAY,GAE/B,CAEAiJ,EAAI,CACFzG,QACAO,MAAOoN,EACP5G,UAAU,EACVH,WAAW,EACXP,MAAO,MAEX,OAASvB,GACP3E,QAAQC,KAAK,0CAA2C0E,GACxD2B,EAAI,CAAEM,UAAU,EAAMH,WAAW,EAAOP,MAAO,6BACjD,CA3GoB,GA+GhBkI,kBAAmB,CAACtR,EAAQuR,KAChC,MAAMC,EAAeD,EAAWnQ,IAAI4K,GAAKA,EAAE1K,IAC3CkI,EAAI,CACFE,oBAAqB,CACnB1J,SACAyR,iBAAkB,EAClBF,aACAC,eACAE,aAAc,CACZC,MAAOJ,EAAWpP,OAClByP,QAAS,EACTC,UAAW,GAEbC,WAAA,IAAezH,MAAOC,kBAK5ByH,mBAAoB,CAACN,EAAkBC,KACrClI,EAAIrL,IAAA,CACFuL,oBAAqBvL,EAAMuL,oBAAsB,IAC5CvL,EAAMuL,oBACT+H,mBACAC,gBACE,SAIRM,kBAAmB,KACjBxI,EAAI,CAAEE,oBAAqB,QAG7BuI,gBAAkBjS,IAChB,MAAM7B,EAAQsL,IACd,OAAOtL,EAAMuL,qBAAqB1J,SAAWA,EAAS7B,EAAMuL,oBAAsB,MAGpFwI,kBAAmB,KAEjB1I,EAAIrL,IAEF,MAAMgU,EAAqC,GAE3C,UAAYnS,EAAQsD,KAAUrB,OAAOyG,QAAQvK,EAAMmF,OACjD6O,EAAWnS,GAAUsD,EAAMlC,IAAIiC,IAAA,IAC1BA,EACH3B,WAAY,IACZE,aAAc,EACdsJ,YAAA,IAAgBb,MAAOC,cACvBa,YAAa,EACbC,WAAY,KAIhB,MAAO,CACL9H,MAAO6O,EACPzI,oBAAqB,SAK3B0I,eAAiB/R,IACfmJ,EAAI,CAAEO,cAAe1J,KAGvBgS,aAAc,KACZ,MAAMlU,EAAQsL,IACd,OAAKtL,EAAM4L,cACJ5L,EAAM4E,MAAMxB,UAAexB,EAAKM,SAAWlC,EAAM4L,eADvB,MAIrC,CACE9J,KAAM,eAENqS,WAAanU,IAGX,MAAMmF,MAAEA,EAAAoG,oBAAOA,KAAwB6I,GAAgBpU,EAcvD,MAAO,IAAKoU,EAAa7I,oBAZAA,EACrB,CACE1J,OAAQ0J,EAAoB1J,OAC5ByR,iBAAkB/H,EAAoB+H,iBACtCD,aAAc9H,EAAoB8H,aAClCE,aAAchI,EAAoBgI,aAClCI,UAAWpI,EAAoBoI,WAEjC,UAUCU,eAAiB,KAC5B,MAAMC,EAAQnJ,IACRoJ,EAAUD,EAAM/I,oBAEtB,IAAKgJ,IAAYA,EAAQlB,cAAgD,IAAhCkB,EAAQlB,aAAarP,OAC5D,OAAO,KAGT,MAAMwQ,EAAgBD,EAAQlB,aAAakB,EAAQjB,kBACnD,IAAKkB,EACH,OAAO,KAKT,OADkBF,EAAMnP,MAAMoP,EAAQ1S,SAAW,IAChC+K,KAAK1H,GAAQA,EAAK/B,KAAOqR,IAAkB,MCl+CxDC,sBAAwBjQ,MAAOkQ,IACnC,MAAMC,EAAMD,EACZE,EAAYrO,IAAI,eAAgB,gCAAiC,CAC/DrE,OAAQyS,GAAKxR,GACb0R,MAAOF,GAAKE,MACZC,SAAUH,GAAKG,WAGjB,IACE,MAAM3R,EAAa2P,OAAO6B,GAAKxR,IAAM,IAC/B0R,EAAgB/B,OAAO6B,GAAKE,OAAS,IACrCE,EAAWF,GAASA,EAAMvG,SAAS,KAAOuG,EAAMxN,MAAM,KAAK,GAAK,OAGhE2N,EAAsB,CAC1B7R,KACA0R,MAAOA,GAAS,sBAChBC,SALuBhC,OAAO6B,GAAKG,UAAYC,GAAY,QAM3DE,MAAOC,OAAOP,GAAKM,OAAS,GAC5BE,QAASD,OAAOP,GAAKS,UAAY,GACjCC,MAAOH,OAAOP,GAAKU,OAAS,KAC5BC,KAAMJ,OAAOP,GAAKW,MAAQ,IAC1BrJ,UAAW6G,OAAO6B,GAAKY,UAAA,IAAerJ,MAAOC,eAC7CqJ,WAAY1C,OAAO6B,GAAKc,cAAA,IAAmBvJ,MAAOC,eAClDuJ,YAAaf,GAAKe,aAAe,CAC/BC,MAAO,SACPC,SAAU,KACVC,eAAe,EACfC,cAAc,EACdC,UAAW,GACXC,SAAU,QAKd,OADApB,EAAYrO,IAAI,eAAgB,8BAA+ByO,GACxDA,CACT,OAAS/J,GACP2J,EAAY3J,MAAM,eAAgB,iCAAkC,CAClEA,QACAgL,MAAOhL,aAAiBpC,MAAQoC,EAAMgL,WAAQ,EAC9C/T,OAASyS,GAAaxR,KAIxB,MAAMA,EAAa2P,OAAO6B,GAAKxR,IAAM,IAC/B0R,EAAgB/B,OAAO6B,GAAKE,OAAS,uBACrCE,EAAWF,GAASA,EAAMvG,SAAS,KAAOuG,EAAMxN,MAAM,KAAK,GAAK,OAGhE6O,EAAqB,CACzB/S,KACA0R,QACAC,SALuBhC,OAAO6B,GAAKG,UAAYC,GAAY,QAM3DE,MAAO,EACPE,QAAS,EACTE,MAAO,IACPC,KAAM,GACNrJ,UAAW6G,OAAO6B,GAAKY,UAAA,IAAerJ,MAAOC,eAC7CqJ,YAAA,IAAgBtJ,MAAOC,cACvBuJ,YAAa,CACXC,MAAO,SACPC,SAAU,KACVC,eAAe,EACfC,cAAc,EACdC,UAAW,GACXC,SAAU,QAKd,OADApB,EAAYrO,IAAI,eAAgB,yCAA0C2P,GACnEA,CACT,GAmIWnK,EAAelH,IAAoB,CAACwG,EAAKC,KAAA,CACpDQ,KAAM,KACNyI,QAAS,KACT4B,iBAAiB,EACjB3K,WAAW,EACXP,MAAO,KAEPmL,OAAQ5R,MAAOqQ,EAAewB,EAAmBvB,KAE/CzJ,EAAI,CAAEG,WAAW,EAAMP,MAAO,OAC9B2J,EAAY0B,KAAK,eAAgB,6DACjC,MAAMC,QAAgBC,UAChBC,EAAmB,CAAEC,YAAa5B,IACxC,MAAM6B,EAAkB,CACtBxT,GAAIoT,EAAQK,aACZ/B,MAAOA,GAAS,eAChBC,SAAUA,GAAYyB,EAAQG,aAAe,MAC7CzB,MAAO,EACPE,QAAS,EACTE,MAAO,EACPC,KAAM,EACNrJ,UAAW,IAAIC,KAAKqK,EAAQtK,WAAWE,cACvCqJ,YAAA,IAAgBtJ,MAAOC,cACvBuJ,YAAa,CACXC,MAAO,SACPC,SAAU,KACVC,eAAe,EACfC,cAAc,EACdC,UAAW,GACXC,SAAU,QAGd3K,EAAI,CAAES,KAAM6K,EAAWpC,QAAS,KAAM4B,iBAAiB,EAAM3K,WAAW,EAAOP,MAAO,QAGxF4L,OAAQrS,MAAOsS,EAAgBT,KAE7BhL,EAAI,CAAEG,WAAW,EAAMP,MAAO,OAC9B2J,EAAY0B,KAAK,eAAgB,iDACjC,MAAMC,QAAgBC,IAChBG,EAAkB,CACtBxT,GAAIoT,EAAQK,aACZ/B,MAAO,eACPC,SAAUyB,EAAQG,aAAe,MACjCzB,MAAO,EACPE,QAAS,EACTE,MAAO,EACPC,KAAM,EACNrJ,UAAW,IAAIC,KAAKqK,EAAQtK,WAAWE,cACvCqJ,YAAA,IAAgBtJ,MAAOC,cACvBuJ,YAAa,CACXC,MAAO,SACPC,SAAU,KACVC,eAAe,EACfC,cAAc,EACdC,UAAW,GACXC,SAAU,QAGd3K,EAAI,CAAES,KAAM6K,EAAWpC,QAAS,KAAM4B,iBAAiB,EAAM3K,WAAW,EAAOP,MAAO,OACtFE,EAAaa,WAAWiI,eAAe0C,EAAUxT,KAGnD4T,QAASvS,UACPoQ,EAAYrO,IAAI,eAAgB,mBAEhC,IACEqO,EAAYrO,IAAI,eAAgB,sCAChCyQ,EAAGC,UAAUC,QAEbtC,EAAYrO,IAAI,eAAgB,uBAChC8E,EAAI,CACFS,KAAM,KACNyI,QAAS,KACT4B,iBAAiB,EACjBlL,MAAO,OAETE,EAAaa,WAAWiI,eAAe,MAEvCW,EAAYrO,IAAI,eAAgB,0BAClC,OAAS0E,GACP2J,EAAY3J,MAAM,eAAgB,gBAAiB,CACjDA,QACAgL,MAAOhL,aAAiBpC,MAAQoC,EAAMgL,WAAQ,IAGhD5K,EAAI,CACFJ,MAAOA,aAAiBpC,MAAQoC,EAAMC,QAAU,iBAEpD,GAGFiM,cAAe3S,MAAOqQ,IACpBD,EAAYrO,IAAI,eAAgB,wBAAyB,CAAEsO,UAE3DxJ,EAAI,CAAEG,WAAW,EAAMP,MAAO,OAE9B,UACQ+L,EAAGI,WAAW,SAASC,qBAAqBxC,GAElDxJ,EAAI,CACFG,WAAW,EACXP,MAAO,OAGT2J,EAAYrO,IAAI,eAAgB,gCAClC,OAAS0E,GACP2J,EAAY3J,MAAM,eAAgB,uBAAwB,CACxDA,QACAgL,MAAOhL,aAAiBpC,MAAQoC,EAAMgL,WAAQ,IAGhD,IAAIrF,EAAe,wBACf3F,aAAiBpC,QAEjB+H,EADE3F,EAAMC,QAAQoD,SAAS,iBACV,sCACNrD,EAAMC,QAAQoD,SAAS,aACjB,4CAEArD,EAAMC,SAIzBG,EAAI,CACFJ,MAAO2F,EACPpF,WAAW,GAEf,GAGF8L,eAAgB9S,MAAO+S,IACrB3C,EAAYrO,IAAI,eAAgB,yBAA0B,CACxDiR,eAAgBD,EAAYvT,SAG9B,MAAMyT,EAAenM,IACrBsJ,EAAYrO,IAAI,eAAgB,qBAAsB,CACpDmR,UAAWD,EAAa3L,KACxB6L,aAAcF,EAAalD,QAC3B4B,gBAAiBsB,EAAatB,kBAGhC9K,EAAI,CAAEG,WAAW,EAAMP,MAAO,OAE9B,IAEE,IAAKsM,GAAeA,EAAYvT,OAAS,EACvC,MAAM,IAAI6E,MAAM,gDAGlB,IAAK4O,EAAa3L,MAAM3I,GACtB,MAAM,IAAI0F,MAAM,+BAGlB+L,EAAYrO,IAAI,eAAgB,sCAE1ByQ,EAAGI,WAAW,SAAS9K,OAAOmL,EAAa3L,KAAK3I,GAAI,CACxDyU,SAAUL,EACVM,gBAAiBN,IAGnB3C,EAAYrO,IAAI,eAAgB,8BAEhC8E,EAAI,CAAEG,WAAW,EAAOP,MAAO,OAE/B2J,EAAYrO,IAAI,eAAgB,iCAClC,OAAS0E,GACP,MAAM2F,EACJ3F,aAAiBpC,MACboC,EAAMC,QACN,oDAUN,MARA0J,EAAY3J,MAAM,eAAgB,wBAAyB,CACzDA,MAAO2F,EACPkH,UAAW7M,GAAO8M,aAAajW,KAC/BmU,MAAOhL,aAAiBpC,MAAQoC,EAAMgL,WAAQ,IAGhD5K,EAAI,CAAEG,WAAW,EAAOP,MAAO2F,IAEzB,IAAI/H,MAAM+H,EAClB,GAGFoH,cAAexT,MAAOZ,IACpB,MAAMkI,KAAEA,GAASR,IAOjB,GALAsJ,EAAYrO,IAAI,eAAgB,wBAAyB,CACvDrE,OAAQ4J,GAAM3I,GACdS,QAASE,OAAOC,KAAKH,KAGlBkI,EAKL,IACE,MAAMmM,EAAa,CACjBnD,SAAUlR,EAAQkR,SAClBG,MAAOrR,EAAQqR,MACfG,SAAUxR,EAAQuR,QAClBE,MAAOzR,EAAQyR,MACfC,KAAM1R,EAAQ0R,KACdI,YAAa9R,EAAQ8R,YACrBD,aAAA,IAAiBvJ,MAAOC,eAG1ByI,EAAYrO,IAAI,eAAgB,+BAAgC0R,SAE1DjB,EAAGI,WAAW,SAAS9K,OAAOR,EAAK3I,GAAI8U,GAE7CrD,EAAYrO,IAAI,eAAgB,6BAChC8E,EAAI,CAAES,KAAM,IAAKA,KAASlI,KAE1BgR,EAAYrO,IAAI,eAAgB,gCAClC,OAAS0E,GACP2J,EAAY3J,MAAM,eAAgB,uBAAwB,CACxDA,QACAgL,MAAOhL,aAAiBpC,MAAQoC,EAAMgL,WAAQ,IAGhD5K,EAAI,CACFJ,MAAOA,aAAiBpC,MAAQoC,EAAMC,QAAU,yBAEpD,MAhCE0J,EAAY5P,KAAK,eAAgB,qCAmCrCwM,WAAY,KACVoD,EAAYrO,IAAI,eAAgB,wBAChC8E,EAAI,CAAEJ,MAAO,QAGfiN,eAAgB1T,UACdoQ,EAAYrO,IAAI,eAAgB,0BAEhC,IACE,GAAIyQ,EAAGC,UAAUkB,SAAWnB,EAAGC,UAAUmB,MAAO,CAC9CxD,EAAYrO,IAAI,eAAgB,0CAA2C,CACzErE,OAAQ8U,EAAGC,UAAUmB,MAAMjV,GAC3B0R,MAAOmC,EAAGC,UAAUmB,MAAMvD,QAG5B,MAAM/I,QAAa2I,sBAAsBuC,EAAGC,UAAUmB,OAEtDxD,EAAYrO,IAAI,eAAgB,mDAChC8E,EAAI,CACFS,OACAyI,QAAS,CACP8D,OAAQrB,EAAGC,UAAUmB,MACrBE,MAAOtB,EAAGC,UAAUqB,OAEtBnC,iBAAiB,GAErB,KAAO,CAELvB,EAAY0B,KAAK,eAAgB,mDACjC,MAAMC,QAAgBC,IAChBG,EAAkB,CACtBxT,GAAIoT,EAAQK,aACZ/B,MAAO,eACPC,SAAUyB,EAAQG,aAAe,MACjCzB,MAAO,EACPE,QAAS,EACTE,MAAO,EACPC,KAAM,EACNrJ,UAAW,IAAIC,KAAKqK,EAAQtK,WAAWE,cACvCqJ,YAAA,IAAgBtJ,MAAOC,cACvBuJ,YAAa,CACXC,MAAO,SACPC,SAAU,KACVC,eAAe,EACfC,cAAc,EACdC,UAAW,GACXC,SAAU,QAGd3K,EAAI,CACFS,KAAM6K,EACNpC,QAAS,KACT4B,iBAAiB,IAEnBhL,EAAaa,WAAWiI,eAAe0C,EAAUxT,IACjDyR,EAAYrO,IAAI,eAAgB,4BAA6B,CAAEqQ,aAAcL,EAAQK,cACvF,CAEAhC,EAAYrO,IAAI,eAAgB,uBAClC,OAAS0E,GACP2J,EAAY3J,MAAM,eAAgB,4BAA6B,CAC7DA,QACAgL,MAAOhL,aAAiBpC,MAAQoC,EAAMgL,WAAQ,IAGhD5K,EAAI,CACFS,KAAM,KACNyI,QAAS,KACT4B,iBAAiB,GAErB,GAIFoC,cAAe/T,MAAOgU,EAAUC,KAC9B,MAAMzY,EAAQ+L,EAAaC,WACrB4K,EAAe5W,EAAM8L,MAAM3I,GACjC,IAAKyT,EAEH,MADAhC,EAAY5P,KAAK,eAAgB,2CAC3B,IAAI6D,MAAM,uBAEZ6P,EAAY,CAChB9B,eACA4B,WACAG,aAAcF,EAAKE,aACnBC,YAAaH,EAAKG,YAClBC,aAAcJ,EAAKI,aACnBC,OAAQL,EAAKK,SAEflE,EAAY0B,KAAK,eAAgB,wBAAyB,CAAEkC,cAG9DO,iBAAkBvU,MAAOgU,IACvB,MAAMxY,EAAQ+L,EAAaC,WACrB4K,EAAe5W,EAAM8L,MAAM3I,GAC5ByT,UACCoC,EAAcpC,EAAc4B,GAClC5D,EAAY0B,KAAK,eAAgB,0BAA2B,CAAEkC,eAGhES,eAAgBzU,MAAOgU,IACrB,MAAMxY,EAAQ+L,EAAaC,WACrB4K,EAAe5W,EAAM8L,MAAM3I,GACjC,QAAKyT,GACEsC,EAAStC,EAAc4B,IAIhCW,MAAO3U,MAAOsS,EAAgBT,KAC5BzB,EAAY0B,KAAK,eAAgB,gDACjC,MAAMC,QAAgBC,IAChBG,EAAkB,CACtBxT,GAAIoT,EAAQK,aACZ/B,MAAO,eACPC,SAAUyB,EAAQG,aAAe,MACjCzB,MAAO,EACPE,QAAS,EACTE,MAAO,EACPC,KAAM,EACNrJ,UAAW,IAAIC,KAAKqK,EAAQtK,WAAWE,cACvCqJ,YAAA,IAAgBtJ,MAAOC,cACvBuJ,YAAa,CACXC,MAAO,SACPC,SAAU,KACVC,eAAe,EACfC,cAAc,EACdC,UAAW,GACXC,SAAU,QAGd3K,EAAI,CAAES,KAAM6K,EAAWpC,QAAS,KAAM4B,iBAAiB,EAAM3K,WAAW,EAAOP,MAAO,QAIxFmO,SAAU5U,MAAOqQ,EAAeC,EAAkBuB,KAChDzB,EAAY0B,KAAK,eAAgB,+DACjC,MAAMC,QAAgBC,UAEhBC,EAAmB,CAAEC,YAAa5B,IACxC,MAAM6B,EAAkB,CACtBxT,GAAIoT,EAAQK,aAEZ/B,MAAOA,GAAS,eAChBC,SAAUA,GAAYyB,EAAQG,aAAe,MAC7CzB,MAAO,EACPE,QAAS,EACTE,MAAO,EACPC,KAAM,EACNrJ,UAAW,IAAIC,KAAKqK,EAAQtK,WAAWE,cACvCqJ,YAAA,IAAgBtJ,MAAOC,cACvBuJ,YAAa,CACXC,MAAO,SACPC,SAAU,KACVC,eAAe,EACfC,cAAc,EACdC,UAAW,GACXC,SAAU,QAGd3K,EAAI,CACFS,KAAM6K,EACNpC,QAAS,KACT4B,iBAAiB,EACjB3K,WAAW,EACXP,MAAO,OAETE,EAAaa,WAAWiI,eAAe0C,EAAUxT,KAGnDkW,OAAQ,KACN,MAAMtC,QAAEA,GAAYzL,IACpByL,KAGFuC,WAAa1V,IACX,MAAMkI,KAAEA,GAASR,IACbQ,GACFT,EAAI,CAAES,KAAM,IAAKA,KAASlI,SAMhCoT,EAAGC,UAAUsC,SAAS,CAACjB,EAAOD,KAC5BzD,EAAY0B,KAAK,eAAgB,6BAA8B,CAC7DkD,WAAYlB,EACZmB,YAAapB,EACbnW,OAAQmW,GAAQlV,GAChBuW,WAAA,IAAexN,MAAOC,gBAGpBmM,GAASD,GACXzD,EAAYrO,IAAI,eAAgB,iDAEhCkO,sBAAsB4D,GAAQrQ,KAAK8D,IACjC8I,EAAYrO,IAAI,eAAgB,0CAChCwF,EAAa4N,SAAS,CACpB7N,OACAyI,QAAS,CAAE8D,SAAQC,SACnBnC,iBAAiB,IAEnBhL,EAAaa,WAAWiI,eAAenI,EAAK3I,MAC3C+P,MAAMjI,IACP2J,EAAY3J,MAAM,eAAgB,4CAA6C,CAC7EA,QACA/I,OAAQmW,EAAOlV,SAInByR,EAAYrO,IAAI,eAAgB,kDAEhCwF,EAAa4N,SAAS,CACpB7N,KAAM,KACNyI,QAAS,KACT4B,iBAAiB,OC7pBhB,MAAMyD,EAAgB/U,IAC3BuG,EACE,CAACC,EAAKC,KAAA,CACJqK,MAAO,SACPkE,YAAa,QAEbC,SAAWnE,IACTtK,EAAI,CAAEsK,UAGN,MAAMkE,YAAEA,GAAgBvO,IAGD,UAFU,WAAVqK,EAAqBkE,EAAclE,GAGxDoE,SAASC,gBAAgBC,UAAUxK,IAAI,QAEvCsK,SAASC,gBAAgBC,UAAUvN,OAAO,SAI9CwN,YAAa,KACX,MAAMvE,MAAEA,GAAUrK,IACZ6O,EAAqB,UAAVxE,EAAoB,OAAS,QAC9CrK,IAAMwO,SAASK,IAGjBC,gBAAiB,KAEf,MAAMP,EAAcQ,OAAOC,WAAW,gCAAgCC,QAClE,OACA,QAEJlP,EAAI,CAAEwO,gBAGNQ,OAAOC,WAAW,gCACfE,iBAAiB,SAAW9Q,IAC3B,MAAM+Q,EAAiB/Q,EAAE6Q,QAAU,OAAS,QAC5ClP,EAAI,CAAEwO,YAAaY,IAGnB,MAAQ9E,SAAUrK,IACJ,WAAVqK,IACqB,SAAnB8E,EACFV,SAASC,gBAAgBC,UAAUxK,IAAI,QAEvCsK,SAASC,gBAAgBC,UAAUvN,OAAO,WAMlD,MAAMiJ,MAAEA,GAAUrK,IAGK,UAFU,WAAVqK,EAAqBkE,EAAclE,GAGxDoE,SAASC,gBAAgBC,UAAUxK,IAAI,QAEvCsK,SAASC,gBAAgBC,UAAUvN,OAAO,WAIhD,CACE5K,KAAM,gBACNqS,WAAanU,IAAA,CAAa2V,MAAO3V,EAAM2V,WCEvC+E,EAAkC,CACtC,CACEvX,GAAI,IACJrB,KAAM,cACNE,YAAa,oCACb2Y,KAAM,KACNvY,SAAU,mBACVwY,aAAc,CAAC,CAAE9a,KAAM,qBAAsB+a,MAAO,EAAGC,SAAU,QACjEC,SAAU,GACVC,WAAY,GACZC,UAAU,EACVC,OAAQ,UAEV,CACE/X,GAAI,IACJrB,KAAM,gBACNE,YAAa,gCACb2Y,KAAM,KACNvY,SAAU,UACVwY,aAAc,CAAC,CAAE9a,KAAM,iBAAkB+a,MAAO,EAAGC,SAAU,QAC7DC,SAAU,IACVC,WAAY,GACZC,UAAU,EACVC,OAAQ,QAEV,CACE/X,GAAI,IACJrB,KAAM,gBACNE,YAAa,0CACb2Y,KAAM,KACNvY,SAAU,WACVwY,aAAc,CACZ,CAAE9a,KAAM,mBAAoB+a,MAAO,IAAKC,SAAU,MAClD,CAAEhb,KAAM,gBAAiB+a,MAAO,GAAIC,SAAU,QAEhDC,SAAU,IACVC,WAAY,GACZC,UAAU,EACVC,OAAQ,QAEV,CACE/X,GAAI,IACJrB,KAAM,cACNE,YAAa,wCACb2Y,KAAM,IACNvY,SAAU,UACVwY,aAAc,CACZ,CAAE9a,KAAM,mBAAoB+a,MAAO,GAAIC,SAAU,OACjD,CAAEhb,KAAM,eAAgB+a,MAAO,IAAKC,SAAU,QAEhDC,SAAU,IACVC,WAAY,GACZC,UAAU,EACVC,OAAQ,QAEV,CACE/X,GAAI,IACJrB,KAAM,UACNE,YAAa,yBACb2Y,KAAM,KACNvY,SAAU,mBACVwY,aAAc,CAAC,CAAE9a,KAAM,cAAe+a,MAAO,IAAMC,SAAU,QAC7DC,SAAU,IACVC,WAAY,IACZC,UAAU,EACVC,OAAQ,QAEV,CACE/X,GAAI,IACJrB,KAAM,SACNE,YAAa,iBACb2Y,KAAM,KACNvY,SAAU,UACVwY,aAAc,CAAC,CAAE9a,KAAM,aAAc+a,MAAO,GAAIC,SAAU,QAC1DC,SAAU,IACVC,WAAY,IACZC,UAAU,EACVC,OAAQ,cAINC,EAA8B,CAClC,CACEhY,GAAI,IACJpB,MAAO,cACPC,YAAa,uBACblC,KAAM,QACN8a,aAAc,CAAC,CAAE9a,KAAM,sBAAuBsb,OAAQ,GAAIpZ,YAAa,mBACvEqZ,QAAS,CACP,CAAEvb,KAAM,KAAMwb,OAAQ,IACtB,CAAExb,KAAM,QAASwb,OAAQ,KAE3BC,WAAA,IAAerP,MAAOC,cACtBqP,QAAS,IAAItP,KAAKA,KAAK2G,MAAQ,OAAqB1G,cACpDsP,UAAU,EACVC,iBAAkB,MAEpB,CACEvY,GAAI,IACJpB,MAAO,iBACPC,YAAa,+BACblC,KAAM,SACN8a,aAAc,CAAC,CAAE9a,KAAM,qBAAsBsb,OAAQ,IAAKpZ,YAAa,8BACvEqZ,QAAS,CACP,CAAEvb,KAAM,KAAMwb,OAAQ,KACtB,CAAExb,KAAM,QAASwb,OAAQ,IACzB,CAAExb,KAAM,OAAQwb,OAAQ,IAE1BC,UAAW,IAAIrP,KAAKA,KAAK2G,MAAQ,QAAyB1G,cAC1DqP,QAAS,IAAItP,KAAKA,KAAK2G,MAAQ,QAAyB1G,cACxDsP,UAAU,EACVC,iBAAkB,KAEpB,CACEvY,GAAI,IACJpB,MAAO,kBACPC,YAAa,wCACblC,KAAM,SACN8a,aAAc,CAAC,CAAE9a,KAAM,oBAAqBsb,OAAQ,EAAGpZ,YAAa,2CACpEqZ,QAAS,CACP,CAAEvb,KAAM,KAAMwb,OAAQ,KACtB,CAAExb,KAAM,QAASwb,OAAQ,IACzB,CAAExb,KAAM,QAAS6b,OAAQ,oBAE3BJ,UAAW,IAAIrP,KAAKA,KAAK2G,MAAQ,QAAyB1G,cAC1DqP,QAAS,IAAItP,KAAKA,KAAK2G,MAAQ,OAAyB1G,cACxDsP,UAAU,EACVC,iBAAkB,MAIhBE,EAAgD,CACpDC,UAAa,CACX1Y,GAAI,YACJrD,KAAM,KACNgc,OAAQ,SACRvR,QAAS,CACP,CAAErI,OAAQ,IAAK4S,SAAU,WAAY/O,MAAO,KAAMgW,KAAM,EAAGC,OAAQ,GACnE,CAAE9Z,OAAQ,IAAK4S,SAAU,cAAe/O,MAAO,KAAMgW,KAAM,EAAGC,OAAQ,GACtE,CAAE9Z,OAAQ,IAAK4S,SAAU,eAAgB/O,MAAO,KAAMgW,KAAM,EAAGC,WAC/D,CAAE9Z,OAAQ,IAAK4S,SAAU,YAAa/O,MAAO,KAAMgW,KAAM,EAAGC,OAAQ,GACpE,CAAE9Z,OAAQ,IAAK4S,SAAU,aAAc/O,MAAO,KAAMgW,KAAM,EAAGC,WAC7D,CAAE9Z,OAAQ,IAAK4S,SAAU,WAAY/O,MAAO,KAAMgW,KAAM,EAAGC,OAAQ,GACnE,CAAE9Z,OAAQ,IAAK4S,SAAU,YAAa/O,MAAO,KAAMgW,KAAM,EAAGC,OAAQ,GACpE,CAAE9Z,OAAQ,IAAK4S,SAAU,aAAc/O,MAAO,KAAMgW,KAAM,EAAGC,WAC7D,CAAE9Z,OAAQ,IAAK4S,SAAU,aAAc/O,MAAO,KAAMgW,KAAM,EAAGC,OAAQ,GACrE,CAAE9Z,OAAQ,KAAM4S,SAAU,cAAe/O,MAAO,KAAMgW,KAAM,GAAIC,QAAQ,IAE1E5P,WAAA,IAAeF,MAAOC,eAExB8P,gBAAmB,CACjB9Y,GAAI,kBACJrD,KAAM,SACNgc,OAAQ,WACRvR,QAAS,CACP,CAAErI,OAAQ,IAAK4S,SAAU,cAAe/O,MAAO,GAAIgW,KAAM,EAAGC,OAAQ,GACpE,CAAE9Z,OAAQ,IAAK4S,SAAU,eAAgB/O,MAAO,GAAIgW,KAAM,EAAGC,OAAQ,GACrE,CAAE9Z,OAAQ,IAAK4S,SAAU,YAAa/O,MAAO,GAAIgW,KAAM,EAAGC,OAAQ,GAClE,CAAE9Z,OAAQ,IAAK4S,SAAU,WAAY/O,MAAO,GAAIgW,KAAM,EAAGC,WACzD,CAAE9Z,OAAQ,IAAK4S,SAAU,aAAc/O,MAAO,GAAIgW,KAAM,EAAGC,OAAQ,GACnE,CAAE9Z,OAAQ,IAAK4S,SAAU,WAAY/O,MAAO,GAAIgW,KAAM,EAAGC,OAAQ,GACjE,CAAE9Z,OAAQ,IAAK4S,SAAU,YAAa/O,MAAO,GAAIgW,KAAM,EAAGC,WAC1D,CAAE9Z,OAAQ,IAAK4S,SAAU,aAAc/O,MAAO,GAAIgW,KAAM,EAAGC,WAC3D,CAAE9Z,OAAQ,IAAK4S,SAAU,aAAc/O,MAAO,GAAIgW,KAAM,EAAGC,OAAQ,GACnE,CAAE9Z,OAAQ,KAAM4S,SAAU,cAAe/O,MAAO,GAAIgW,KAAM,GAAIC,OAAQ,IAExE5P,WAAA,IAAeF,MAAOC,gBAKpB+P,eAAkBC,GACf5a,KAAKwO,MAAMxO,KAAK6a,KAAKD,EAAK,MAAQ,EAIrCE,uBAA0BpH,GACW,IAArB1T,KAAK+a,IAAIrH,EAAO,GAKhCsH,oBAAsB,MAC1B3M,WAAY,EACZ4M,kBAAmB,EACnBC,qBAAsB,EACtBC,sBAAuB,EACvBC,gBAAiB,EACjBhc,eAAgB,EAChBic,eAAgB,EAChBC,kBAAmB,EACnBC,aAAc,EACdC,eAAgB,EAChBC,cAAe,EACfC,cAAe,EACfC,KAAM,EACNC,SAAU,EACVlI,MAAO,EACPkH,GAAI,EACJiB,cAAe,MAIXC,iBAAmB,MACvBzN,WAAY,KACZ4M,kBAAmB,GACnBC,qBAAsB,IACtBC,sBAAuB,IACvBC,gBAAiB,KACjBhc,eAAgB,KAChBic,eAAgB,GAChBC,kBAAmB,IACnBC,aAAc,EACdC,eAAgB,EAChBC,cAAe,GACfC,cAAe,GACfC,KAAM,IACNC,SAAU,GACVlI,MAAO,EACPkH,GAAI,KACJiB,cAAe,OAGJE,EAAuBzY,IAClCuG,EACE,CAACC,EAAKC,KAAA,CACJiS,UAAWhB,sBACXiB,iBAAiB,EACjBC,eAAe,EAEfC,aAAchD,EACdiD,iBAAkB,GAElBC,WAAY,KAEZC,iBAAkB1C,EAClB2C,4BAA6B,GAE7BC,aAAcnC,EAEdoC,gBAAkBC,IAChB5S,EAAKrL,IACH,MAAMke,EAAW,IAAKle,EAAMud,aAAcU,GAQ1C,YALiB,IAAbA,EAAM9B,KACR+B,EAASjJ,MAAQiH,eAAegC,EAAS/B,IACzC+B,EAASd,cAAgBf,uBAAuB6B,EAASjJ,QAGpD,CACLsI,UAAWW,EACXV,iBAAiB,EACjBC,eAAe,MAKrBU,mBAAqBC,IACnB,MAAMT,iBAAEA,GAAqBrS,IACxBqS,EAAiB/Q,QAAWyR,EAAGD,gBAAkBA,IACpD/S,EAAKrL,IAAA,CACH2d,iBAAkB,IACb3d,EAAM2d,iBACT,CACExa,GAAI+I,KAAK2G,MAAMpR,WACfS,OAAQ,IACRkc,gBACAE,UAAA,IAAcpS,MAAOC,oBAO/BoS,aAAeC,IACbnT,EAAKrL,IAAA,CACH4d,WAAY5d,EAAM4d,WAAa,IAAK5d,EAAM4d,cAAeY,GAAW,SAIxEC,cAAgBC,IACd,MAAMZ,4BAAEA,GAAgCxS,IACnCwS,EAA4BlR,QAAU+R,EAAED,cAAgBA,IAC3DrT,EAAKrL,IAAA,CACH8d,4BAA6B,IACxB9d,EAAM8d,4BACT,CACE3a,GAAI+I,KAAK2G,MAAMpR,WACfS,OAAQ,IACRwc,cACAxM,SAAU,GACV0M,WAAW,EACXC,UAAA,IAAc3S,MAAOC,cACrB2S,kBAAmB,GACnBC,eAAgB,GAChB9B,cAAe,EACf+B,SAAU,QAOpBC,wBAAyB,CAACP,EAAaxM,KACrC7G,EAAKrL,IAAA,CACH8d,4BAA6B9d,EAAM8d,4BAA4B7a,IAAI0b,GACjEA,EAAED,cAAgBA,EACd,IAAKC,EAAGzM,SAAU,IAAKyM,EAAEzM,YAAaA,IACtCyM,OAKVO,qBAAuBR,IACrB,MAAMb,iBAAEA,EAAAC,4BAAkBA,GAAgCxS,IACpD6T,EAAYtB,EAAiBjR,KAAKiB,GAAKA,EAAE1K,KAAOub,GAChDU,EAAgBtB,EAA4BlR,KAAK+R,GAAKA,EAAED,cAAgBA,GAE9E,GAAIS,GAAaC,GAAiBA,EAAcR,UAAW,CAEzD,IAAIS,EAAW,EAEXC,EAAe,EAEnBH,EAAU9D,QAAQkE,QAAQC,IACJ,OAAhBA,EAAO1f,MAAiB0f,EAAOlE,OACjC+D,GAAYG,EAAOlE,OACM,UAAhBkE,EAAO1f,MAAoB0f,EAAOlE,SAC3CgE,GAAgBE,EAAOlE,UAK3BjQ,EAAKrL,IAAA,CACHud,UAAW,IACNvd,EAAMud,UACT3N,WAAY5P,EAAMud,UAAU3N,WAAayP,EAAW,IAGtDvB,4BAA6B9d,EAAM8d,4BAA4B1a,OAC7Dub,GAAKA,EAAED,cAAgBA,KAG7B,GAGFe,mBAAoB,KAElBpU,EAAI,CACFkS,UAAWF,mBACXK,aAAchD,EACdmD,iBAAkB1C,EAClB4C,aAAcnC,EACd+B,iBAAkB,CAChB,CACExa,GAAI,IACJjB,OAAQ,IACRkc,cAAe,IACfE,SAAU,IAAIpS,KAAKA,KAAK2G,MAAQ,OAA0B1G,eAE5D,CACEhJ,GAAI,IACJjB,OAAQ,IACRkc,cAAe,IACfE,SAAU,IAAIpS,KAAKA,KAAK2G,MAAQ,OAAyB1G,gBAG7DyR,WAAY,CACVza,GAAI,IACJjB,OAAQ,IACR+a,cAAe,GACfD,cAAe,GACf0C,eAAA,IAAmBxT,MAAOC,cAC1BwT,YAAa,EACb1T,UAAW,IAAIC,KAAKA,KAAK2G,MAAQ,QAA0B1G,eAE7D2R,4BAA6B,CAC3B,CACE3a,GAAI,IACJjB,OAAQ,IACRwc,YAAa,IACbxM,SAAU,CAAE0N,oBAAqB,IACjChB,WAAW,EACXC,UAAA,IAAc3S,MAAOC,cACrB0T,aAAA,IAAiB3T,MAAOC,cACxB2S,kBAAmB,CAAEgB,aAAe,GACpCf,eAAgB,GAChB9B,cAAe,EACf+B,SAAU,GAEZ,CACE7b,GAAI,IACJjB,OAAQ,IACRwc,YAAa,IACbxM,SAAU,CAAE6N,mBAAoB,KAChCnB,WAAW,EACXC,SAAU,IAAI3S,KAAKA,KAAK2G,MAAQ,QAAyB1G,cACzD2S,kBAAmB,CAAEgB,aAAe,EAAME,aAAe,GACzDjB,eAAgB,CACd,CACEkB,KAAM,EACN1E,UAAW,IAAIrP,KAAKA,KAAK2G,MAAQ,QAAyB1G,cAC1DqP,SAAA,IAAatP,MAAOC,cACpB+F,SAAU,CAAE6N,mBAAoB,KAChCnB,WAAW,EACXiB,aAAA,IAAiB3T,MAAOC,cACxB+T,eAAe,IAGnBjD,cAAe,EACf+B,SAAU,IAGdxB,iBAAiB,EACjBC,eAAe,KAInB0C,kBAAmB,KAEjB9U,EAAI,CACFkS,UAAWhB,sBACXoB,iBAAkB,GAClBC,WAAY,KACZE,4BAA6B,GAC7BN,iBAAiB,EACjBC,eAAe,KAInB2C,iBAAkB,KAEhB/U,EAAI,CACFkS,UAAWhB,sBACXoB,iBAAkB,GAClBC,WAAY,KACZE,4BAA6B,GAC7BN,iBAAiB,EACjBC,eAAe,KAInB4C,YAAa,CAACnD,EAAMC,KAClB9R,EAAKrL,IAAA,CACHud,UAAW,IACNvd,EAAMud,UACTL,KAAMld,EAAMud,UAAUL,KAAOA,EAC7BC,SAAUnd,EAAMud,UAAUJ,SAAWA,OAK3CmD,cAAe,CAACpD,EAAMC,KACpB,MAAMI,UAAEA,GAAcjS,IACtB,OAAIiS,EAAUL,MAAQA,GAAQK,EAAUJ,UAAYA,IAClD9R,EAAKrL,IAAA,CACHud,UAAW,IACNvd,EAAMud,UACTL,KAAMld,EAAMud,UAAUL,KAAOA,EAC7BC,SAAUnd,EAAMud,UAAUJ,SAAWA,OAGlC,IAMXoD,mBAAoB,CAACC,GAAkB,KACvBlV,IAGHmS,eAGPpS,EAFEmV,EAEE,CACFjD,UAAWF,mBACXK,aAAchD,EACdmD,iBAAkB1C,EAClB4C,aAAcnC,EACd+B,iBAAkB,CAChB,CACExa,GAAI,IACJjB,OAAQ,IACRkc,cAAe,IACfE,SAAU,IAAIpS,KAAKA,KAAK2G,MAAQ,OAA0B1G,eAE5D,CACEhJ,GAAI,IACJjB,OAAQ,IACRkc,cAAe,IACfE,SAAU,IAAIpS,KAAKA,KAAK2G,MAAQ,OAAyB1G,gBAG7DyR,WAAY,CACVza,GAAI,IACJjB,OAAQ,IACR+a,cAAe,GACfD,cAAe,GACf0C,eAAA,IAAmBxT,MAAOC,cAC1BwT,YAAa,EACb1T,UAAW,IAAIC,KAAKA,KAAK2G,MAAQ,QAA0B1G,eAE7D2R,4BAA6B,CAC3B,CACE3a,GAAI,IACJjB,OAAQ,IACRwc,YAAa,IACbxM,SAAU,CAAE0N,oBAAqB,IACjChB,WAAW,EACXC,UAAA,IAAc3S,MAAOC,cACrB0T,aAAA,IAAiB3T,MAAOC,eAE1B,CACEhJ,GAAI,IACJjB,OAAQ,IACRwc,YAAa,IACbxM,SAAU,CAAE6N,mBAAoB,KAChCnB,WAAW,EACXC,SAAU,IAAI3S,KAAKA,KAAK2G,MAAQ,QAAyB1G,gBAG7DqR,iBAAiB,EACjBC,eAAe,GAIb,CACFF,UAAWhB,sBACXoB,iBAAkB,GAClBC,WAAY,KACZE,4BAA6B,GAC7BN,iBAAiB,EACjBC,eAAe,KAOvBgD,wBAAyB,CAAC/B,EAAagC,EAAa9B,KAClDvT,EAAKrL,IAAA,CACH8d,4BAA6B9d,EAAM8d,4BAA4B7a,IAAI0b,GACjEA,EAAED,cAAgBA,EACd,IACKC,EACHG,kBAAmB,IACdH,EAAEG,kBACL4B,CAACA,GAAc9B,IAGnBD,OAKVgC,qBAAsB,CAACjC,EAAakC,KAClCvV,EAAKrL,IAAA,CACH8d,4BAA6B9d,EAAM8d,4BAA4B7a,IAAI0b,GACjEA,EAAED,cAAgBA,EACd,IACKC,EACHI,eAAgBJ,EAAEI,eACd,IAAIJ,EAAEI,eAAe3b,OAAOyd,GAAKA,EAAEZ,OAASW,EAASX,MAAOW,GAC5D,CAACA,IAEPjC,OAKVmC,sBAAuB,CAACpC,EAAaF,KACnCnT,EAAKrL,IAAA,CACH8d,4BAA6B9d,EAAM8d,4BAA4B7a,IAAI0b,GACjEA,EAAED,cAAgBA,EACd,IAAKC,EAAG1B,cAAeuB,GACvBG,OAKVoC,mBAAoB,CAACrC,EAAauB,KAChC5U,EAAKrL,IAAA,CACH8d,4BAA6B9d,EAAM8d,4BAA4B7a,IAAI0b,GACjEA,EAAED,cAAgBA,EACd,IACKC,EACHI,eAAgBJ,EAAEI,gBAAgB9b,IAAI4d,GACpCA,EAAEZ,OAASA,EACP,IAAKY,EAAGX,eAAe,GACvBW,IACD,IAEPlC,OAKVqC,qBAAsB,CAACtC,EAAagC,KAElC,MAAM7C,iBAAEA,GAAqBvS,IACXuS,EAAiBjR,KAAKiB,GAAKA,EAAE1K,KAAOub,IAKpDrT,EAAKrL,IAAA,CACH8d,4BAA6B9d,EAAM8d,4BAA4B7a,IAAI0b,GACjEA,EAAED,cAAgBA,EACd,IACKC,EACHG,kBAAmB,IACdH,EAAEG,kBACL,CAAC,GAAG4B,cAAwB,IAGhC/B,OAMZsC,0BAA2B,CAACC,EAAQC,KAIlCpc,QAAQwB,IAAI,gBAAgB4a,uBAAkCD,KAG9D7V,EAAKrL,IAAA,CACHud,UAAW,IACNvd,EAAMud,eAMf6D,aAAc,CAACC,EAAcC,KAM3B,IAAIjC,EAAWgC,EACfhC,GAAYiC,EAGZ,MAAMC,EAAmD,GAAlChgB,KAAKwO,MAAMuR,EAAiB,IACnDjC,GAAYkC,EAERlC,EAAW,GACbhU,EAAKrL,IACH,MAAMwhB,EAAQxhB,EAAMud,UAAUpB,GAAKkD,EAC7BoC,EAAWvF,eAAesF,GAC1BE,EAAmBrF,uBAAuBoF,GAKhD,OAHA1c,QAAQwB,IAAI,mBAAmB8Y,SAAgBgC,YAAuBC,cAA2BC,sBACjGxc,QAAQwB,IAAI,gBAAgBvG,EAAMud,UAAUpB,QAAQqF,YAAgBxhB,EAAMud,UAAUtI,WAAWwM,MAExF,CACLlE,UAAW,IACNvd,EAAMud,UACTpB,GAAIqF,EACJvM,MAAOwM,EACPrE,cAAesE,EACf9R,WAAY5P,EAAMud,UAAU3N,WAAayR,EACzC7E,kBAAmBxc,EAAMud,UAAUf,kBAAoB6E,SAOnE,CACEvf,KAAM,uBACNqS,WAAanU,IAAA,CACXud,UAAWvd,EAAMud,UACjBI,iBAAkB3d,EAAM2d,iBACxBC,WAAY5d,EAAM4d,WAClBE,4BAA6B9d,EAAM8d,4BACnCN,gBAAiBxd,EAAMwd,gBACvBC,cAAezd,EAAMyd","names":["createNewCard","frontContent","backContent","cardType","type","mediaRefs","state","queue","due","ivl","factor","reps","lapses","left","learningStep","graduationInterval","easyInterval","totalStudyTime","averageAnswerTime","flags","originalDue","originalDeck","xpAwarded","difficultyRating","uuid","anyCrypto","globalThis","crypto","randomUUID","Math","random","toString","slice","buildNewDeckFromDomain","deck","deckId","name","title","description","meta","userId","tags","category","settings","advancedSettings","isPublic","buildNewCardFromDomain","input","normalizedState","Set","has","cardId","fields","front","back","map","m","id","filter","Boolean","ease","easeFactor","interval","intervalDays","dueAt","mapDeckUpdatesToRepo","updates","result","Object","keys","length","defaultDeckSettings","newCardsPerDay","maxReviewsPerDay","easyBonus","intervalModifier","maximumInterval","minimumInterval","async","persistCreateDeck","deckData","repos","decks","create","err","console","warn","persistAddCard","card","cards","cleanFieldContent","content","replace","trim","extractPlainText","detectBestFieldCombination","sampleFields","frontIndex","backIndex","fieldCount","combinations","score","validPairs","match","normalizedScore","push","sort","a","b","log","getMimeTypeFromFilename","filename","jpg","jpeg","png","gif","svg","mp3","wav","ogg","mp4","webm","toLowerCase","split","pop","parseApkgFile","file","default","JSZip","initSqlJs","Promise","all","__vitePreload","import","then","n","j","__VITE_PRELOAD__","s","SQL","locateFile","endsWith","arrayBuffer","zip","zipContent","loadAsync","dbFile","Error","dbArrayBuffer","db","Database","Uint8Array","deckQuery","exec","deckName","values","decksJson","JSON","parse","deckIds","e","notesQuery","sampleSize","min","i","row","max","close","mediaFiles","mediaMapFile","mediaMap","mediaMapText","zipEntry","entries","files","dir","isNumericMedia","test","hasMediaExt","blob","originalFilename","data","size","error","message","useDeckStore","persist","set","get","currentStudySession","isLoading","importProgress","importStatus","hydrated","currentUserId","createDeck","user","useAuthStore","getState","createdAt","Date","toISOString","updatedAt","updateDeck","update","deleteDeck","_deletedCards","remainingCards","remove","getDeck","find","addCard","cardData","nextReview","reviewCount","lapseCount","updatedCards","cardCount","addCardBulk","existingCards","cardKey","some","createDeckBulk","addCardsBatch","cardsData","existingCardSet","uniqueCardsData","c","updateCard","newCards","deleteCard","affectedDeckId","findIndex","deleteCardsBatch","cardIds","updatedDeckCards","includes","getCards","importAnkiDeck","setImportProgress","resetImportProgress","fileName","d","mediaContextService","getMediaContextService","storedMediaFiles","mediaFile","mimeType","mediaHash","mediaStorage","storeBlob","buildMappingsFromImport","urlMappings","uniqueCards","seenCards","add","batchSize","successfulImports","totalCards","batch","batchCards","floor","ceil","cardProgress","toFixed","resolve","setTimeout","cardError","originalCard","individualError","text","separator","cleanText","importFromText","errorMessage","lines","line","validCards","skippedLines","parts","part","uniqueValidCards","addedCards","loadExampleDecks","existingTitles","exampleDecks","clearError","setLoading","loading","removeDuplicateCards","deckCards","uniqueCardsMap","Map","duplicatesRemoved","Array","from","progress","status","hydrateFromIndexedDB","deckRows","list","cardsByDeck","listByDeck","r","nowIso","createdIso","dueDay","now","String","deckUserId","updatedMeta","existing","catch","startStudySession","studyCards","studyCardIds","currentCardIndex","sessionStats","total","correct","incorrect","startedAt","updateStudySession","clearStudySession","getStudySession","resetAllStudyData","resetCards","setCurrentUser","getUserDecks","partialize","restOfState","useCurrentCard","store","session","currentCardId","convertPocketbaseUser","pocketbaseUser","rec","debugLogger","email","username","baseName","convertedUser","level","Number","totalXp","total_xp","coins","gems","created","lastActive","last_active","preferences","theme","language","notifications","soundEffects","dailyGoal","timezone","stack","fallbackUser","isAuthenticated","signUp","_password","info","profile","ensureLocalProfile","updateLocalProfile","displayName","localUser","deviceUserId","signIn","_email","signOut","pb","authStore","clear","resetPassword","collection","requestPasswordReset","updatePassword","newPassword","passwordLength","currentState","hasUser","hasSession","password","passwordConfirm","errorType","constructor","updateProfile","updateData","initializeAuth","isValid","model","record","token","connectOnline","provider","link","linkAccount","serverUserId","accessToken","refreshToken","scopes","disconnectOnline","unlinkAccount","isOnlineLinked","isLinked","login","register","logout","updateUser","onChange","hasToken","hasRecord","timestamp","setState","useThemeStore","systemTheme","setTheme","document","documentElement","classList","toggleTheme","newTheme","initializeTheme","window","matchMedia","matches","addEventListener","newSystemTheme","mockAchievements","icon","requirements","value","operator","xpReward","coinReward","isSecret","rarity","mockChallenges","target","rewards","amount","startDate","endDate","isActive","participantCount","itemId","mockLeaderboards","xp_weekly","period","rank","change","streak_all_time","calculateLevel","xp","sqrt","calculateXPToNextLevel","pow","getInitialUserStats","cardsStudiedToday","cardsStudiedThisWeek","cardsStudiedThisMonth","averageAccuracy","studyTimeToday","studyTimeThisWeek","decksCreated","decksCompleted","longestStreak","currentStreak","gold","diamonds","xpToNextLevel","getDemoUserStats","useGamificationStore","userStats","isFirstTimeUser","isInitialized","achievements","userAchievements","userStreak","activeChallenges","userChallengeParticipations","leaderboards","updateUserStats","stats","newStats","addUserAchievement","achievementId","ua","earnedAt","updateStreak","streak","joinChallenge","challengeId","p","completed","joinedAt","milestoneProgress","weeklyProgress","bestWeek","updateChallengeProgress","claimChallengeReward","challenge","participation","xpGained","_coinsGained","forEach","reward","initializeMockData","lastStudyDate","freezeCount","cards_studied_today","completedAt","milestone_1","cards_studied_week","milestone_2","week","storyUnlocked","initializeNewUser","resetAllUserData","addCurrency","spendCurrency","initializeUserData","isDemo","updateMilestoneProgress","milestoneId","updateWeeklyProgress","weekData","w","updateChallengeStreak","unlockStoryChapter","claimMilestoneReward","contributeToCommunityGoal","goalId","contribution","awardStudyXP","cardsStudied","correctAnswers","milestoneBonus","newXP","newLevel","newXPToNextLevel"],"ignoreList":[],"sources":["../../src/utils/cardDefaults.ts","../../src/data/mappers/domainMappers.ts","../../src/stores/deckStore.ts","../../src/stores/authStore.ts","../../src/stores/themeStore.ts","../../src/stores/gamificationStore.ts"],"sourcesContent":["import { Card, CardType, MediaReference } from '../../../shared/types'\r\n\r\n/**\r\n * Create a new card with all required Anki-style fields populated with defaults\r\n */\r\nexport function createNewCard(\r\n  frontContent: string,\r\n  backContent: string,\r\n  cardType: CardType = { type: 'basic' },\r\n  mediaRefs: MediaReference[] = []\r\n): Omit<Card, 'id' | 'createdAt' | 'deckId' | 'easeFactor' | 'intervalDays' | 'nextReview' | 'reviewCount' | 'lapseCount'> {\r\n  return {\r\n    frontContent,\r\n    backContent,\r\n    cardType,\r\n    mediaRefs,\r\n    \r\n    // Enhanced Anki-style fields with defaults\r\n    state: 'new',\r\n    queue: 0, // 0 = new\r\n    due: 0, // New cards have no due date\r\n    ivl: 0, // No interval yet\r\n    factor: 2500, // Default ease factor (250%)\r\n    reps: 0, // No repetitions yet\r\n    lapses: 0, // No lapses yet\r\n    left: 0, // No learning time left\r\n    \r\n    // Learning state defaults\r\n    learningStep: 0,\r\n    graduationInterval: 1, // Default 1 day\r\n    easyInterval: 4, // Default 4 days\r\n    \r\n    // Timing and performance defaults\r\n    totalStudyTime: 0,\r\n    averageAnswerTime: 0,\r\n    \r\n    // Metadata defaults\r\n    flags: 0,\r\n    originalDue: 0,\r\n    originalDeck: '', // Will be set when card is created\r\n    \r\n    // Gamification defaults\r\n    xpAwarded: 0,\r\n    difficultyRating: 3 // Default medium difficulty\r\n  }\r\n}\r\n\r\n/**\r\n * Create a complete card object for SVG map cards\r\n */\r\nexport function createSvgMapCard(\r\n  id: string,\r\n  deckId: string,\r\n  frontContent: string,\r\n  backContent: string,\r\n  cardType: CardType,\r\n  mediaRefs: MediaReference[] = []\r\n): Card {\r\n  const baseCard = createNewCard(frontContent, backContent, cardType, mediaRefs)\r\n  \r\n  return {\r\n    ...baseCard,\r\n    id,\r\n    deckId,\r\n    createdAt: new Date().toISOString(),\r\n    \r\n    // Legacy fields for backward compatibility\r\n    easeFactor: 2.5,\r\n    intervalDays: 0,\r\n    nextReview: new Date().toISOString(),\r\n    reviewCount: 0,\r\n    lapseCount: 0,\r\n    \r\n    // Set original deck\r\n    originalDeck: deckId\r\n  }\r\n}","/**\r\n * Domain <-> Repository mappers\r\n * Map shared domain types (Deck/Card) to repository DTOs and vice versa.\r\n */\r\n\r\nimport type { Deck, Card } from '@shared/types';\r\nimport type { NewDeck, NewCard, UpdateDeck } from '../repositories';\r\n\r\nfunction uuid(): string {\r\n  try {\r\n    const anyCrypto = (globalThis as any).crypto;\r\n    if (anyCrypto && typeof anyCrypto.randomUUID === 'function') {\r\n      return anyCrypto.randomUUID();\r\n    }\r\n  } catch {}\r\n  // Fallback\r\n  return 'id_' + Math.random().toString(36).slice(2, 10);\r\n}\r\n\r\n/**\r\n * Build repository NewDeck payload from domain Deck inputs (without id/timestamps).\r\n */\r\nexport function buildNewDeckFromDomain(deck: Omit<Deck, 'id' | 'createdAt' | 'updatedAt'>): NewDeck {\r\n  return {\r\n    deckId: uuid(),\r\n    name: deck.title,\r\n    description: deck.description,\r\n    meta: {\r\n      userId: deck.userId,\r\n      tags: deck.tags ?? [],\r\n      category: deck.category ?? null,\r\n      settings: deck.settings ?? null,\r\n      advancedSettings: deck.advancedSettings ?? null,\r\n      isPublic: deck.isPublic ?? false,\r\n    },\r\n  };\r\n}\r\n\r\n/**\r\n * Build repository NewCard payload from a domain Card-like shape.\r\n * Note: media hashing/dedup is handled elsewhere; we only propagate known references.\r\n */\r\nexport function buildNewCardFromDomain(input: {\r\n  deckId: string;\r\n  frontContent: string;\r\n  backContent: string;\r\n  // Optional hints to carry over to repo layer:\r\n  mediaRefs?: Card['mediaRefs'];\r\n  state?: Card['state'];\r\n  easeFactor?: number;\r\n  intervalDays?: number;\r\n}): NewCard {\r\n  const allowed = new Set(['new', 'learning', 'review', 'relearning'] as const);\r\n  const normalizedState =\r\n    allowed.has(input.state as any)\r\n      ? (input.state as 'new' | 'learning' | 'review' | 'relearning')\r\n      : 'new';\r\n\r\n  return {\r\n    cardId: uuid(),\r\n    deckId: input.deckId,\r\n    fields: {\r\n      front: input.frontContent,\r\n      back: input.backContent,\r\n    },\r\n    // If we don't have media hashes yet, we leave refs empty; upstream pipeline can attach later.\r\n    mediaRefs: (input.mediaRefs ?? []).map((m) => m.id).filter(Boolean),\r\n    state: normalizedState,\r\n    ease: input.easeFactor ?? 250,\r\n    interval: input.intervalDays ?? 0,\r\n    dueAt: null,\r\n    lapses: 0,\r\n  };\r\n}\r\n\r\n/**\r\n * Map domain Deck partial updates to repository UpdateDeck.\r\n */\r\nexport function mapDeckUpdatesToRepo(updates: Partial<Deck>): UpdateDeck {\r\n  const result: UpdateDeck = {};\r\n  if (typeof updates.title === 'string') result.name = updates.title;\r\n  if (typeof updates.description === 'string') result.description = updates.description;\r\n  const meta: Record<string, unknown> = {};\r\n  if (updates.tags) meta.tags = updates.tags;\r\n  if (updates.category) meta.category = updates.category;\r\n  if (updates.settings) meta.settings = updates.settings;\r\n  if (updates.advancedSettings) meta.advancedSettings = updates.advancedSettings;\r\n  if (Object.keys(meta).length) result.meta = meta;\r\n  return result;\r\n}","import { create } from 'zustand'\nimport { persist } from 'zustand/middleware'\nimport type { Deck, Card, DeckSettings } from '../../../shared/types'\nimport { createNewCard } from '../utils/cardDefaults'\n\nimport { repos } from '../data'\nimport { buildNewDeckFromDomain, buildNewCardFromDomain, mapDeckUpdatesToRepo } from '../data/mappers/domainMappers'\nimport { useAuthStore } from './authStore'\nimport { mediaStorage } from '../services/mediaStorageService'\nimport { getMediaContextService } from '../services/anki/MediaContextService'\ninterface StudySession {\n  deckId: string\n  currentCardIndex: number\n  studyCards: Card[] // For in-memory access during a session\n  studyCardIds: string[] // For persistence\n  sessionStats: {\n    total: number\n    correct: number\n    incorrect: number\n  }\n  startedAt: string\n}\n\ninterface DeckStore {\n  decks: Deck[]\n  cards: Record<string, Card[]> // deckId -> cards\n  currentStudySession: StudySession | null\n  isLoading: boolean\n  error: string | null\n  importProgress: number // 0-100\n  importStatus: string | null\n  hydrated: boolean\n  currentUserId: string | null\n  \n  // Deck operations\n  createDeck: (deck: Omit<Deck, 'id' | 'createdAt' | 'updatedAt'>) => Promise<Deck>\n  updateDeck: (id: string, updates: Partial<Deck>) => Promise<void>\n  deleteDeck: (id: string) => Promise<void>\n  getDeck: (id: string) => Deck | undefined\n  \n  // Card operations\n  addCard: (deckId: string, card: Omit<Card, 'id' | 'deckId' | 'createdAt' | 'easeFactor' | 'intervalDays' | 'nextReview' | 'reviewCount' | 'lapseCount'>) => Promise<Card>\n  addCardBulk: (deckId: string, card: Omit<Card, 'id' | 'deckId' | 'createdAt' | 'easeFactor' | 'intervalDays' | 'nextReview' | 'reviewCount' | 'lapseCount'>) => Promise<Card>\n  addCardsBatch: (deckId: string, cards: Array<Omit<Card, 'id' | 'deckId' | 'createdAt' | 'easeFactor' | 'intervalDays' | 'nextReview' | 'reviewCount' | 'lapseCount'>>) => Promise<Card[]>\n  createDeckBulk: (deck: Omit<Deck, 'id' | 'createdAt' | 'updatedAt'>) => Promise<Deck>\n  updateCard: (cardId: string, updates: Partial<Card>) => Promise<void>\n  deleteCard: (cardId: string) => Promise<void>\n  deleteCardsBatch: (deckId: string, cardIds: string[]) => Promise<void>\n  getCards: (deckId: string) => Card[]\n  \n  // Import operations\n  importAnkiDeck: (file: File) => Promise<Deck>\n  importFromText: (deckName: string, text: string, separator?: string) => Promise<Deck>\n  \n  // Example data\n  loadExampleDecks: () => Promise<void>\n  hydrateFromIndexedDB: () => Promise<void>\n  \n  // Utility\n  clearError: () => void\n  setLoading: (loading: boolean) => void\n  setImportProgress: (progress: number, status?: string) => void\n  resetImportProgress: () => void\n  removeDuplicateCards: (deckId: string) => Promise<number>\n  setCurrentUser: (userId: string | null) => void\n  getUserDecks: () => Deck[]\n  \n  // Study session functions\n  startStudySession: (deckId: string, studyCards: Card[]) => void\n  updateStudySession: (currentCardIndex: number, sessionStats: StudySession['sessionStats']) => void\n  clearStudySession: () => void\n  getStudySession: (deckId: string) => StudySession | null\n  resetAllStudyData: () => void\n}\n\nconst defaultDeckSettings: DeckSettings = {\n  newCardsPerDay: 20,\n  maxReviewsPerDay: 100,\n  easyBonus: 1.3,\n  intervalModifier: 1.0,\n  maximumInterval: 36500, // 100 years\n  minimumInterval: 1\n};\n\n// Offline-first persistence helpers (IndexedDB via repositories)\nasync function persistCreateDeck(deckData: Omit<Deck, 'id' | 'createdAt' | 'updatedAt'>) {\n  try {\n    await repos.decks.create(buildNewDeckFromDomain(deckData));\n  } catch (err) {\n    // Non-blocking persistence; UI state remains responsive\n    console.warn('[deckStore] repo createDeck failed', err);\n  }\n}\n\nasync function persistAddCard(deckId: string, card: Card) {\n  try {\n    await repos.cards.create(\n      buildNewCardFromDomain({\n        deckId,\n        frontContent: card.frontContent,\n        backContent: card.backContent,\n        mediaRefs: card.mediaRefs,\n        state: card.state,\n        easeFactor: card.easeFactor,\n        intervalDays: card.intervalDays,\n      })\n    );\n  } catch (err) {\n    console.warn('[deckStore] repo addCard failed', err);\n  }\n}\n\n// Helper function to clean field content (preserve HTML for media rendering)\nconst cleanFieldContent = (content: string): string => {\n  return content\n    .replace(/&nbsp;/g, ' ')\n    .replace(/&lt;/g, '<')\n    .replace(/&gt;/g, '>')\n    .replace(/&amp;/g, '&')\n    .trim()\n}\n\n// Helper to extract plain text for detection (no HTML)\nconst extractPlainText = (content: string): string => {\n  return content\n    .replace(/<[^>]*>/g, '')\n    .replace(/\\[sound:[^\\]]*\\]/g, '')\n    .replace(/&nbsp;/g, ' ')\n    .replace(/&lt;/g, '<')\n    .replace(/&gt;/g, '>')\n    .replace(/&amp;/g, '&')\n    .trim()\n}\n\n// Helper function to detect the best field combination for front/back\nconst detectBestFieldCombination = (sampleFields: string[][]): { frontIndex: number; backIndex: number } => {\n  if (sampleFields.length === 0) {\n    return { frontIndex: 0, backIndex: 1 }\n  }\n  \n  const fieldCount = sampleFields[0].length\n  const combinations: Array<{ frontIndex: number; backIndex: number; score: number }> = []\n  \n  // Try different field combinations\n  for (let front = 0; front < fieldCount; front++) {\n    for (let back = front + 1; back < fieldCount; back++) {\n      let score = 0\n      let validPairs = 0\n      \n      for (const fields of sampleFields) {\n        const frontContent = extractPlainText(fields[front] || '')\n        const backContent = extractPlainText(fields[back] || '')\n        \n        // Score based on content quality\n        if (frontContent && backContent) {\n          validPairs++\n          \n          // Prefer combinations where both fields have substantial content\n          if (frontContent.length > 2 && backContent.length > 2) {\n            score += 10\n          }\n          \n          // Prefer combinations where fields are different\n          if (frontContent !== backContent) {\n            score += 5\n          }\n          \n          // Avoid fields that look like audio references or numbers only\n          if (!frontContent.match(/^\\[sound:/) && !backContent.match(/^\\[sound:/)) {\n            score += 3\n          }\n          \n          if (!frontContent.match(/^\\d+$/) && !backContent.match(/^\\d+$/)) {\n            score += 2\n          }\n        }\n      }\n      \n      // Normalize score by number of valid pairs\n      const normalizedScore = validPairs > 0 ? score / validPairs : 0\n      combinations.push({ frontIndex: front, backIndex: back, score: normalizedScore })\n    }\n  }\n  \n  // Sort by score and return the best combination\n  combinations.sort((a, b) => b.score - a.score)\n  \n  if (combinations.length > 0 && combinations[0].score > 0) {\n    console.log(`Best field combination: ${combinations[0].frontIndex} -> ${combinations[0].backIndex} (score: ${combinations[0].score})`)\n    return { frontIndex: combinations[0].frontIndex, backIndex: combinations[0].backIndex }\n  }\n  \n  // Fallback to 0->1 or 0->2 if available\n  if (fieldCount >= 3) {\n    return { frontIndex: 0, backIndex: 2 }\n  }\n  return { frontIndex: 0, backIndex: 1 }\n}\n\n// Helper function to parse .apkg files (with dynamic imports for bundle optimization)\ninterface MediaFile {\n  filename: string\n  data: Blob\n}\n\n// Helper to determine MIME type from filename extension\nconst getMimeTypeFromFilename = (filename: string): string => {\n  const ext = filename.toLowerCase().split('.').pop() || ''\n  const mimeTypes: Record<string, string> = {\n    'jpg': 'image/jpeg',\n    'jpeg': 'image/jpeg',\n    'png': 'image/png',\n    'gif': 'image/gif',\n    'svg': 'image/svg+xml',\n    'mp3': 'audio/mpeg',\n    'wav': 'audio/wav',\n    'ogg': 'audio/ogg',\n    'mp4': 'video/mp4',\n    'webm': 'video/webm'\n  }\n  return mimeTypes[ext] || 'application/octet-stream'\n}\n\nconst parseApkgFile = async (file: File): Promise<{\n  name: string\n  cards: Array<{ front: string; back: string }>\n  mediaFiles: MediaFile[]\n}> => {\n  try {\n    // Dynamic imports to reduce initial bundle size\n    const [{ default: JSZip }, { default: initSqlJs }] = await Promise.all([\n      import('jszip'),\n      import('sql.js')\n    ])\n\n    // Initialize SQL.js\n    const SQL = await initSqlJs({\n      locateFile: (file) => {\n        if (file.endsWith('.wasm')) {\n          return '/sql-wasm.wasm'\n        }\n        return `/${file}`\n      }\n    })\n\n    // Read the .apkg file as array buffer\n    const arrayBuffer = await file.arrayBuffer()\n    \n    // Extract the ZIP file\n    const zip = new JSZip()\n    const zipContent = await zip.loadAsync(arrayBuffer)\n    \n    // Get the collection.anki2 file (SQLite database)\n    const dbFile = zipContent.file('collection.anki2')\n    if (!dbFile) {\n      throw new Error('Invalid .apkg file: collection.anki2 not found')\n    }\n    \n    // Read the database file\n    const dbArrayBuffer = await dbFile.async('arraybuffer')\n    const db = new SQL.Database(new Uint8Array(dbArrayBuffer))\n    \n    // Query to get deck name from the col table\n    const deckQuery = db.exec(\"SELECT decks FROM col LIMIT 1\")\n    let deckName = file.name.replace(/\\.apkg$/, '')\n    if (deckQuery.length > 0 && deckQuery[0].values.length > 0) {\n      try {\n        const decksJson = deckQuery[0].values[0][0] as string\n        const decks = JSON.parse(decksJson)\n        // Find the first non-default deck (id != 1)\n        const deckIds = Object.keys(decks).filter(id => id !== '1')\n        if (deckIds.length > 0) {\n          deckName = decks[deckIds[0]].name || deckName\n        }\n      } catch (e) {\n        console.warn('Could not parse deck names from .apkg file, using filename')\n      }\n    }\n    \n    // Query to get notes and cards\n    const notesQuery = db.exec(`\n      SELECT n.flds, n.tags, c.type\n      FROM notes n\n      JOIN cards c ON n.id = c.nid\n      WHERE c.type >= 0\n      ORDER BY n.id\n    `)\n    \n    const cards: Array<{ front: string; back: string }> = []\n    \n    if (notesQuery.length > 0) {\n      // First, analyze a sample of fields to determine the best field combination\n      const sampleSize = Math.min(10, notesQuery[0].values.length)\n      const sampleFields: string[][] = []\n      \n      for (let i = 0; i < sampleSize; i++) {\n        const fields = (notesQuery[0].values[i][0] as string).split('\\x1f')\n        sampleFields.push(fields)\n      }\n      \n      // Detect the best field combination\n      const { frontIndex, backIndex } = detectBestFieldCombination(sampleFields)\n      console.log(`Using field combination: ${frontIndex} (front) -> ${backIndex} (back)`)\n      \n      // Process all cards using the detected field combination\n      for (const row of notesQuery[0].values) {\n        const fields = (row[0] as string).split('\\x1f') // Anki uses \\x1f as field separator\n        \n        if (fields.length > Math.max(frontIndex, backIndex)) {\n          const front = cleanFieldContent(fields[frontIndex] || '')\n          const back = cleanFieldContent(fields[backIndex] || '')\n          \n          if (front && back && front !== back) {\n            cards.push({ front, back })\n          }\n        }\n      }\n    }\n    \n    db.close()\n\n    if (cards.length === 0) {\n      throw new Error('No valid cards found in the .apkg file')\n    }\n\n    // Extract media files from the zip\n    // Anki stores media with numeric filenames (0, 1, 2...) and a 'media' JSON mapping file\n    const mediaFiles: MediaFile[] = []\n\n    // First, get the media mapping (maps numeric IDs to original filenames)\n    const mediaMapFile = zipContent.file('media')\n    let mediaMap: Record<string, string> = {}\n\n    if (mediaMapFile) {\n      try {\n        const mediaMapText = await mediaMapFile.async('text')\n        mediaMap = JSON.parse(mediaMapText)\n        console.log(`Found media mapping with ${Object.keys(mediaMap).length} entries`)\n      } catch (err) {\n        console.warn('Failed to parse media mapping:', err)\n      }\n    }\n\n    // Extract all media files (numeric filenames at root level)\n    for (const [filename, zipEntry] of Object.entries(zipContent.files)) {\n      // Skip directories, collection.anki2, and media mapping file\n      if (zipEntry.dir || filename === 'collection.anki2' || filename === 'media') {\n        continue\n      }\n\n      // Check if this is a numeric media file or has a media extension\n      const isNumericMedia = /^\\d+$/.test(filename)\n      const hasMediaExt = /\\.(jpg|jpeg|png|gif|svg|mp3|wav|ogg|mp4|webm)$/i.test(filename)\n\n      if (isNumericMedia || hasMediaExt) {\n        try {\n          const blob = await zipEntry.async('blob')\n\n          // Use mapped filename if available, otherwise use the file's actual name\n          const originalFilename = mediaMap[filename] || filename\n\n          mediaFiles.push({\n            filename: originalFilename,\n            data: blob\n          })\n\n          console.log(`Extracted media: ${filename} -> ${originalFilename} (${blob.size} bytes)`)\n        } catch (err) {\n          console.warn(`Failed to extract media file: ${filename}`, err)\n        }\n      }\n    }\n\n    console.log(`Successfully parsed ${cards.length} cards and ${mediaFiles.length} media files from .apkg`)\n    return { name: deckName, cards, mediaFiles }\n  } catch (error) {\n    console.error('Error parsing .apkg file:', error)\n    throw new Error(`Failed to parse .apkg file: ${error instanceof Error ? error.message : 'Unknown error'}`)\n  }\n}\n\nexport const useDeckStore = create<DeckStore>()(\n  persist(\n    (set, get) => ({\n      decks: [],\n      cards: {},\n      currentStudySession: null,\n      isLoading: false,\n      error: null,\n      importProgress: 0,\n      importStatus: null,\n      hydrated: false,\n      currentUserId: null,\n \n      createDeck: async (deckData) => {\n        set({ isLoading: true, error: null })\n        try {\n          const { user } = useAuthStore.getState()\n          const userId = user?.id || 'local-user'\n\n          const deck: Deck = {\n            ...deckData,\n            userId,\n            id: crypto.randomUUID(),\n            createdAt: new Date().toISOString(),\n            updatedAt: new Date().toISOString(),\n            settings: { ...defaultDeckSettings, ...deckData.settings }\n          }\n          \n          set(state => ({\n            decks: [...state.decks, deck],\n            cards: { ...state.cards, [deck.id]: [] },\n            isLoading: false\n          }))\n\n          // Persist to IndexedDB (non-blocking)\n          void persistCreateDeck(deckData);\n          \n          return deck\n        } catch (error) {\n          set({ error: 'Failed to create deck', isLoading: false })\n          throw error\n        }\n      },\n\n      updateDeck: async (id, updates) => {\n        set({ isLoading: true, error: null })\n        try {\n          set(state => ({\n            decks: state.decks.map(deck =>\n              deck.id === id\n                ? { ...deck, ...updates, updatedAt: new Date().toISOString() }\n                : deck\n            ),\n            isLoading: false\n          }))\n\n          // Persist deck updates (non-blocking)\n          try {\n            void repos.decks.update(id, mapDeckUpdatesToRepo(updates));\n          } catch (e) {\n            console.warn('[deckStore] repo updateDeck failed', e);\n          }\n        } catch (error) {\n          set({ error: 'Failed to update deck', isLoading: false })\n          throw error\n        }\n      },\n\n      deleteDeck: async (id) => {\n        set({ isLoading: true, error: null })\n        try {\n          set(state => {\n            // eslint-disable-next-line @typescript-eslint/no-unused-vars\n            const { [id]: _deletedCards, ...remainingCards } = state.cards\n            return {\n              decks: state.decks.filter(deck => deck.id !== id),\n              cards: remainingCards,\n              isLoading: false\n            }\n          })\n          // Persist delete (non-blocking)\n          try {\n            void repos.decks.remove(id)\n          } catch (e) {\n            console.warn('[deckStore] repo deleteDeck failed', e)\n          }\n        } catch (error) {\n          set({ error: 'Failed to delete deck', isLoading: false })\n          throw error\n        }\n      },\n\n      getDeck: (id) => {\n        return get().decks.find(deck => deck.id === id)\n      },\n\n      addCard: async (deckId, cardData) => {\n        set({ isLoading: true, error: null })\n        try {\n          const card: Card = {\n            ...cardData,\n            id: crypto.randomUUID(),\n            deckId,\n            createdAt: new Date().toISOString(),\n            easeFactor: 2.5,\n            intervalDays: 0,\n            nextReview: new Date().toISOString(),\n            reviewCount: 0,\n            lapseCount: 0\n          }\n          \n          set(state => {\n            const deckCards = state.cards[deckId] || []\n            const updatedCards = [...deckCards, card]\n            \n            return {\n              cards: { ...state.cards, [deckId]: updatedCards },\n              decks: state.decks.map(deck =>\n                deck.id === deckId\n                  ? { ...deck, cardCount: updatedCards.length, updatedAt: new Date().toISOString() }\n                  : deck\n              ),\n              isLoading: false\n            }\n          })\n\n          // Persist to IndexedDB (non-blocking)\n          void persistAddCard(deckId, card);\n          \n          return card\n        } catch (error) {\n          set({ error: 'Failed to add card', isLoading: false })\n          throw error\n        }\n      },\n\n      addCardBulk: async (deckId, cardData) => {\n        try {\n          const state = get()\n          const existingCards = state.cards[deckId] || []\n          \n          // Check if this card already exists\n          const cardKey = `${cardData.frontContent.trim().toLowerCase()}|${cardData.backContent.trim().toLowerCase()}`\n          const isDuplicate = existingCards.some(card =>\n            `${card.frontContent.trim().toLowerCase()}|${card.backContent.trim().toLowerCase()}` === cardKey\n          )\n          \n          if (isDuplicate) {\n            console.log('Skipping duplicate card:', cardData.frontContent)\n            // Return a dummy card to maintain the interface, but don't add it\n            return {\n              ...cardData,\n              id: 'duplicate-skipped',\n              deckId,\n              createdAt: new Date().toISOString(),\n              easeFactor: 2.5,\n              intervalDays: 0,\n              nextReview: new Date().toISOString(),\n              reviewCount: 0,\n              lapseCount: 0\n            }\n          }\n          \n          const card: Card = {\n            ...cardData,\n            id: crypto.randomUUID(),\n            deckId,\n            createdAt: new Date().toISOString(),\n            easeFactor: 2.5,\n            intervalDays: 0,\n            nextReview: new Date().toISOString(),\n            reviewCount: 0,\n            lapseCount: 0\n          }\n          \n          set(state => {\n            const deckCards = state.cards[deckId] || []\n            const updatedCards = [...deckCards, card]\n            \n            return {\n              cards: { ...state.cards, [deckId]: updatedCards },\n              decks: state.decks.map(deck =>\n                deck.id === deckId\n                  ? { ...deck, cardCount: updatedCards.length, updatedAt: new Date().toISOString() }\n                  : deck\n              )\n            }\n          })\n\n          // Persist to IndexedDB (non-blocking) if not a skipped duplicate\n          if (card.id !== 'duplicate-skipped') {\n            void persistAddCard(deckId, card)\n          }\n          \n          return card\n        } catch (error) {\n          console.error('Failed to add card during bulk import:', error)\n          throw error\n        }\n      },\n\n      createDeckBulk: async (deckData) => {\n        try {\n          const { user } = useAuthStore.getState()\n          const userId = user?.id || 'local-user'\n\n          const deck: Deck = {\n            ...deckData,\n            userId,\n            id: crypto.randomUUID(),\n            createdAt: new Date().toISOString(),\n            updatedAt: new Date().toISOString(),\n            settings: { ...defaultDeckSettings, ...deckData.settings }\n          }\n          \n          set(state => ({\n            decks: [...state.decks, deck],\n            cards: { ...state.cards, [deck.id]: [] }\n          }))\n\n          // Persist to IndexedDB (non-blocking)\n          void persistCreateDeck(deckData);\n          \n          return deck\n        } catch (error) {\n          console.error('Failed to create deck during bulk import:', error)\n          throw error\n        }\n      },\n\n      addCardsBatch: async (deckId, cardsData) => {\n        try {\n          const state = get()\n          const existingCards = state.cards[deckId] || []\n          \n          // Create a Set of existing card content for fast lookup\n          const existingCardSet = new Set(\n            existingCards.map(card => `${card.frontContent.trim().toLowerCase()}|${card.backContent.trim().toLowerCase()}`)\n          )\n          \n          // Filter out duplicates and create new cards\n          const uniqueCardsData = cardsData.filter(cardData => {\n            const cardKey = `${cardData.frontContent.trim().toLowerCase()}|${cardData.backContent.trim().toLowerCase()}`\n            return !existingCardSet.has(cardKey)\n          })\n          \n          console.log(`Batch processing: ${cardsData.length} cards submitted, ${uniqueCardsData.length} unique cards to add`)\n          \n          if (uniqueCardsData.length === 0) {\n            console.log('No new unique cards to add in this batch')\n            return []\n          }\n          \n          const cards: Card[] = uniqueCardsData.map(cardData => ({\n            ...cardData,\n            id: crypto.randomUUID(),\n            deckId,\n            createdAt: new Date().toISOString(),\n            easeFactor: 2.5,\n            intervalDays: 0,\n            nextReview: new Date().toISOString(),\n            reviewCount: 0,\n            lapseCount: 0\n          }))\n          \n          set(state => {\n            const deckCards = state.cards[deckId] || []\n            const updatedCards = [...deckCards, ...cards]\n            \n            return {\n              cards: { ...state.cards, [deckId]: updatedCards },\n              decks: state.decks.map(deck =>\n                deck.id === deckId\n                  ? { ...deck, cardCount: updatedCards.length, updatedAt: new Date().toISOString() }\n                  : deck\n              )\n            }\n          })\n          \n          // Persist each card (non-blocking)\n          for (const c of cards) {\n            void persistAddCard(deckId, c)\n          }\n\n          return cards\n        } catch (error) {\n          console.error('Failed to add cards during batch import:', error)\n          throw error\n        }\n      },\n\n      updateCard: async (cardId, updates) => {\n        set({ isLoading: true, error: null })\n        try {\n          set(state => {\n            const newCards = { ...state.cards }\n            for (const deckId in newCards) {\n              newCards[deckId] = newCards[deckId].map(card =>\n                card.id === cardId ? { ...card, ...updates } : card\n              )\n            }\n            return { cards: newCards, isLoading: false }\n          })\n        } catch (error) {\n          set({ error: 'Failed to update card', isLoading: false })\n          throw error\n        }\n      },\n\n      deleteCard: async (cardId) => {\n        set({ isLoading: true, error: null })\n        try {\n          let affectedDeckId = ''\n          set(state => {\n            const newCards = { ...state.cards }\n            for (const deckId in newCards) {\n              const cardIndex = newCards[deckId].findIndex(card => card.id === cardId)\n              if (cardIndex !== -1) {\n                newCards[deckId] = newCards[deckId].filter(card => card.id !== cardId)\n                affectedDeckId = deckId\n                break\n              }\n            }\n            \n            return {\n              cards: newCards,\n              decks: state.decks.map(deck =>\n                deck.id === affectedDeckId\n                  ? { ...deck, cardCount: newCards[affectedDeckId].length, updatedAt: new Date().toISOString() }\n                  : deck\n              ),\n              isLoading: false\n            }\n          })\n          // Persist delete (non-blocking)\n          try {\n            void repos.cards.remove(cardId)\n          } catch (e) {\n            console.warn('[deckStore] repo deleteCard failed', e)\n          }\n        } catch (error) {\n          set({ error: 'Failed to delete card', isLoading: false })\n          throw error\n        }\n      },\n\n      deleteCardsBatch: async (deckId, cardIds) => {\n        set({ isLoading: true, error: null })\n        try {\n          set(state => {\n            const newCards = { ...state.cards }\n            const currentDeckCards = newCards[deckId] || []\n            const updatedDeckCards = currentDeckCards.filter(card => !cardIds.includes(card.id))\n            \n            newCards[deckId] = updatedDeckCards\n            \n            return {\n              cards: newCards,\n              decks: state.decks.map(deck =>\n                deck.id === deckId\n                  ? { ...deck, cardCount: updatedDeckCards.length, updatedAt: new Date().toISOString() }\n                  : deck\n              ),\n              isLoading: false\n            }\n          })\n\n          // Persist deletes (non-blocking)\n          for (const cardId of cardIds) {\n            try {\n              void repos.cards.remove(cardId)\n            } catch (e) {\n              console.warn(`[deckStore] repo deleteCardsBatch failed for card ${cardId}`, e)\n            }\n          }\n        } catch (error) {\n          set({ error: 'Failed to delete cards in batch', isLoading: false })\n          throw error\n        }\n      },\n\n      getCards: (deckId) => {\n        return get().cards[deckId] || []\n      },\n\n      importAnkiDeck: async (file) => {\n        const { setImportProgress, resetImportProgress } = get()\n        set({ isLoading: true, error: null })\n        resetImportProgress()\n        \n        try {\n          const fileName = file.name.toLowerCase()\n          \n          // Handle different file types\n          if (fileName.endsWith('.apkg')) {\n            setImportProgress(10, 'Reading file...')\n            \n            // Parse .apkg file using the new parser\n            const { name, cards, mediaFiles } = await parseApkgFile(file)\n\n            console.log(`Parsed .apkg: ${name} with ${cards.length} cards and ${mediaFiles.length} media files`)\n\n            // Check if deck with the same name already exists for the current user\n            const { user } = useAuthStore.getState()\n            const userId = user?.id || 'local-user'\n            const existingDeck = get().decks.find(d => d.title === name && d.userId === userId);\n            if (existingDeck) {\n              throw new Error(`A deck named \"${name}\" already exists. Please rename the deck or the file before importing.`);\n            }\n            \n            setImportProgress(30, 'Creating deck...')\n\n            // Create deck\n            const deck = await get().createDeckBulk({\n              userId,\n              title: name,\n              description: `Imported Anki deck with ${cards.length} cards`,\n              cardCount: 0,\n              isPublic: false,\n              settings: defaultDeckSettings,\n              category: 'imported'\n            })\n\n            // Store media files and build mappings\n            if (mediaFiles.length > 0) {\n              console.log(`[IMPORT] Starting media storage for ${mediaFiles.length} files`)\n              setImportProgress(35, `Storing ${mediaFiles.length} media files...`)\n\n              const mediaContextService = getMediaContextService()\n              const storedMediaFiles: Array<{\n                id: string\n                originalFilename: string\n                filename: string\n                mimeType: string\n                blob?: Blob\n              }> = []\n\n              for (let i = 0; i < mediaFiles.length; i++) {\n                const mediaFile = mediaFiles[i]\n                try {\n                  // Determine MIME type from filename\n                  const mimeType = mediaFile.data.type || getMimeTypeFromFilename(mediaFile.filename)\n\n                  console.log(`[IMPORT] Storing media ${i + 1}/${mediaFiles.length}: ${mediaFile.filename} (${mimeType}, ${mediaFile.data.size} bytes)`)\n\n                  // Store blob in media repository\n                  const mediaHash = await mediaStorage.storeBlob(mediaFile.data, mimeType)\n\n                  console.log(`[IMPORT] Stored ${mediaFile.filename} with hash: ${mediaHash}`)\n\n                  // Create media file record for mapping\n                  storedMediaFiles.push({\n                    id: mediaHash,\n                    originalFilename: mediaFile.filename,\n                    filename: mediaFile.filename,\n                    mimeType,\n                    blob: mediaFile.data\n                  })\n\n                  if (i % 10 === 0) {\n                    setImportProgress(35 + (5 * i / mediaFiles.length), `Stored ${i}/${mediaFiles.length} media files...`)\n                  }\n                } catch (err) {\n                  console.error(`[IMPORT] Failed to store media file: ${mediaFile.filename}`, err)\n                }\n              }\n\n              console.log(`[IMPORT] Stored ${storedMediaFiles.length} media files, building mappings for deck ${deck.id}`)\n\n              // Build media mappings\n              await mediaContextService.buildMappingsFromImport(deck.id, storedMediaFiles, userId)\n\n              console.log(`[IMPORT] Built media mappings for deck ${deck.id}`)\n              console.log(`[IMPORT] MediaContext mappings count:`, (mediaContextService as any).urlMappings.get(deck.id)?.size || 0)\n            } else {\n              console.log(`[IMPORT] No media files found in .apkg`)\n            }\n\n            setImportProgress(40, `Importing ${cards.length} cards...`)\n            \n            // Remove duplicates from cards before batch processing\n            const uniqueCards: typeof cards = []\n            const seenCards = new Set<string>()\n            \n            for (const card of cards) {\n              const cardKey = `${card.front.trim().toLowerCase()}|${card.back.trim().toLowerCase()}`\n              if (!seenCards.has(cardKey)) {\n                seenCards.add(cardKey)\n                uniqueCards.push(card)\n              }\n            }\n            \n            console.log(`Removed ${cards.length - uniqueCards.length} duplicates from Anki cards. Processing ${uniqueCards.length} unique cards.`)\n            \n            // Process unique cards in smaller batches for better performance and reliability\n            const batchSize = 100\n            let successfulImports = 0\n            const totalCards = uniqueCards.length\n            \n            console.log(`Starting batch import of ${totalCards} unique cards`)\n            \n            for (let i = 0; i < totalCards; i += batchSize) {\n              const batch = uniqueCards.slice(i, i + batchSize)\n              const batchCards = batch.map(cardData => createNewCard(\n                cardData.front,\n                cardData.back,\n                { type: 'basic' as const },\n                []\n              ))\n              \n              try {\n                console.log(`Processing batch ${Math.floor(i / batchSize) + 1}/${Math.ceil(totalCards / batchSize)} (${batch.length} cards)`)\n                await get().addCardsBatch(deck.id, batchCards)\n                successfulImports += batch.length\n                \n                // Update progress (40% to 90% for card import)\n                const cardProgress = 40 + (50 * Math.min(i + batchSize, totalCards) / totalCards)\n                setImportProgress(cardProgress, `Imported ${successfulImports}/${totalCards} cards...`)\n                \n                console.log(`Batch completed. Progress: ${cardProgress.toFixed(1)}%`)\n                \n                // Add small delay to allow UI updates\n                await new Promise(resolve => setTimeout(resolve, 50))\n              } catch (cardError) {\n                console.error('Failed to import batch:', cardError)\n                // Try individual cards in this batch as fallback\n                for (const originalCard of batch) {\n                  try {\n                    await get().addCardBulk(deck.id, createNewCard(\n                      originalCard.front,\n                      originalCard.back,\n                      { type: 'basic' as const },\n                      []\n                    ))\n                    successfulImports++\n                  } catch (individualError) {\n                    console.warn('Failed to import individual card:', originalCard, individualError)\n                  }\n                }\n                \n                // Update progress even after fallback\n                const cardProgress = 40 + (50 * Math.min(i + batchSize, totalCards) / totalCards)\n                setImportProgress(cardProgress, `Imported ${successfulImports}/${totalCards} cards...`)\n              }\n            }\n            \n            console.log(`Batch import completed. Total successful: ${successfulImports}`)\n            \n            setImportProgress(95, 'Finalizing import...')\n            \n            // Update deck description with final count\n            await get().updateDeck(deck.id, {\n              description: `Imported Anki deck with ${successfulImports} cards`\n            })\n            \n            setImportProgress(100, 'Import completed!')\n            \n            // Clear progress after a short delay\n            setTimeout(() => {\n              resetImportProgress()\n            }, 1000)\n            \n            set({ isLoading: false })\n            return deck\n          } else if (fileName.endsWith('.txt') || fileName.endsWith('.tsv') || fileName.endsWith('.csv')) {\n            setImportProgress(10, 'Reading text file...')\n            \n            // Handle text-based imports\n            const text = await file.text()\n            \n            // Detect separator\n            let separator = '\\t' // Corrected: \t is a tab character\n            if (fileName.endsWith('.csv')) {\n              separator = ','\n            }\n            \n            setImportProgress(20, 'Processing text content...')\n            \n            // Clean the text and handle encoding issues\n            const cleanText = text\n              .replace(/\\r\\n/g, '\\n')  // Normalize line endings\n              .replace(/\\r/g, '\\n')    // Handle old Mac line endings\n              .trim()\n            \n            const deck = await get().importFromText(\n              file.name.replace(/\\.[^/.]+$/, \"\"),\n              cleanText,\n              separator\n            )\n            set({ isLoading: false })\n            return deck\n          } else {\n            setImportProgress(10, 'Reading file as text...')\n            \n            // Try to parse as text anyway\n            const text = await file.text()\n            \n            setImportProgress(20, 'Processing content...')\n            \n            const cleanText = text\n              .replace(/\\r\\n/g, '\\n')\n              .replace(/\\r/g, '\\n')\n              .trim()\n            \n            const deck = await get().importFromText(\n              file.name.replace(/\\.[^/.]+$/, \"\"),\n              cleanText,\n              '\\t'\n            )\n            set({ isLoading: false })\n            return deck\n          }\n        } catch (error) {\n          const errorMessage = error instanceof Error ? error.message : 'Failed to import Anki deck'\n          set({ error: errorMessage, isLoading: false })\n          resetImportProgress()\n          throw error\n        }\n      },\n\n      importFromText: async (deckName, text, separator = '\\t') => {\n        const { setImportProgress, resetImportProgress } = get()\n        set({ isLoading: true, error: null })\n        \n        try {\n          setImportProgress(30, 'Processing text content...')\n          \n          // Clean and normalize the text\n          const cleanText = text\n            .replace(/\\r\\n/g, '\\n')  // Normalize Windows line endings\n            .replace(/\\r/g, '\\n')    // Handle old Mac line endings\n            .replace(/\\\\u0000/g, '')  // Remove null characters\n            .replace(/[\\\\u0001-\\\\u0008\\\\u000B\\\\u000C\\\\u000E-\\\\u001F\\\\u007F]/g, '') // Remove control characters\n            .trim()\n          \n          const lines = cleanText\n            .split('\\n')\n            .map(line => line.trim())\n            .filter(line => line.length > 0)\n          \n          if (lines.length === 0) {\n            throw new Error('No valid content found in the file')\n          }\n          \n          setImportProgress(40, 'Creating deck...')\n          \n          const { user } = useAuthStore.getState()\n          const userId = user?.id || 'local-user'\n\n          const deck = await get().createDeckBulk({\n            userId,\n            title: deckName,\n            description: `Imported deck with ${lines.length} cards`,\n            cardCount: 0,\n            isPublic: false,\n            settings: defaultDeckSettings,\n            category: 'imported'\n          })\n          \n          setImportProgress(50, `Importing ${lines.length} cards...`)\n          \n          // Process lines and prepare cards for batch import\n          const validCards: Array<Omit<Card, 'id' | 'createdAt' | 'deckId' | 'easeFactor' | 'intervalDays' | 'nextReview' | 'reviewCount' | 'lapseCount'>> = []\n          let skippedLines = 0\n          \n          // First pass: parse and validate all lines\n          for (let i = 0; i < lines.length; i++) {\n            const line = lines[i]\n            try {\n              // Handle quoted fields (CSV style)\n              let parts: string[]\n              if (separator === ',' && line.includes('\"')) {\n                // Simple CSV parsing for quoted fields\n                parts = line.split(',').map(part =>\n                  part.replace(/^\"(.*)\"$/, '$1').trim()\n                )\n              } else {\n                parts = line.split(separator)\n              }\n              \n              if (parts.length >= 2) {\n                const front = parts[0].trim()\n                const back = parts[1].trim()\n                \n                // Skip empty cards\n                if (front && back) {\n                  validCards.push(createNewCard(\n                    front,\n                    back,\n                    { type: 'basic' as const },\n                    []\n                  ))\n                } else {\n                  skippedLines++\n                }\n              } else {\n                skippedLines++\n              }\n            } catch (cardError) {\n              console.warn('Failed to parse line:', line, cardError)\n              skippedLines++\n            }\n          }\n          \n          // Remove duplicates from validCards before batch processing\n          const uniqueValidCards: typeof validCards = []\n          const seenCards = new Set<string>()\n          \n          for (const card of validCards) {\n            const cardKey = `${card.frontContent.trim().toLowerCase()}|${card.backContent.trim().toLowerCase()}`\n            if (!seenCards.has(cardKey)) {\n              seenCards.add(cardKey)\n              uniqueValidCards.push(card)\n            }\n          }\n          \n          console.log(`Removed ${validCards.length - uniqueValidCards.length} duplicates from parsed cards. Processing ${uniqueValidCards.length} unique cards.`)\n          \n          // Second pass: batch import unique cards\n          const batchSize = 100\n          let successfulImports = 0\n          \n          console.log(`Starting text import batch processing of ${uniqueValidCards.length} unique cards`)\n          \n          for (let i = 0; i < uniqueValidCards.length; i += batchSize) {\n            const batch = uniqueValidCards.slice(i, i + batchSize)\n            \n            try {\n              console.log(`Processing text batch ${Math.floor(i / batchSize) + 1}/${Math.ceil(uniqueValidCards.length / batchSize)} (${batch.length} cards)`)\n              const addedCards = await get().addCardsBatch(deck.id, batch)\n              successfulImports += addedCards.length\n              \n              // Update progress (50% to 90% for card import)\n              const cardProgress = 50 + (40 * Math.min(i + batchSize, uniqueValidCards.length) / uniqueValidCards.length)\n              setImportProgress(cardProgress, `Imported ${successfulImports}/${uniqueValidCards.length} cards...`)\n              \n              console.log(`Text batch completed. Progress: ${cardProgress.toFixed(1)}%, Added: ${addedCards.length} cards`)\n              \n              // Add small delay to allow UI updates\n              await new Promise(resolve => setTimeout(resolve, 50))\n            } catch (cardError) {\n              console.error('Failed to import text batch:', cardError)\n              // Try individual cards in this batch as fallback\n              for (const cardData of batch) {\n                try {\n                  const addedCard = await get().addCardBulk(deck.id, cardData)\n                  if (addedCard.id !== 'duplicate-skipped') {\n                    successfulImports++\n                  }\n                } catch (individualError) {\n                  console.warn('Failed to import individual text card:', cardData, individualError)\n                }\n              }\n              \n              // Update progress even after fallback\n              const cardProgress = 50 + (40 * Math.min(i + batchSize, uniqueValidCards.length) / uniqueValidCards.length)\n              setImportProgress(cardProgress, `Imported ${successfulImports}/${uniqueValidCards.length} cards...`)\n            }\n          }\n          \n          console.log(`Text import batch processing completed. Total successful: ${successfulImports}`)\n          \n          setImportProgress(95, 'Finalizing import...')\n          \n          // Update deck description with import results\n          await get().updateDeck(deck.id, {\n            description: `Imported deck with ${successfulImports} cards${skippedLines > 0 ? ` (${skippedLines} lines skipped)` : ''}`\n          })\n          \n          if (successfulImports === 0) {\n            throw new Error('No valid cards could be imported. Please check the file format.')\n          }\n          \n          setImportProgress(100, 'Import completed!')\n          \n          // Clear progress after a short delay\n          setTimeout(() => {\n            resetImportProgress()\n          }, 1000)\n          \n          set({ isLoading: false })\n          return deck\n        } catch (error) {\n          set({ error: 'Failed to import from text', isLoading: false })\n          resetImportProgress()\n          throw error\n        }\n      },\n\n      loadExampleDecks: async () => {\n        set({ isLoading: true, error: null })\n        try {\n          const state = get()\n          \n          // Check if example decks already exist to prevent duplicates\n          const existingTitles = new Set(state.decks.map(deck => deck.title))\n          const exampleTitles = ['Spanish Vocabulary', 'JavaScript Concepts', 'World Capitals']\n          \n          // If any example deck already exists, don't load any\n          if (exampleTitles.some(title => existingTitles.has(title))) {\n            console.log('Example decks already exist, skipping load')\n            set({ isLoading: false })\n            return\n          }\n\n          const exampleDecks = [\n            {\n              title: 'Spanish Vocabulary',\n              description: 'Essential Spanish words for beginners',\n              category: 'language',\n              cards: [\n                { front: 'Hello', back: 'Hola' },\n                { front: 'Goodbye', back: 'Adis' },\n                { front: 'Thank you', back: 'Gracias' },\n                { front: 'Please', back: 'Por favor' },\n                { front: 'Yes', back: 'S' },\n                { front: 'No', back: 'No' },\n                { front: 'Water', back: 'Agua' },\n                { front: 'Food', back: 'Comida' },\n                { front: 'House', back: 'Casa' },\n                { front: 'Car', back: 'Coche' }\n              ]\n            },\n            {\n              title: 'JavaScript Concepts',\n              description: 'Important JavaScript programming concepts',\n              category: 'programming',\n              cards: [\n                { front: 'What is a closure?', back: 'A closure is a function that has access to variables in its outer (enclosing) scope even after the outer function has returned.' },\n                { front: 'What is hoisting?', back: 'Hoisting is JavaScript\\'s default behavior of moving declarations to the top of their scope.' },\n                { front: 'What is the difference between let and var?', back: 'let has block scope and cannot be redeclared, while var has function scope and can be redeclared.' },\n                { front: 'What is a Promise?', back: 'A Promise is an object representing the eventual completion or failure of an asynchronous operation.' },\n                { front: 'What is async/await?', back: 'async/await is syntactic sugar for working with Promises, making asynchronous code look more like synchronous code.' }\n              ]\n            },\n            {\n              title: 'World Capitals',\n              description: 'Capital cities of countries around the world',\n              category: 'geography',\n              cards: [\n                { front: 'France', back: 'Paris' },\n                { front: 'Germany', back: 'Berlin' },\n                { front: 'Italy', back: 'Rome' },\n                { front: 'Spain', back: 'Madrid' },\n                { front: 'United Kingdom', back: 'London' },\n                { front: 'Japan', back: 'Tokyo' },\n                { front: 'China', back: 'Beijing' },\n                { front: 'Australia', back: 'Canberra' },\n                { front: 'Brazil', back: 'Braslia' },\n                { front: 'Canada', back: 'Ottawa' }\n              ]\n            }\n          ]\n\n          console.log('Loading example decks...')\n          const { user } = useAuthStore.getState()\n          const userId = user?.id || 'local-user'\n\n          for (const deckData of exampleDecks) {\n            const deck = await get().createDeck({\n              userId,\n              title: deckData.title,\n              description: deckData.description,\n              cardCount: 0,\n              isPublic: false,\n              settings: defaultDeckSettings,\n              category: deckData.category,\n              tags: [deckData.category]\n            })\n\n            for (const cardData of deckData.cards) {\n              await get().addCard(deck.id, createNewCard(\n                cardData.front,\n                cardData.back,\n                { type: 'basic' },\n                []\n              ))\n            }\n          }\n\n          console.log('Example decks loaded successfully')\n          set({ isLoading: false })\n        } catch (error) {\n          set({ error: 'Failed to load example decks', isLoading: false })\n          throw error\n        }\n      },\n\n      clearError: () => set({ error: null }),\n      setLoading: (loading) => set({ isLoading: loading }),\n      removeDuplicateCards: async (deckId) => {\n        try {\n          const state = get()\n          const deckCards = state.cards[deckId] || []\n          \n          if (deckCards.length === 0) {\n            return 0\n          }\n          \n          // Create a Map to track unique cards (first occurrence wins)\n          const uniqueCardsMap = new Map<string, Card>()\n          let duplicatesRemoved = 0\n          \n          for (const card of deckCards) {\n            const cardKey = `${card.frontContent.trim().toLowerCase()}|${card.backContent.trim().toLowerCase()}`\n            \n            if (!uniqueCardsMap.has(cardKey)) {\n              uniqueCardsMap.set(cardKey, card)\n            } else {\n              duplicatesRemoved++\n              console.log(`Removing duplicate card: ${card.frontContent}`)\n            }\n          }\n          \n          const uniqueCards = Array.from(uniqueCardsMap.values())\n          \n          if (duplicatesRemoved > 0) {\n            set(state => ({\n              cards: { ...state.cards, [deckId]: uniqueCards },\n              decks: state.decks.map(deck =>\n                deck.id === deckId\n                  ? { ...deck, cardCount: uniqueCards.length, updatedAt: new Date().toISOString() }\n                  : deck\n              )\n            }))\n            \n            console.log(`Removed ${duplicatesRemoved} duplicate cards from deck. ${uniqueCards.length} unique cards remaining.`)\n          }\n          \n          return duplicatesRemoved\n        } catch (error) {\n          console.error('Failed to remove duplicate cards:', error)\n          throw error\n        }\n      },\n\n      setImportProgress: (progress, status) => set({ importProgress: progress, importStatus: status }),\n      resetImportProgress: () => set({ importProgress: 0, importStatus: null }),\n      \n      // Hydrate in-memory store from IndexedDB (decks + cards)\n      hydrateFromIndexedDB: async () => {\n        const state = get();\n        if (state.hydrated) return;\n        set({ isLoading: true });\n        try {\n          // Load decks\n          const deckRows = await repos.decks.list();\n          const cardsByDeck: Record<string, Card[]> = {};\n\n          // Load cards per deck and map to domain Card\n          for (const d of deckRows) {\n            const rows = await repos.cards.listByDeck(d.deckId);\n            const cards: Card[] = rows.map((r) => {\n              const nowIso = new Date().toISOString();\n              const createdIso = new Date(r.createdAt).toISOString?.() ?? nowIso;\n              const dueDay = r.dueAt ? Math.floor(r.dueAt / 86400000) : Math.floor(Date.now() / 86400000);\n              return {\n                id: r.cardId,\n                deckId: r.deckId,\n                frontContent: String((r.fields as any)?.front ?? ''),\n                backContent: String((r.fields as any)?.back ?? ''),\n                cardType: { type: 'basic' },\n                mediaRefs: [],\n\n                // Legacy/simple scheduling fields used by some UI stats\n                easeFactor: typeof r.ease === 'number' ? (r.ease / 100) : 2.5,\n                intervalDays: r.interval ?? 0,\n                nextReview: r.dueAt ? new Date(r.dueAt).toISOString() : nowIso,\n                createdAt: createdIso,\n                reviewCount: 0,\n                lapseCount: r.lapses ?? 0,\n\n                // Enhanced Anki-style fields (best-effort defaults)\n                state: (r.state as Card['state']) ?? 'new',\n                queue: 0,\n                due: dueDay,\n                ivl: r.interval ?? 0,\n                factor: typeof r.ease === 'number' ? r.ease : 250,\n                reps: 0,\n                lapses: r.lapses ?? 0,\n                left: 0,\n\n                learningStep: 0,\n                graduationInterval: 0,\n                easyInterval: 0,\n\n                totalStudyTime: 0,\n                averageAnswerTime: 0,\n                flags: 0,\n                originalDue: 0,\n                originalDeck: r.deckId,\n                xpAwarded: 0,\n                difficultyRating: 0,\n              };\n            });\n            cardsByDeck[d.deckId] = cards;\n          }\n\n          // Get current userId for migration (wait for it to be set by authStore)\n          const currentUserId = state.currentUserId || useAuthStore.getState().user?.id || 'local-user';\n\n          // Map decks to domain Deck and migrate userId\n          const decks: Deck[] = [];\n          for (const d of deckRows) {\n            const meta = (d.meta ?? {}) as any;\n            const deckUserId = meta.userId ?? currentUserId;\n\n            // If userId was migrated, update in repository (async, non-blocking)\n            if (!meta.userId && deckUserId) {\n              const updatedMeta = { ...meta, userId: deckUserId };\n              // Only update if deck still exists\n              repos.decks.get(d.deckId).then(existing => {\n                if (existing) {\n                  return repos.decks.update(d.deckId, { meta: updatedMeta });\n                }\n              }).catch(err => {\n                // Silently ignore \"Deck not found\" errors (deck was deleted)\n                if (!err.message?.includes('Deck not found')) {\n                  console.warn('[deckStore] Failed to migrate userId for deck', d.deckId, err);\n                }\n              });\n            }\n\n            decks.push({\n              id: d.deckId,\n              userId: deckUserId,\n              title: d.name,\n              description: d.description ?? '',\n              cardCount: (cardsByDeck[d.deckId]?.length ?? d.cardCount ?? 0),\n              isPublic: meta.isPublic ?? false,\n              settings: meta.settings ?? { ...defaultDeckSettings },\n              advancedSettings: meta.advancedSettings,\n              createdAt: new Date(d.createdAt).toISOString(),\n              updatedAt: new Date(d.updatedAt).toISOString(),\n              tags: meta.tags ?? [],\n              category: meta.category ?? undefined,\n            });\n          }\n\n          set({\n            decks,\n            cards: cardsByDeck,\n            hydrated: true,\n            isLoading: false,\n            error: null,\n          });\n        } catch (e) {\n          console.warn('[deckStore] hydrateFromIndexedDB failed', e);\n          set({ hydrated: true, isLoading: false, error: 'Failed to load local data' });\n        }\n      },\n \n      // Study session functions\n            startStudySession: (deckId, studyCards) => {\n        const studyCardIds = studyCards.map(c => c.id);\n        set({\n          currentStudySession: {\n            deckId,\n            currentCardIndex: 0,\n            studyCards, // Keep full cards for in-memory access\n            studyCardIds, // Add the IDs for persistence\n            sessionStats: {\n              total: studyCards.length,\n              correct: 0,\n              incorrect: 0\n            },\n            startedAt: new Date().toISOString()\n          }\n        })\n      },\n\n      updateStudySession: (currentCardIndex, sessionStats) => {\n        set(state => ({\n          currentStudySession: state.currentStudySession ? {\n            ...state.currentStudySession,\n            currentCardIndex,\n            sessionStats\n          } : null\n        }))\n      },\n\n      clearStudySession: () => {\n        set({ currentStudySession: null })\n      },\n\n      getStudySession: (deckId) => {\n        const state = get()\n        return state.currentStudySession?.deckId === deckId ? state.currentStudySession : null\n      },\n\n      resetAllStudyData: () => {\n        // Reset all study-related data but keep decks and cards\n        set(state => {\n          // Reset all card progress data\n          const resetCards: Record<string, Card[]> = {}\n\n          for (const [deckId, cards] of Object.entries(state.cards)) {\n            resetCards[deckId] = cards.map(card => ({\n              ...card,\n              easeFactor: 2.5,\n              intervalDays: 0,\n              nextReview: new Date().toISOString(),\n              reviewCount: 0,\n              lapseCount: 0\n            }))\n          }\n\n          return {\n            cards: resetCards,\n            currentStudySession: null\n          }\n        })\n      },\n\n      setCurrentUser: (userId: string | null) => {\n        set({ currentUserId: userId })\n      },\n\n      getUserDecks: () => {\n        const state = get()\n        if (!state.currentUserId) return []\n        return state.decks.filter(deck => deck.userId === state.currentUserId)\n      }\n    }),\n    {\n      name: 'deck-storage',\n      // This function selects which parts of the state to save\n      partialize: (state) => {\n        // 1. Exclude the top-level 'cards' object entirely.\n        // 2. From the 'currentStudySession', exclude the 'studyCards' array of full objects.\n        const { cards, currentStudySession, ...restOfState } = state;\n\n        const sessionToPersist = currentStudySession\n          ? {\n              deckId: currentStudySession.deckId,\n              currentCardIndex: currentStudySession.currentCardIndex,\n              studyCardIds: currentStudySession.studyCardIds, // Only persist the IDs\n              sessionStats: currentStudySession.sessionStats,\n              startedAt: currentStudySession.startedAt,\n            }\n          : null;\n\n        // Return a new object containing only the data we want to persist.\n        // Note: `decks` are preserved via `restOfState`.\n        return { ...restOfState, currentStudySession: sessionToPersist };\n      },\n    }\n  )\n)\n\nexport const useCurrentCard = (): Card | null => {\n  const store = useDeckStore();\n  const session = store.currentStudySession;\n\n  if (!session || !session.studyCardIds || session.studyCardIds.length === 0) {\n    return null;\n  }\n\n  const currentCardId = session.studyCardIds[session.currentCardIndex];\n  if (!currentCardId) {\n    return null;\n  }\n\n  // The full, non-persisted `cards` object holds all cards for the current deck.\n  const deckCards = store.cards[session.deckId] || [];\n  return deckCards.find(card => card.id === currentCardId) || null;\n};","import { create } from 'zustand'\r\nimport { pb } from '../lib/pocketbase'\r\nimport type { User } from '../types'\r\nimport { debugLogger } from '../utils/debugLogger'\r\nimport { validateForm, validationSchemas, sanitizeInput } from '../utils/validation'\r\nimport { ensureLocalProfile, updateLocalProfile } from '../services/localProfileService'\r\nimport { linkAccount, unlinkAccount, isLinked } from '../services/onlineLinkService'\r\nimport { isRemoteAuthEnabled } from '../config/featureFlags'\r\nimport { useDeckStore } from './deckStore'\r\n\r\ninterface AuthState {\r\n  user: User | null\r\n  session: { record: Record<string, unknown>; token: string } | null // PocketBase auth record\r\n  isAuthenticated: boolean\r\n  isLoading: boolean\r\n  error: string | null\r\n  \r\n  // Primary Actions (unified interface for components)\r\n  login: (email: string, password: string) => Promise<void>\r\n  register: (email: string, username: string, password: string) => Promise<void>\r\n  logout: () => void\r\n  updateUser: (updates: Partial<User>) => void\r\n\r\n  // Local Account + Online Link (optional)\r\n  connectOnline: (provider: 'studymaster', link: { serverUserId: string; accessToken: string; refreshToken?: string; scopes?: string[] }) => Promise<void>\r\n  disconnectOnline: (provider: 'studymaster') => Promise<void>\r\n  isOnlineLinked: (provider: 'studymaster') => Promise<boolean>\r\n  \r\n  // PocketBase-specific Actions\r\n  signUp: (email: string, password: string, username: string) => Promise<void>\r\n  signIn: (email: string, password: string) => Promise<void>\r\n  signOut: () => Promise<void>\r\n  resetPassword: (email: string) => Promise<void>\r\n  updatePassword: (newPassword: string) => Promise<void>\r\n  updateProfile: (updates: Partial<User>) => Promise<void>\r\n  clearError: () => void\r\n  initializeAuth: () => Promise<void>\r\n}\r\n\r\n// Helper function to convert PocketBase user to our User type\r\nconst convertPocketbaseUser = async (pocketbaseUser: Record<string, unknown>): Promise<User> => {\r\n  const rec = pocketbaseUser as any;\r\n  debugLogger.log('[POCKETBASE]', 'START - convertPocketbaseUser', {\r\n    userId: rec?.id,\r\n    email: rec?.email,\r\n    username: rec?.username\r\n  });\r\n\r\n  try {\r\n    const id: string = String(rec?.id ?? '');\r\n    const email: string = String(rec?.email ?? '');\r\n    const baseName = email && email.includes('@') ? email.split('@')[0] : 'User';\r\n    const username: string = String(rec?.username ?? baseName ?? 'User');\r\n\r\n    const convertedUser: User = {\r\n      id,\r\n      email: email || 'unknown@example.com',\r\n      username,\r\n      level: Number(rec?.level ?? 1),\r\n      totalXp: Number(rec?.total_xp ?? 0),\r\n      coins: Number(rec?.coins ?? 100),\r\n      gems: Number(rec?.gems ?? 10),\r\n      createdAt: String(rec?.created ?? new Date().toISOString()),\r\n      lastActive: String(rec?.last_active ?? new Date().toISOString()),\r\n      preferences: rec?.preferences ?? {\r\n        theme: 'system',\r\n        language: 'en',\r\n        notifications: true,\r\n        soundEffects: true,\r\n        dailyGoal: 50,\r\n        timezone: 'UTC'\r\n      }\r\n    };\r\n\r\n    debugLogger.log('[POCKETBASE]', 'END - convertPocketbaseUser', convertedUser);\r\n    return convertedUser;\r\n  } catch (error) {\r\n    debugLogger.error('[POCKETBASE]', 'Error in convertPocketbaseUser', {\r\n      error,\r\n      stack: error instanceof Error ? error.stack : undefined,\r\n      userId: (rec as any)?.id\r\n    });\r\n    \r\n    // Fallback: create a basic user object\r\n    const id: string = String(rec?.id ?? '');\r\n    const email: string = String(rec?.email ?? 'unknown@example.com');\r\n    const baseName = email && email.includes('@') ? email.split('@')[0] : 'User';\r\n    const username: string = String(rec?.username ?? baseName ?? 'User');\r\n\r\n    const fallbackUser: User = {\r\n      id,\r\n      email,\r\n      username,\r\n      level: 1,\r\n      totalXp: 0,\r\n      coins: 100,\r\n      gems: 10,\r\n      createdAt: String(rec?.created ?? new Date().toISOString()),\r\n      lastActive: new Date().toISOString(),\r\n      preferences: {\r\n        theme: 'system',\r\n        language: 'en',\r\n        notifications: true,\r\n        soundEffects: true,\r\n        dailyGoal: 50,\r\n        timezone: 'UTC'\r\n      }\r\n    };\r\n\r\n    debugLogger.log('[POCKETBASE]', 'END - convertPocketbaseUser (fallback)', fallbackUser);\r\n    return fallbackUser;\r\n  }\r\n}\r\n\r\n// Helper functions for authentication operations\r\nconst validateSignUpInputs = (email: string, password: string, username: string) => {\r\n  const validationResults = validateForm(\r\n    { email, password, username },\r\n    validationSchemas.signUp\r\n  )\r\n  \r\n  const validationErrors = Object.entries(validationResults)\r\n    .filter(([_, result]) => !result.isValid)\r\n    .map(([field, result]) => `${field}: ${result.errors.join(', ')}`)\r\n  \r\n  if (validationErrors.length > 0) {\r\n    throw new Error(validationErrors.join('; '))\r\n  }\r\n}\r\n\r\nconst validateSignInInputs = (email: string, password: string) => {\r\n  const validationResults = validateForm(\r\n    { email, password },\r\n    validationSchemas.signIn\r\n  )\r\n  \r\n  const validationErrors = Object.entries(validationResults)\r\n    .filter(([_, result]) => !result.isValid)\r\n    .map(([field, result]) => `${field}: ${result.errors.join(', ')}`)\r\n  \r\n  if (validationErrors.length > 0) {\r\n    throw new Error(validationErrors.join('; '))\r\n  }\r\n}\r\n\r\nconst createPocketBaseUserData = (email: string, username: string, password: string) => ({\r\n  username: sanitizeInput(username),\r\n  email: sanitizeInput(email),\r\n  password,\r\n  passwordConfirm: password,\r\n  level: 1,\r\n  total_xp: 0,\r\n  coins: 100,\r\n  gems: 10,\r\n  last_active: new Date().toISOString(),\r\n  preferences: {\r\n    theme: 'system',\r\n    language: 'en',\r\n    notifications: true,\r\n    soundEffects: true,\r\n    dailyGoal: 50,\r\n    timezone: 'UTC'\r\n  }\r\n})\r\n\r\nconst createDemoUser = (): User => ({\r\n  id: 'demo-user',\r\n  email: 'demo@studymaster.app',\r\n  username: 'DemoUser',\r\n  level: 5,\r\n  totalXp: 2500,\r\n  coins: 150,\r\n  gems: 25,\r\n  createdAt: new Date().toISOString(),\r\n  lastActive: new Date().toISOString(),\r\n  preferences: {\r\n    theme: 'system',\r\n    language: 'en',\r\n    notifications: true,\r\n    soundEffects: true,\r\n    dailyGoal: 50,\r\n    timezone: 'UTC'\r\n  }\r\n})\r\n\r\nconst handleSignUpError = (error: unknown): string => {\r\n  if (!(error instanceof Error)) return 'Registration failed'\r\n  \r\n  if (error.message.includes('username')) {\r\n    return 'Username already exists or is invalid'\r\n  } else if (error.message.includes('email')) {\r\n    return 'Email already exists or is invalid'\r\n  } else {\r\n    return error.message\r\n  }\r\n}\r\n\r\nconst handleSignInError = (error: unknown): string => {\r\n  if (!(error instanceof Error)) return 'Login failed'\r\n  \r\n  if (error.message.includes('Failed to authenticate')) {\r\n    return 'Invalid email/username or password. Please check your credentials and try again.'\r\n  } else if (error.message.includes('Too many requests')) {\r\n    return 'Too many login attempts. Please wait a moment and try again.'\r\n  } else {\r\n    return error.message\r\n  }\r\n}\r\n\r\nconst isDemoLogin = (email: string, password: string): boolean => {\r\n  const isDevelopment = import.meta.env.NODE_ENV === 'development' || import.meta.env.VITE_ENABLE_DEBUG_LOGGING === 'true'\r\n  const demoPassword = import.meta.env.VITE_DEMO_PASSWORD || 'demo123456'\r\n  return isDevelopment && email === 'demo' && password === demoPassword\r\n}\r\n\r\nconst performPocketBaseAuth = async (email: string, password: string) => {\r\n  const sanitizedEmail = sanitizeInput(email)\r\n  \r\n  // Try email first, then username fallback\r\n  try {\r\n    return await pb.collection('users').authWithPassword(sanitizedEmail, password)\r\n  } catch (emailError) {\r\n    debugLogger.log('[POCKETBASE]', 'Email login failed, trying username');\r\n    return await pb.collection('users').authWithPassword(sanitizedEmail, password)\r\n  }\r\n}\r\n\r\nconst updateUserLastActive = async (userId: string) => {\r\n  try {\r\n    await pb.collection('users').update(userId, {\r\n      last_active: new Date().toISOString()\r\n    })\r\n    debugLogger.log('[POCKETBASE]', 'Updated last active time');\r\n  } catch (updateError) {\r\n    debugLogger.warn('[POCKETBASE]', 'Could not update last active time', {\r\n      error: updateError\r\n    });\r\n  }\r\n}\r\n\r\n// Consolidated authentication store - combines PocketBase + local fallback\r\n// This replaces the dual authStore/pocketbaseAuthStore pattern\r\nexport const useAuthStore = create<AuthState>()((set, get) => ({\r\n  user: null,\r\n  session: null,\r\n  isAuthenticated: false,\r\n  isLoading: false,\r\n  error: null,\r\n\r\n  signUp: async (email: string, _password: string, username: string) => {\r\n    // Force local registration (server optional). Never calls PocketBase.\r\n    set({ isLoading: true, error: null })\r\n    debugLogger.info('[AUTH_STORE]', 'signUp - forcing local profile creation (server optional)')\r\n    const profile = await ensureLocalProfile()\r\n    await updateLocalProfile({ displayName: username })\r\n    const localUser: User = {\r\n      id: profile.deviceUserId,\r\n      email: email || 'local@device',\r\n      username: username || profile.displayName || 'You',\r\n      level: 1,\r\n      totalXp: 0,\r\n      coins: 0,\r\n      gems: 0,\r\n      createdAt: new Date(profile.createdAt).toISOString(),\r\n      lastActive: new Date().toISOString(),\r\n      preferences: {\r\n        theme: 'system',\r\n        language: 'en',\r\n        notifications: true,\r\n        soundEffects: true,\r\n        dailyGoal: 50,\r\n        timezone: 'UTC'\r\n      }\r\n    }\r\n    set({ user: localUser, session: null, isAuthenticated: true, isLoading: false, error: null })\r\n  },\r\n\r\n  signIn: async (_email: string, _password: string) => {\r\n    // Force local login (server optional). Never calls PocketBase.\r\n    set({ isLoading: true, error: null })\r\n    debugLogger.info('[AUTH_STORE]', 'signIn - forcing local auth (server optional)')\r\n    const profile = await ensureLocalProfile()\r\n    const localUser: User = {\r\n      id: profile.deviceUserId,\r\n      email: 'local@device',\r\n      username: profile.displayName || 'You',\r\n      level: 1,\r\n      totalXp: 0,\r\n      coins: 0,\r\n      gems: 0,\r\n      createdAt: new Date(profile.createdAt).toISOString(),\r\n      lastActive: new Date().toISOString(),\r\n      preferences: {\r\n        theme: 'system',\r\n        language: 'en',\r\n        notifications: true,\r\n        soundEffects: true,\r\n        dailyGoal: 50,\r\n        timezone: 'UTC'\r\n      }\r\n    }\r\n    set({ user: localUser, session: null, isAuthenticated: true, isLoading: false, error: null })\r\n    useDeckStore.getState().setCurrentUser(localUser.id)\r\n  },\r\n\r\n  signOut: async () => {\r\n    debugLogger.log('[POCKETBASE]', 'START - signOut');\r\n    \r\n    try {\r\n      debugLogger.log('[POCKETBASE]', 'Calling PocketBase authStore.clear');\r\n      pb.authStore.clear()\r\n      \r\n      debugLogger.log('[POCKETBASE]', 'Clearing auth state');\r\n      set({\r\n        user: null,\r\n        session: null,\r\n        isAuthenticated: false,\r\n        error: null\r\n      })\r\n      useDeckStore.getState().setCurrentUser(null)\r\n      \r\n      debugLogger.log('[POCKETBASE]', 'END - signOut (success)');\r\n    } catch (error) {\r\n      debugLogger.error('[POCKETBASE]', 'SignOut error', {\r\n        error,\r\n        stack: error instanceof Error ? error.stack : undefined\r\n      });\r\n      \r\n      set({\r\n        error: error instanceof Error ? error.message : 'Logout failed'\r\n      })\r\n    }\r\n  },\r\n\r\n  resetPassword: async (email: string) => {\r\n    debugLogger.log('[POCKETBASE]', 'START - resetPassword', { email });\r\n    \r\n    set({ isLoading: true, error: null })\r\n    \r\n    try {\r\n      await pb.collection('users').requestPasswordReset(email)\r\n      \r\n      set({\r\n        isLoading: false,\r\n        error: null\r\n      })\r\n      \r\n      debugLogger.log('[POCKETBASE]', 'END - resetPassword (success)');\r\n    } catch (error) {\r\n      debugLogger.error('[POCKETBASE]', 'Reset password error', {\r\n        error,\r\n        stack: error instanceof Error ? error.stack : undefined\r\n      });\r\n      \r\n      let errorMessage = 'Password reset failed'\r\n      if (error instanceof Error) {\r\n        if (error.message.includes('Invalid email')) {\r\n          errorMessage = 'Please enter a valid email address.'\r\n        } else if (error.message.includes('not found')) {\r\n          errorMessage = 'No account found with this email address.'\r\n        } else {\r\n          errorMessage = error.message\r\n        }\r\n      }\r\n      \r\n      set({\r\n        error: errorMessage,\r\n        isLoading: false\r\n      })\r\n    }\r\n  },\r\n\r\n  updatePassword: async (newPassword: string) => {\r\n    debugLogger.log('[POCKETBASE]', 'START - updatePassword', {\r\n      passwordLength: newPassword.length\r\n    });\r\n    \r\n    const currentState = get();\r\n    debugLogger.log('[POCKETBASE]', 'Current auth state', {\r\n      hasUser: !!currentState.user,\r\n      hasSession: !!currentState.session,\r\n      isAuthenticated: currentState.isAuthenticated\r\n    });\r\n    \r\n    set({ isLoading: true, error: null });\r\n    \r\n    try {\r\n      // Validate password\r\n      if (!newPassword || newPassword.length < 6) {\r\n        throw new Error(\"Password must be at least 6 characters long.\");\r\n      }\r\n\r\n      if (!currentState.user?.id) {\r\n        throw new Error('No authenticated user found');\r\n      }\r\n\r\n      debugLogger.log('[POCKETBASE]', 'Calling pb.collection.update');\r\n\r\n      await pb.collection('users').update(currentState.user.id, {\r\n        password: newPassword,\r\n        passwordConfirm: newPassword\r\n      });\r\n\r\n      debugLogger.log('[POCKETBASE]', 'Password update successful');\r\n\r\n      set({ isLoading: false, error: null });\r\n      \r\n      debugLogger.log('[POCKETBASE]', 'END - updatePassword (success)');\r\n    } catch (error) {\r\n      const errorMessage =\r\n        error instanceof Error\r\n          ? error.message\r\n          : \"An unknown error occurred during password update.\";\r\n      \r\n      debugLogger.error('[POCKETBASE]', 'UpdatePassword failed', {\r\n        error: errorMessage,\r\n        errorType: error?.constructor?.name,\r\n        stack: error instanceof Error ? error.stack : undefined\r\n      });\r\n      \r\n      set({ isLoading: false, error: errorMessage });\r\n      \r\n      throw new Error(errorMessage);\r\n    }\r\n  },\r\n\r\n  updateProfile: async (updates: Partial<User>) => {\r\n    const { user } = get()\r\n    \r\n    debugLogger.log('[POCKETBASE]', 'START - updateProfile', {\r\n      userId: user?.id,\r\n      updates: Object.keys(updates)\r\n    });\r\n    \r\n    if (!user) {\r\n      debugLogger.warn('[POCKETBASE]', 'No user found for profile update');\r\n      return\r\n    }\r\n    \r\n    try {\r\n      const updateData = {\r\n        username: updates.username,\r\n        level: updates.level,\r\n        total_xp: updates.totalXp,\r\n        coins: updates.coins,\r\n        gems: updates.gems,\r\n        preferences: updates.preferences,\r\n        last_active: new Date().toISOString()\r\n      };\r\n      \r\n      debugLogger.log('[POCKETBASE]', 'Updating profile in database', updateData);\r\n      \r\n      await pb.collection('users').update(user.id, updateData)\r\n      \r\n      debugLogger.log('[POCKETBASE]', 'Updating local user state');\r\n      set({ user: { ...user, ...updates } })\r\n      \r\n      debugLogger.log('[POCKETBASE]', 'END - updateProfile (success)');\r\n    } catch (error) {\r\n      debugLogger.error('[POCKETBASE]', 'Profile update error', {\r\n        error,\r\n        stack: error instanceof Error ? error.stack : undefined\r\n      });\r\n      \r\n      set({\r\n        error: error instanceof Error ? error.message : 'Profile update failed'\r\n      })\r\n    }\r\n  },\r\n\r\n  clearError: () => {\r\n    debugLogger.log('[POCKETBASE]', 'Clearing error state');\r\n    set({ error: null })\r\n  },\r\n\r\n  initializeAuth: async () => {\r\n    debugLogger.log('[POCKETBASE]', 'START - initializeAuth');\r\n    \r\n    try {\r\n      if (pb.authStore.isValid && pb.authStore.model) {\r\n        debugLogger.log('[POCKETBASE]', 'Valid auth store found, converting user', {\r\n          userId: pb.authStore.model.id,\r\n          email: pb.authStore.model.email\r\n        });\r\n        \r\n        const user = await convertPocketbaseUser(pb.authStore.model)\r\n        \r\n        debugLogger.log('[POCKETBASE]', 'Setting authenticated state from initialization');\r\n        set({\r\n          user,\r\n          session: {\r\n            record: pb.authStore.model,\r\n            token: pb.authStore.token\r\n          },\r\n          isAuthenticated: true\r\n        })\r\n      } else {\r\n        // Fallback: bootstrap a local-only profile (no server required)\r\n        debugLogger.info('[AUTH_STORE]', 'No remote session. Bootstrapping local profile.');\r\n        const profile = await ensureLocalProfile();\r\n        const localUser: User = {\r\n          id: profile.deviceUserId,\r\n          email: 'local@device',\r\n          username: profile.displayName || 'You',\r\n          level: 1,\r\n          totalXp: 0,\r\n          coins: 0,\r\n          gems: 0,\r\n          createdAt: new Date(profile.createdAt).toISOString(),\r\n          lastActive: new Date().toISOString(),\r\n          preferences: {\r\n            theme: 'system',\r\n            language: 'en',\r\n            notifications: true,\r\n            soundEffects: true,\r\n            dailyGoal: 50,\r\n            timezone: 'UTC'\r\n          }\r\n        };\r\n        set({\r\n          user: localUser,\r\n          session: null,\r\n          isAuthenticated: true\r\n        });\r\n        useDeckStore.getState().setCurrentUser(localUser.id);\r\n        debugLogger.log('[AUTH_STORE]', 'Local profile initialized', { deviceUserId: profile.deviceUserId });\r\n      }\r\n      \r\n      debugLogger.log('[POCKETBASE]', 'END - initializeAuth');\r\n    } catch (error) {\r\n      debugLogger.error('[POCKETBASE]', 'Auth initialization error', {\r\n        error,\r\n        stack: error instanceof Error ? error.stack : undefined\r\n      });\r\n      \r\n      set({\r\n        user: null,\r\n        session: null,\r\n        isAuthenticated: false\r\n      })\r\n    }\r\n  },\r\n\r\n  // Local account: optional online link helpers\r\n  connectOnline: async (provider, link) => {\r\n    const state = useAuthStore.getState();\r\n    const deviceUserId = state.user?.id;\r\n    if (!deviceUserId) {\r\n      debugLogger.warn('[AUTH_STORE]', 'connectOnline called without local user');\r\n      throw new Error('No local user');\r\n    }\r\n    await linkAccount({\r\n      deviceUserId,\r\n      provider,\r\n      serverUserId: link.serverUserId,\r\n      accessToken: link.accessToken,\r\n      refreshToken: link.refreshToken,\r\n      scopes: link.scopes,\r\n    });\r\n    debugLogger.info('[AUTH_STORE]', 'Online account linked', { provider });\r\n  },\r\n\r\n  disconnectOnline: async (provider) => {\r\n    const state = useAuthStore.getState();\r\n    const deviceUserId = state.user?.id;\r\n    if (!deviceUserId) return;\r\n    await unlinkAccount(deviceUserId, provider);\r\n    debugLogger.info('[AUTH_STORE]', 'Online account unlinked', { provider });\r\n  },\r\n\r\n  isOnlineLinked: async (provider) => {\r\n    const state = useAuthStore.getState();\r\n    const deviceUserId = state.user?.id;\r\n    if (!deviceUserId) return false;\r\n    return isLinked(deviceUserId, provider);\r\n  },\r\n\r\n  // Unified methods for components (FORCE LOCAL by default)\r\n  login: async (_email: string, _password: string) => {\r\n    debugLogger.info('[AUTH_STORE]', 'Login - forcing local auth (server optional)')\r\n    const profile = await ensureLocalProfile()\r\n    const localUser: User = {\r\n      id: profile.deviceUserId,\r\n      email: 'local@device',\r\n      username: profile.displayName || 'You',\r\n      level: 1,\r\n      totalXp: 0,\r\n      coins: 0,\r\n      gems: 0,\r\n      createdAt: new Date(profile.createdAt).toISOString(),\r\n      lastActive: new Date().toISOString(),\r\n      preferences: {\r\n        theme: 'system',\r\n        language: 'en',\r\n        notifications: true,\r\n        soundEffects: true,\r\n        dailyGoal: 50,\r\n        timezone: 'UTC'\r\n      }\r\n    }\r\n    set({ user: localUser, session: null, isAuthenticated: true, isLoading: false, error: null })\r\n  },\r\n\r\n  // Force local registration (server optional). Never calls PocketBase.\r\n  register: async (email: string, username: string, _password: string) => {\r\n    debugLogger.info('[AUTH_STORE]', 'Register - forcing local profile creation (server optional)')\r\n    const profile = await ensureLocalProfile()\r\n    // Persist desired display name locally\r\n    await updateLocalProfile({ displayName: username })\r\n    const localUser: User = {\r\n      id: profile.deviceUserId,\r\n      // Email is stored only for UX; not sent anywhere unless user links online features\r\n      email: email || 'local@device',\r\n      username: username || profile.displayName || 'You',\r\n      level: 1,\r\n      totalXp: 0,\r\n      coins: 0,\r\n      gems: 0,\r\n      createdAt: new Date(profile.createdAt).toISOString(),\r\n      lastActive: new Date().toISOString(),\r\n      preferences: {\r\n        theme: 'system',\r\n        language: 'en',\r\n        notifications: true,\r\n        soundEffects: true,\r\n        dailyGoal: 50,\r\n        timezone: 'UTC'\r\n      }\r\n    }\r\n    set({\r\n      user: localUser,\r\n      session: null,\r\n      isAuthenticated: true,\r\n      isLoading: false,\r\n      error: null\r\n    })\r\n    useDeckStore.getState().setCurrentUser(localUser.id)\r\n  },\r\n\r\n  logout: () => {\r\n    const { signOut } = get()\r\n    signOut()\r\n  },\r\n\r\n  updateUser: (updates: Partial<User>) => {\r\n    const { user } = get()\r\n    if (user) {\r\n      set({ user: { ...user, ...updates } })\r\n    }\r\n  }\r\n}))\r\n\r\n// Set up auth state change listener\r\npb.authStore.onChange((token, record) => {\r\n  debugLogger.info('[POCKETBASE]', 'Auth state change detected', {\r\n    hasToken: !!token,\r\n    hasRecord: !!record,\r\n    userId: record?.id,\r\n    timestamp: new Date().toISOString()\r\n  });\r\n  \r\n  if (token && record) {\r\n    debugLogger.log('[POCKETBASE]', 'Processing auth state change - user logged in');\r\n    \r\n    convertPocketbaseUser(record).then(user => {\r\n      debugLogger.log('[POCKETBASE]', 'Updating auth store for logged in user');\r\n      useAuthStore.setState({\r\n        user,\r\n        session: { record, token },\r\n        isAuthenticated: true\r\n      })\r\n      useDeckStore.getState().setCurrentUser(user.id)\r\n    }).catch(error => {\r\n      debugLogger.error('[POCKETBASE]', 'Failed to convert user during auth change', {\r\n        error,\r\n        userId: record.id\r\n      });\r\n    });\r\n  } else {\r\n    debugLogger.log('[POCKETBASE]', 'Processing auth state change - user logged out');\r\n    \r\n    useAuthStore.setState({\r\n      user: null,\r\n      session: null,\r\n      isAuthenticated: false\r\n    })\r\n  }\r\n})","import { create } from 'zustand'\r\nimport { persist } from 'zustand/middleware'\r\n\r\ntype Theme = 'light' | 'dark' | 'system'\r\n\r\ninterface ThemeState {\r\n  theme: Theme\r\n  systemTheme: 'light' | 'dark'\r\n  \r\n  // Actions\r\n  setTheme: (theme: Theme) => void\r\n  toggleTheme: () => void\r\n  initializeTheme: () => void\r\n}\r\n\r\nexport const useThemeStore = create<ThemeState>()(\r\n  persist(\r\n    (set, get) => ({\r\n      theme: 'system',\r\n      systemTheme: 'light',\r\n\r\n      setTheme: (theme: Theme) => {\r\n        set({ theme })\r\n        \r\n        // Apply theme immediately\r\n        const { systemTheme } = get()\r\n        const effectiveTheme = theme === 'system' ? systemTheme : theme\r\n        \r\n        if (effectiveTheme === 'dark') {\r\n          document.documentElement.classList.add('dark')\r\n        } else {\r\n          document.documentElement.classList.remove('dark')\r\n        }\r\n      },\r\n\r\n      toggleTheme: () => {\r\n        const { theme } = get()\r\n        const newTheme = theme === 'light' ? 'dark' : 'light'\r\n        get().setTheme(newTheme)\r\n      },\r\n\r\n      initializeTheme: () => {\r\n        // Detect system theme preference\r\n        const systemTheme = window.matchMedia('(prefers-color-scheme: dark)').matches \r\n          ? 'dark' \r\n          : 'light'\r\n        \r\n        set({ systemTheme })\r\n        \r\n        // Listen for system theme changes\r\n        window.matchMedia('(prefers-color-scheme: dark)')\r\n          .addEventListener('change', (e) => {\r\n            const newSystemTheme = e.matches ? 'dark' : 'light'\r\n            set({ systemTheme: newSystemTheme })\r\n            \r\n            // If using system theme, update the applied theme\r\n            const { theme } = get()\r\n            if (theme === 'system') {\r\n              if (newSystemTheme === 'dark') {\r\n                document.documentElement.classList.add('dark')\r\n              } else {\r\n                document.documentElement.classList.remove('dark')\r\n              }\r\n            }\r\n          })\r\n        \r\n        // Apply initial theme\r\n        const { theme } = get()\r\n        const effectiveTheme = theme === 'system' ? systemTheme : theme\r\n        \r\n        if (effectiveTheme === 'dark') {\r\n          document.documentElement.classList.add('dark')\r\n        } else {\r\n          document.documentElement.classList.remove('dark')\r\n        }\r\n      }\r\n    }),\r\n    {\r\n      name: 'theme-storage',\r\n      partialize: (state) => ({ theme: state.theme })\r\n    }\r\n  )\r\n)","import { create } from 'zustand'\r\nimport { persist } from 'zustand/middleware'\r\nimport type {\r\n  Achievement,\r\n  UserAchievement,\r\n  UserStreak,\r\n  Challenge,\r\n  ChallengeParticipation,\r\n  Leaderboard,\r\n  WeeklyProgress\r\n} from '@shared/types'\r\n\r\ninterface UserStats {\r\n  totalCards: number\r\n  cardsStudiedToday: number\r\n  cardsStudiedThisWeek: number\r\n  cardsStudiedThisMonth: number\r\n  averageAccuracy: number\r\n  totalStudyTime: number // in minutes\r\n  studyTimeToday: number // in minutes\r\n  studyTimeThisWeek: number // in minutes\r\n  decksCreated: number\r\n  decksCompleted: number\r\n  longestStreak: number\r\n  currentStreak: number\r\n  // Currency system\r\n  gold: number\r\n  diamonds: number\r\n  // User level and XP\r\n  level: number\r\n  xp: number\r\n  xpToNextLevel: number\r\n}\r\n\r\ninterface GamificationState {\r\n  // User stats\r\n  userStats: UserStats\r\n  \r\n  // Achievements\r\n  achievements: Achievement[]\r\n  userAchievements: UserAchievement[]\r\n  \r\n  // Streaks\r\n  userStreak: UserStreak | null\r\n  \r\n  // Challenges\r\n  activeChallenges: Challenge[]\r\n  userChallengeParticipations: ChallengeParticipation[]\r\n  \r\n  // Leaderboards\r\n  leaderboards: Record<string, Leaderboard>\r\n  \r\n  // User state tracking\r\n  isFirstTimeUser: boolean\r\n  isInitialized: boolean\r\n  \r\n  // Actions\r\n  updateUserStats: (stats: Partial<UserStats>) => void\r\n  addUserAchievement: (achievementId: string) => void\r\n  updateStreak: (streak: Partial<UserStreak>) => void\r\n  joinChallenge: (challengeId: string) => void\r\n  updateChallengeProgress: (challengeId: string, progress: Record<string, number>) => void\r\n  claimChallengeReward: (challengeId: string) => void\r\n  initializeMockData: () => void\r\n  initializeNewUser: () => void\r\n  initializeUserData: (isDemo?: boolean) => void\r\n  resetAllUserData: () => void\r\n  addCurrency: (gold: number, diamonds: number) => void\r\n  spendCurrency: (gold: number, diamonds: number) => boolean\r\n  awardStudyXP: (cardsStudied: number, correctAnswers: number) => void\r\n  \r\n  // Monthly Challenge Management\r\n  updateMilestoneProgress: (challengeId: string, milestoneId: string, completed: boolean) => void\r\n  updateWeeklyProgress: (challengeId: string, weekData: WeeklyProgress) => void\r\n  updateChallengeStreak: (challengeId: string, streak: number) => void\r\n  unlockStoryChapter: (challengeId: string, week: number) => void\r\n  claimMilestoneReward: (challengeId: string, milestoneId: string) => void\r\n  contributeToCommunityGoal: (goalId: string, contribution: number) => void\r\n}\r\n\r\n// Mock data\r\nconst mockAchievements: Achievement[] = [\r\n  {\r\n    id: '1',\r\n    name: 'First Steps',\r\n    description: 'Complete your first study session',\r\n    icon: '',\r\n    category: 'study_milestones',\r\n    requirements: [{ type: 'sessions_completed', value: 1, operator: 'gte' }],\r\n    xpReward: 50,\r\n    coinReward: 10,\r\n    isSecret: false,\r\n    rarity: 'common'\r\n  },\r\n  {\r\n    id: '2',\r\n    name: 'Streak Master',\r\n    description: 'Maintain a 7-day study streak',\r\n    icon: '',\r\n    category: 'streaks',\r\n    requirements: [{ type: 'current_streak', value: 7, operator: 'gte' }],\r\n    xpReward: 200,\r\n    coinReward: 50,\r\n    isSecret: false,\r\n    rarity: 'rare'\r\n  },\r\n  {\r\n    id: '3',\r\n    name: 'Perfect Score',\r\n    description: 'Get 100% accuracy in a 20+ card session',\r\n    icon: '',\r\n    category: 'accuracy',\r\n    requirements: [\r\n      { type: 'session_accuracy', value: 100, operator: 'eq' },\r\n      { type: 'session_cards', value: 20, operator: 'gte' }\r\n    ],\r\n    xpReward: 150,\r\n    coinReward: 30,\r\n    isSecret: false,\r\n    rarity: 'rare'\r\n  },\r\n  {\r\n    id: '4',\r\n    name: 'Speed Demon',\r\n    description: 'Complete 50 cards in under 10 minutes',\r\n    icon: '',\r\n    category: 'special',\r\n    requirements: [\r\n      { type: 'cards_in_session', value: 50, operator: 'gte' },\r\n      { type: 'session_time', value: 600, operator: 'lte' }\r\n    ],\r\n    xpReward: 300,\r\n    coinReward: 75,\r\n    isSecret: false,\r\n    rarity: 'epic'\r\n  },\r\n  {\r\n    id: '5',\r\n    name: 'Scholar',\r\n    description: 'Study 1000 cards total',\r\n    icon: '',\r\n    category: 'study_milestones',\r\n    requirements: [{ type: 'total_cards', value: 1000, operator: 'gte' }],\r\n    xpReward: 500,\r\n    coinReward: 100,\r\n    isSecret: false,\r\n    rarity: 'epic'\r\n  },\r\n  {\r\n    id: '6',\r\n    name: 'Legend',\r\n    description: 'Reach level 20',\r\n    icon: '',\r\n    category: 'special',\r\n    requirements: [{ type: 'user_level', value: 20, operator: 'gte' }],\r\n    xpReward: 1000,\r\n    coinReward: 500,\r\n    isSecret: false,\r\n    rarity: 'legendary'\r\n  }\r\n]\r\n\r\nconst mockChallenges: Challenge[] = [\r\n  {\r\n    id: '1',\r\n    title: 'Daily Grind',\r\n    description: 'Study 25 cards today',\r\n    type: 'daily',\r\n    requirements: [{ type: 'cards_studied_today', target: 25, description: 'Study 25 cards' }],\r\n    rewards: [\r\n      { type: 'xp', amount: 50 },\r\n      { type: 'coins', amount: 10 }\r\n    ],\r\n    startDate: new Date().toISOString(),\r\n    endDate: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString(),\r\n    isActive: true,\r\n    participantCount: 1247\r\n  },\r\n  {\r\n    id: '2',\r\n    title: 'Weekly Warrior',\r\n    description: 'Complete 200 cards this week',\r\n    type: 'weekly',\r\n    requirements: [{ type: 'cards_studied_week', target: 200, description: 'Study 200 cards this week' }],\r\n    rewards: [\r\n      { type: 'xp', amount: 200 },\r\n      { type: 'coins', amount: 50 },\r\n      { type: 'gems', amount: 5 }\r\n    ],\r\n    startDate: new Date(Date.now() - 3 * 24 * 60 * 60 * 1000).toISOString(),\r\n    endDate: new Date(Date.now() + 4 * 24 * 60 * 60 * 1000).toISOString(),\r\n    isActive: true,\r\n    participantCount: 892\r\n  },\r\n  {\r\n    id: '3',\r\n    title: 'Accuracy Master',\r\n    description: 'Maintain 90%+ accuracy for 5 sessions',\r\n    type: 'weekly',\r\n    requirements: [{ type: 'accuracy_sessions', target: 5, description: 'Complete 5 sessions with 90%+ accuracy' }],\r\n    rewards: [\r\n      { type: 'xp', amount: 300 },\r\n      { type: 'coins', amount: 75 },\r\n      { type: 'badge', itemId: 'accuracy_master' }\r\n    ],\r\n    startDate: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000).toISOString(),\r\n    endDate: new Date(Date.now() + 5 * 24 * 60 * 60 * 1000).toISOString(),\r\n    isActive: true,\r\n    participantCount: 456\r\n  }\r\n]\r\n\r\nconst mockLeaderboards: Record<string, Leaderboard> = {\r\n  'xp_weekly': {\r\n    id: 'xp_weekly',\r\n    type: 'xp',\r\n    period: 'weekly',\r\n    entries: [\r\n      { userId: '1', username: 'DemoUser', score: 2500, rank: 1, change: 0 },\r\n      { userId: '2', username: 'StudyMaster', score: 2350, rank: 2, change: 1 },\r\n      { userId: '3', username: 'FlashcardPro', score: 2200, rank: 3, change: -1 },\r\n      { userId: '4', username: 'LearnFast', score: 2100, rank: 4, change: 2 },\r\n      { userId: '5', username: 'MemoryKing', score: 2050, rank: 5, change: -1 },\r\n      { userId: '6', username: 'QuizWhiz', score: 1980, rank: 6, change: 0 },\r\n      { userId: '7', username: 'CardShark', score: 1920, rank: 7, change: 3 },\r\n      { userId: '8', username: 'BrainBoost', score: 1850, rank: 8, change: -2 },\r\n      { userId: '9', username: 'StudyBuddy', score: 1800, rank: 9, change: 1 },\r\n      { userId: '10', username: 'FlashGenius', score: 1750, rank: 10, change: -1 }\r\n    ],\r\n    updatedAt: new Date().toISOString()\r\n  },\r\n  'streak_all_time': {\r\n    id: 'streak_all_time',\r\n    type: 'streak',\r\n    period: 'all_time',\r\n    entries: [\r\n      { userId: '2', username: 'StudyMaster', score: 45, rank: 1, change: 0 },\r\n      { userId: '3', username: 'FlashcardPro', score: 38, rank: 2, change: 0 },\r\n      { userId: '4', username: 'LearnFast', score: 32, rank: 3, change: 1 },\r\n      { userId: '1', username: 'DemoUser', score: 28, rank: 4, change: -1 },\r\n      { userId: '5', username: 'MemoryKing', score: 25, rank: 5, change: 0 },\r\n      { userId: '6', username: 'QuizWhiz', score: 22, rank: 6, change: 2 },\r\n      { userId: '7', username: 'CardShark', score: 20, rank: 7, change: -1 },\r\n      { userId: '8', username: 'BrainBoost', score: 18, rank: 8, change: -1 },\r\n      { userId: '9', username: 'StudyBuddy', score: 15, rank: 9, change: 0 },\r\n      { userId: '10', username: 'FlashGenius', score: 12, rank: 10, change: 0 }\r\n    ],\r\n    updatedAt: new Date().toISOString()\r\n  }\r\n}\r\n\r\n// Helper function to calculate level from XP\r\nconst calculateLevel = (xp: number): number => {\r\n  return Math.floor(Math.sqrt(xp / 100)) + 1\r\n}\r\n\r\n// Helper function to calculate XP needed for next level\r\nconst calculateXPToNextLevel = (level: number): number => {\r\n  const nextLevelXP = Math.pow(level, 2) * 100\r\n  return nextLevelXP\r\n}\r\n\r\n// Initial clean state for new users\r\nconst getInitialUserStats = (): UserStats => ({\r\n  totalCards: 0,\r\n  cardsStudiedToday: 0,\r\n  cardsStudiedThisWeek: 0,\r\n  cardsStudiedThisMonth: 0,\r\n  averageAccuracy: 0,\r\n  totalStudyTime: 0,\r\n  studyTimeToday: 0,\r\n  studyTimeThisWeek: 0,\r\n  decksCreated: 0,\r\n  decksCompleted: 0,\r\n  longestStreak: 0,\r\n  currentStreak: 0,\r\n  gold: 0,\r\n  diamonds: 0,\r\n  level: 1,\r\n  xp: 0,\r\n  xpToNextLevel: 100\r\n})\r\n\r\n// Demo data for demonstration purposes\r\nconst getDemoUserStats = (): UserStats => ({\r\n  totalCards: 1250,\r\n  cardsStudiedToday: 45,\r\n  cardsStudiedThisWeek: 180,\r\n  cardsStudiedThisMonth: 720,\r\n  averageAccuracy: 87.5,\r\n  totalStudyTime: 2400, // 40 hours\r\n  studyTimeToday: 35,\r\n  studyTimeThisWeek: 240, // 4 hours\r\n  decksCreated: 8,\r\n  decksCompleted: 3,\r\n  longestStreak: 28,\r\n  currentStreak: 12,\r\n  gold: 100,\r\n  diamonds: 10,\r\n  level: 8,\r\n  xp: 6400,\r\n  xpToNextLevel: 8100\r\n})\r\n\r\nexport const useGamificationStore = create<GamificationState>()(\r\n  persist(\r\n    (set, get) => ({\r\n      userStats: getInitialUserStats(),\r\n      isFirstTimeUser: true,\r\n      isInitialized: false,\r\n      \r\n      achievements: mockAchievements,\r\n      userAchievements: [],\r\n      \r\n      userStreak: null,\r\n      \r\n      activeChallenges: mockChallenges,\r\n      userChallengeParticipations: [],\r\n      \r\n      leaderboards: mockLeaderboards,\r\n      \r\n      updateUserStats: (stats) => {\r\n        set((state) => {\r\n          const newStats = { ...state.userStats, ...stats }\r\n          \r\n          // Recalculate level and XP if XP changed\r\n          if (stats.xp !== undefined) {\r\n            newStats.level = calculateLevel(newStats.xp)\r\n            newStats.xpToNextLevel = calculateXPToNextLevel(newStats.level)\r\n          }\r\n          \r\n          return {\r\n            userStats: newStats,\r\n            isFirstTimeUser: false,\r\n            isInitialized: true\r\n          }\r\n        })\r\n      },\r\n      \r\n      addUserAchievement: (achievementId) => {\r\n        const { userAchievements } = get()\r\n        if (!userAchievements.find(ua => ua.achievementId === achievementId)) {\r\n          set((state) => ({\r\n            userAchievements: [\r\n              ...state.userAchievements,\r\n              {\r\n                id: Date.now().toString(),\r\n                userId: '1',\r\n                achievementId,\r\n                earnedAt: new Date().toISOString()\r\n              }\r\n            ]\r\n          }))\r\n        }\r\n      },\r\n      \r\n      updateStreak: (streak) => {\r\n        set((state) => ({\r\n          userStreak: state.userStreak ? { ...state.userStreak, ...streak } : null\r\n        }))\r\n      },\r\n      \r\n      joinChallenge: (challengeId) => {\r\n        const { userChallengeParticipations } = get()\r\n        if (!userChallengeParticipations.find(p => p.challengeId === challengeId)) {\r\n          set((state) => ({\r\n            userChallengeParticipations: [\r\n              ...state.userChallengeParticipations,\r\n              {\r\n                id: Date.now().toString(),\r\n                userId: '1',\r\n                challengeId,\r\n                progress: {},\r\n                completed: false,\r\n                joinedAt: new Date().toISOString(),\r\n                milestoneProgress: {},\r\n                weeklyProgress: [],\r\n                currentStreak: 0,\r\n                bestWeek: 0\r\n              }\r\n            ]\r\n          }))\r\n        }\r\n      },\r\n      \r\n      updateChallengeProgress: (challengeId, progress) => {\r\n        set((state) => ({\r\n          userChallengeParticipations: state.userChallengeParticipations.map(p =>\r\n            p.challengeId === challengeId\r\n              ? { ...p, progress: { ...p.progress, ...progress } }\r\n              : p\r\n          )\r\n        }))\r\n      },\r\n      \r\n      claimChallengeReward: (challengeId) => {\r\n        const { activeChallenges, userChallengeParticipations } = get()\r\n        const challenge = activeChallenges.find(c => c.id === challengeId)\r\n        const participation = userChallengeParticipations.find(p => p.challengeId === challengeId)\r\n        \r\n        if (challenge && participation && participation.completed) {\r\n          // Calculate total XP and coins from rewards\r\n          let xpGained = 0\r\n          // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n          let _coinsGained = 0\r\n          \r\n          challenge.rewards.forEach(reward => {\r\n            if (reward.type === 'xp' && reward.amount) {\r\n              xpGained += reward.amount\r\n            } else if (reward.type === 'coins' && reward.amount) {\r\n              _coinsGained += reward.amount\r\n            }\r\n          })\r\n          \r\n          // Update user stats with rewards\r\n          set((state) => ({\r\n            userStats: {\r\n              ...state.userStats,\r\n              totalCards: state.userStats.totalCards + xpGained / 10 // Rough conversion\r\n            },\r\n            // Remove the participation since reward is claimed\r\n            userChallengeParticipations: state.userChallengeParticipations.filter(\r\n              p => p.challengeId !== challengeId\r\n            )\r\n          }))\r\n        }\r\n      },\r\n      \r\n      initializeMockData: () => {\r\n        // This function can be called to load demo data\r\n        set({\r\n          userStats: getDemoUserStats(),\r\n          achievements: mockAchievements,\r\n          activeChallenges: mockChallenges,\r\n          leaderboards: mockLeaderboards,\r\n          userAchievements: [\r\n            {\r\n              id: '1',\r\n              userId: '1',\r\n              achievementId: '1',\r\n              earnedAt: new Date(Date.now() - 10 * 24 * 60 * 60 * 1000).toISOString()\r\n            },\r\n            {\r\n              id: '2',\r\n              userId: '1',\r\n              achievementId: '2',\r\n              earnedAt: new Date(Date.now() - 5 * 24 * 60 * 60 * 1000).toISOString()\r\n            }\r\n          ],\r\n          userStreak: {\r\n            id: '1',\r\n            userId: '1',\r\n            currentStreak: 12,\r\n            longestStreak: 28,\r\n            lastStudyDate: new Date().toISOString(),\r\n            freezeCount: 2,\r\n            createdAt: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString()\r\n          },\r\n          userChallengeParticipations: [\r\n            {\r\n              id: '1',\r\n              userId: '1',\r\n              challengeId: '1',\r\n              progress: { cards_studied_today: 45 } as Record<string, number>,\r\n              completed: true,\r\n              joinedAt: new Date().toISOString(),\r\n              completedAt: new Date().toISOString(),\r\n              milestoneProgress: { 'milestone_1': true },\r\n              weeklyProgress: [],\r\n              currentStreak: 5,\r\n              bestWeek: 1\r\n            },\r\n            {\r\n              id: '2',\r\n              userId: '1',\r\n              challengeId: '2',\r\n              progress: { cards_studied_week: 180 } as Record<string, number>,\r\n              completed: false,\r\n              joinedAt: new Date(Date.now() - 3 * 24 * 60 * 60 * 1000).toISOString(),\r\n              milestoneProgress: { 'milestone_1': true, 'milestone_2': false },\r\n              weeklyProgress: [\r\n                {\r\n                  week: 1,\r\n                  startDate: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString(),\r\n                  endDate: new Date().toISOString(),\r\n                  progress: { cards_studied_week: 180 },\r\n                  completed: true,\r\n                  completedAt: new Date().toISOString(),\r\n                  storyUnlocked: true\r\n                }\r\n              ],\r\n              currentStreak: 3,\r\n              bestWeek: 1\r\n            }\r\n          ] as ChallengeParticipation[],\r\n          isFirstTimeUser: false,\r\n          isInitialized: true\r\n        })\r\n      },\r\n\r\n      initializeNewUser: () => {\r\n        // Initialize a completely fresh user\r\n        set({\r\n          userStats: getInitialUserStats(),\r\n          userAchievements: [],\r\n          userStreak: null,\r\n          userChallengeParticipations: [],\r\n          isFirstTimeUser: false,\r\n          isInitialized: true\r\n        })\r\n      },\r\n\r\n      resetAllUserData: () => {\r\n        // Reset all user-specific data to initial state\r\n        set({\r\n          userStats: getInitialUserStats(),\r\n          userAchievements: [],\r\n          userStreak: null,\r\n          userChallengeParticipations: [],\r\n          isFirstTimeUser: true,\r\n          isInitialized: true\r\n        })\r\n      },\r\n\r\n      addCurrency: (gold, diamonds) => {\r\n        set((state) => ({\r\n          userStats: {\r\n            ...state.userStats,\r\n            gold: state.userStats.gold + gold,\r\n            diamonds: state.userStats.diamonds + diamonds\r\n          }\r\n        }))\r\n      },\r\n\r\n      spendCurrency: (gold, diamonds) => {\r\n        const { userStats } = get()\r\n        if (userStats.gold >= gold && userStats.diamonds >= diamonds) {\r\n          set((state) => ({\r\n            userStats: {\r\n              ...state.userStats,\r\n              gold: state.userStats.gold - gold,\r\n              diamonds: state.userStats.diamonds - diamonds\r\n            }\r\n          }))\r\n          return true\r\n        }\r\n        return false\r\n      },\r\n\r\n      // Initialize user data based on authentication status\r\n      initializeUserData: (isDemo: boolean = false) => {\r\n        const state = get()\r\n        \r\n        // Only initialize if not already done\r\n        if (!state.isInitialized) {\r\n          if (isDemo) {\r\n            // Load demo data for demo users\r\n            set({\r\n              userStats: getDemoUserStats(),\r\n              achievements: mockAchievements,\r\n              activeChallenges: mockChallenges,\r\n              leaderboards: mockLeaderboards,\r\n              userAchievements: [\r\n                {\r\n                  id: '1',\r\n                  userId: '1',\r\n                  achievementId: '1',\r\n                  earnedAt: new Date(Date.now() - 10 * 24 * 60 * 60 * 1000).toISOString()\r\n                },\r\n                {\r\n                  id: '2',\r\n                  userId: '1',\r\n                  achievementId: '2',\r\n                  earnedAt: new Date(Date.now() - 5 * 24 * 60 * 60 * 1000).toISOString()\r\n                }\r\n              ],\r\n              userStreak: {\r\n                id: '1',\r\n                userId: '1',\r\n                currentStreak: 12,\r\n                longestStreak: 28,\r\n                lastStudyDate: new Date().toISOString(),\r\n                freezeCount: 2,\r\n                createdAt: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString()\r\n              },\r\n              userChallengeParticipations: [\r\n                {\r\n                  id: '1',\r\n                  userId: '1',\r\n                  challengeId: '1',\r\n                  progress: { cards_studied_today: 45 } as Record<string, number>,\r\n                  completed: true,\r\n                  joinedAt: new Date().toISOString(),\r\n                  completedAt: new Date().toISOString()\r\n                },\r\n                {\r\n                  id: '2',\r\n                  userId: '1',\r\n                  challengeId: '2',\r\n                  progress: { cards_studied_week: 180 } as Record<string, number>,\r\n                  completed: false,\r\n                  joinedAt: new Date(Date.now() - 3 * 24 * 60 * 60 * 1000).toISOString()\r\n                }\r\n              ] as ChallengeParticipation[],\r\n              isFirstTimeUser: false,\r\n              isInitialized: true\r\n            })\r\n          } else {\r\n            // Initialize fresh user data for new authenticated users\r\n            set({\r\n              userStats: getInitialUserStats(),\r\n              userAchievements: [],\r\n              userStreak: null,\r\n              userChallengeParticipations: [],\r\n              isFirstTimeUser: false,\r\n              isInitialized: true\r\n            })\r\n          }\r\n        }\r\n      },\r\n\r\n      // Monthly Challenge Management Methods\r\n      updateMilestoneProgress: (challengeId, milestoneId, completed) => {\r\n        set((state) => ({\r\n          userChallengeParticipations: state.userChallengeParticipations.map(p =>\r\n            p.challengeId === challengeId\r\n              ? {\r\n                  ...p,\r\n                  milestoneProgress: {\r\n                    ...p.milestoneProgress,\r\n                    [milestoneId]: completed\r\n                  }\r\n                }\r\n              : p\r\n          )\r\n        }))\r\n      },\r\n\r\n      updateWeeklyProgress: (challengeId, weekData) => {\r\n        set((state) => ({\r\n          userChallengeParticipations: state.userChallengeParticipations.map(p =>\r\n            p.challengeId === challengeId\r\n              ? {\r\n                  ...p,\r\n                  weeklyProgress: p.weeklyProgress\r\n                    ? [...p.weeklyProgress.filter(w => w.week !== weekData.week), weekData]\r\n                    : [weekData]\r\n                }\r\n              : p\r\n          )\r\n        }))\r\n      },\r\n\r\n      updateChallengeStreak: (challengeId, streak) => {\r\n        set((state) => ({\r\n          userChallengeParticipations: state.userChallengeParticipations.map(p =>\r\n            p.challengeId === challengeId\r\n              ? { ...p, currentStreak: streak }\r\n              : p\r\n          )\r\n        }))\r\n      },\r\n\r\n      unlockStoryChapter: (challengeId, week) => {\r\n        set((state) => ({\r\n          userChallengeParticipations: state.userChallengeParticipations.map(p =>\r\n            p.challengeId === challengeId\r\n              ? {\r\n                  ...p,\r\n                  weeklyProgress: p.weeklyProgress?.map(w =>\r\n                    w.week === week\r\n                      ? { ...w, storyUnlocked: true }\r\n                      : w\r\n                  ) || []\r\n                }\r\n              : p\r\n          )\r\n        }))\r\n      },\r\n\r\n      claimMilestoneReward: (challengeId, milestoneId) => {\r\n        // Find the challenge and milestone to get reward details\r\n        const { activeChallenges } = get()\r\n        const challenge = activeChallenges.find(c => c.id === challengeId)\r\n        \r\n        if (challenge) {\r\n          // Add milestone reward logic here\r\n          // For now, just mark milestone as claimed\r\n          set((state) => ({\r\n            userChallengeParticipations: state.userChallengeParticipations.map(p =>\r\n              p.challengeId === challengeId\r\n                ? {\r\n                    ...p,\r\n                    milestoneProgress: {\r\n                      ...p.milestoneProgress,\r\n                      [`${milestoneId}_claimed`]: true\r\n                    }\r\n                  }\r\n                : p\r\n            )\r\n          }))\r\n        }\r\n      },\r\n\r\n      contributeToCommunityGoal: (goalId, contribution) => {\r\n        // Update community goal progress\r\n        // This would typically involve API calls to update server-side data\r\n        // For now, we'll just update local state\r\n        console.log(`Contributing ${contribution} to community goal ${goalId}`)\r\n        \r\n        // Update user stats to reflect contribution\r\n        set((state) => ({\r\n          userStats: {\r\n            ...state.userStats,\r\n            // Add contribution tracking if needed\r\n          }\r\n        }))\r\n      },\r\n\r\n      awardStudyXP: (cardsStudied, correctAnswers) => {\r\n        // Award XP based on study performance\r\n        // Base XP: 1 XP per card studied\r\n        // Bonus XP: 1 additional XP per correct answer (rating higher than \"Again\")\r\n        // Milestone bonus: 10 XP for every 10 cards studied with good performance\r\n        \r\n        let xpGained = cardsStudied // Base XP\r\n        xpGained += correctAnswers // Bonus for correct answers\r\n        \r\n        // Milestone bonus: 10 XP for every 10 cards with good performance\r\n        const milestoneBonus = Math.floor(correctAnswers / 10) * 10\r\n        xpGained += milestoneBonus\r\n        \r\n        if (xpGained > 0) {\r\n          set((state) => {\r\n            const newXP = state.userStats.xp + xpGained\r\n            const newLevel = calculateLevel(newXP)\r\n            const newXPToNextLevel = calculateXPToNextLevel(newLevel)\r\n            \r\n            console.log(` XP Awarded: +${xpGained} XP (${cardsStudied} cards, ${correctAnswers} correct, ${milestoneBonus} milestone bonus)`)\r\n            console.log(` Total XP: ${state.userStats.xp}  ${newXP} (Level ${state.userStats.level}  ${newLevel})`)\r\n            \r\n            return {\r\n              userStats: {\r\n                ...state.userStats,\r\n                xp: newXP,\r\n                level: newLevel,\r\n                xpToNextLevel: newXPToNextLevel,\r\n                totalCards: state.userStats.totalCards + cardsStudied,\r\n                cardsStudiedToday: state.userStats.cardsStudiedToday + cardsStudied\r\n              }\r\n            }\r\n          })\r\n        }\r\n      }\r\n    }),\r\n    {\r\n      name: 'gamification-storage',\r\n      partialize: (state) => ({\r\n        userStats: state.userStats,\r\n        userAchievements: state.userAchievements,\r\n        userStreak: state.userStreak,\r\n        userChallengeParticipations: state.userChallengeParticipations,\r\n        isFirstTimeUser: state.isFirstTimeUser,\r\n        isInitialized: state.isInitialized\r\n      })\r\n    }\r\n  )\r\n)"],"file":"stores-sGyTT1ft.js"}