const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/zip-vendor-C6asOhRA.js","assets/react-vendor-Cb7t3V5P.js","assets/vendor-By12O1K7.js","assets/ui-vendor-C86Gg0gy.js","assets/sql-vendor-BY3SVwKM.js"])))=>i.map(i=>d[i]);
import{c as e,d as t,p as r,a}from"./data-vendor-WMMcZ37Z.js";import{e as s,d as n}from"./services-C299jnKw.js";const o="modulepreload",assetsURL=function(e){return"/"+e},i={},d=function preload(e,t,r){let a=Promise.resolve();if(t&&t.length>0){document.getElementsByTagName("link");const s=document.querySelector("meta[property=csp-nonce]"),n=s?.nonce||s?.getAttribute("nonce");function allSettled(e){return Promise.all(e.map(e=>Promise.resolve(e).then(e=>({status:"fulfilled",value:e}),e=>({status:"rejected",reason:e}))))}a=allSettled(t.map(e=>{if((e=assetsURL(e))in i)return;i[e]=!0;const t=e.endsWith(".css"),r=t?'[rel="stylesheet"]':"";if(document.querySelector(`link[href="${e}"]${r}`))return;const a=document.createElement("link");return a.rel=t?"stylesheet":o,t||(a.as="script"),a.crossOrigin="",a.href=e,n&&a.setAttribute("nonce",n),document.head.appendChild(a),t?new Promise((t,r)=>{a.addEventListener("load",t),a.addEventListener("error",()=>r(new Error(`Unable to preload CSS for ${e}`)))}):void 0}))}function handlePreloadError(e){const t=new Event("vite:preloadError",{cancelable:!0});if(t.payload=e,window.dispatchEvent(t),!t.defaultPrevented)throw e}return a.then(t=>{for(const e of t||[])"rejected"===e.status&&handlePreloadError(e.reason);return e().catch(handlePreloadError)})},c={required:(e="This field is required")=>({test:e=>e.trim().length>0,message:e}),minLength:(e,t)=>({test:t=>t.length>=e,message:t||`Must be at least ${e} characters long`}),maxLength:(e,t)=>({test:t=>t.length<=e,message:t||`Must be no more than ${e} characters long`}),email:(e="Please enter a valid email address")=>({test:e=>/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(e),message:e}),password:(e="Password must be at least 8 characters with uppercase, lowercase, number, and special character")=>({test:e=>/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/.test(e),message:e}),username:(e="Username must be 3-50 characters and contain only letters, numbers, and underscores")=>({test:e=>/^[a-zA-Z0-9_]{3,50}$/.test(e),message:e}),noXSS:(e="Invalid characters detected")=>({test:e=>!/<script|javascript:|data:|vbscript:|onload=|onerror=/i.test(e),message:e}),noSQLInjection:(e="Invalid characters detected")=>({test:e=>![/'/,/\\'/,/;/,/--/,/\/\*/,/(union|select|insert|delete|update|drop|create|alter|exec|execute)\s/i].some(t=>t.test(e)),message:e})};function validateField(e,t){const r=[];for(const a of t)a.test(e)||r.push(a.message);return{isValid:0===r.length,errors:r}}function validateForm(e,t){const r={};for(const[a,s]of Object.entries(t)){const t=e[a]||"";r[a]=validateField(t,s)}return r}function sanitizeInput(e){return e.replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;").replace(/'/g,"&#x27;").replace(/\//g,"&#x2F;").trim()}const l={signUp:{email:[c.required(),c.email()],password:[c.required(),c.password()],username:[c.required(),c.username()]},signIn:{email:[c.required()],password:[c.required(),c.minLength(6)]}},convertPocketbaseUser=async e=>{t.log("[POCKETBASE_AUTH_STORE]","START - convertPocketbaseUser",{userId:e.id,email:e.email,username:e.username});try{const r={id:e.id,email:e.email,username:e.username||e.email?.split("@")[0]||"User",level:e.level||1,totalXp:e.total_xp||0,coins:e.coins||100,gems:e.gems||10,createdAt:e.created||(new Date).toISOString(),lastActive:e.last_active||(new Date).toISOString(),preferences:e.preferences||{theme:"system",language:"en",notifications:!0,soundEffects:!0,dailyGoal:50,timezone:"UTC"}};return t.log("[POCKETBASE_AUTH_STORE]","END - convertPocketbaseUser",r),r}catch(r){t.error("[POCKETBASE_AUTH_STORE]","Error in convertPocketbaseUser",{error:r,stack:r instanceof Error?r.stack:void 0,userId:e.id});const a={id:e.id,email:e.email||"unknown@example.com",username:e.username||e.email?.split("@")[0]||"User",level:1,totalXp:0,coins:100,gems:10,createdAt:e.created||(new Date).toISOString(),lastActive:(new Date).toISOString(),preferences:{theme:"system",language:"en",notifications:!0,soundEffects:!0,dailyGoal:50,timezone:"UTC"}};return t.log("[POCKETBASE_AUTH_STORE]","END - convertPocketbaseUser (fallback)",a),a}},validateSignUpInputs=(e,t,r)=>{const a=validateForm({email:e,password:t,username:r},l.signUp),s=Object.entries(a).filter(([e,t])=>!t.isValid).map(([e,t])=>`${e}: ${t.errors.join(", ")}`);if(s.length>0)throw new Error(s.join("; "))},validateSignInInputs=(e,t)=>{const r=validateForm({email:e,password:t},l.signIn),a=Object.entries(r).filter(([e,t])=>!t.isValid).map(([e,t])=>`${e}: ${t.errors.join(", ")}`);if(a.length>0)throw new Error(a.join("; "))},createPocketBaseUserData=(e,t,r)=>({username:sanitizeInput(t),email:sanitizeInput(e),password:r,passwordConfirm:r,level:1,total_xp:0,coins:100,gems:10,last_active:(new Date).toISOString(),preferences:{theme:"system",language:"en",notifications:!0,soundEffects:!0,dailyGoal:50,timezone:"UTC"}}),handleSignUpError=e=>e instanceof Error?e.message.includes("username")?"Username already exists or is invalid":e.message.includes("email")?"Email already exists or is invalid":e.message:"Registration failed",handleSignInError=e=>e instanceof Error?e.message.includes("Failed to authenticate")?"Invalid email/username or password. Please check your credentials and try again.":e.message.includes("Too many requests")?"Too many login attempts. Please wait a moment and try again.":e.message:"Login failed",isDemoLogin=(e,t)=>!1,performPocketBaseAuth=async(e,a)=>{const s=sanitizeInput(e);try{return await r.collection("users").authWithPassword(s,a)}catch(n){return t.log("[POCKETBASE_AUTH_STORE]","Email login failed, trying username"),await r.collection("users").authWithPassword(s,a)}},updateUserLastActive=async e=>{try{await r.collection("users").update(e,{last_active:(new Date).toISOString()}),t.log("[POCKETBASE_AUTH_STORE]","Updated last active time")}catch(a){t.warn("[POCKETBASE_AUTH_STORE]","Could not update last active time",{error:a})}},u=e()((e,a)=>({user:null,session:null,isAuthenticated:!1,isLoading:!1,error:null,signUp:async(a,s,n)=>{t.log("[POCKETBASE_AUTH_STORE]","START - signUp",{email:a,username:n,passwordLength:s.length}),e({isLoading:!0,error:null});try{validateSignUpInputs(a,s,n);const o=createPocketBaseUserData(a,n,s);t.log("[POCKETBASE_AUTH_STORE]","Creating user in PocketBase",{email:o.email,username:o.username});const i=await r.collection("users").create(o);t.log("[POCKETBASE_AUTH_STORE]","User created successfully",{userId:i.id});const d=await r.collection("users").authWithPassword(o.email,s);t.log("[POCKETBASE_AUTH_STORE]","SignUp with auth successful",{userId:d.record.id,hasToken:!!d.token});const c=await convertPocketbaseUser(d.record);e({user:c,session:d,isAuthenticated:!0,isLoading:!1,error:null})}catch(o){t.error("[POCKETBASE_AUTH_STORE]","SignUp error",{error:o,stack:o instanceof Error?o.stack:void 0}),e({error:handleSignUpError(o),isLoading:!1})}t.log("[POCKETBASE_AUTH_STORE]","END - signUp")},signIn:async(r,a)=>{t.log("[POCKETBASE_AUTH_STORE]","START - signIn",{email:r,passwordLength:a.length,isDemoLogin:"demo"===r}),e({isLoading:!0,error:null});const s=setTimeout(()=>{t.warn("[POCKETBASE_AUTH_STORE]","SignIn timeout reached"),e({isLoading:!1,error:"Login timed out. Please try again."})},1e4);try{isDemoLogin(r,a),validateSignInInputs(r,a),t.log("[POCKETBASE_AUTH_STORE]","Attempting PocketBase authentication");const n=await performPocketBaseAuth(r,a);if(t.log("[POCKETBASE_AUTH_STORE]","SignIn response",{hasRecord:!!n.record,hasToken:!!n.token,userId:n.record?.id}),n.record&&n.token){t.log("[POCKETBASE_AUTH_STORE]","SignIn successful, converting user profile");const r=await convertPocketbaseUser(n.record);await updateUserLastActive(n.record.id),clearTimeout(s),e({user:r,session:n,isAuthenticated:!0,isLoading:!1,error:null}),t.log("[POCKETBASE_AUTH_STORE]","END - signIn (success)")}else t.warn("[POCKETBASE_AUTH_STORE]","No user or token in response"),clearTimeout(s),e({error:"Invalid login response - no user or token",isLoading:!1})}catch(n){t.error("[POCKETBASE_AUTH_STORE]","SignIn error",{error:n,stack:n instanceof Error?n.stack:void 0}),clearTimeout(s),e({error:handleSignInError(n),isLoading:!1})}t.log("[POCKETBASE_AUTH_STORE]","END - signIn")},signOut:async()=>{t.log("[POCKETBASE_AUTH_STORE]","START - signOut");try{t.log("[POCKETBASE_AUTH_STORE]","Calling PocketBase authStore.clear"),r.authStore.clear(),t.log("[POCKETBASE_AUTH_STORE]","Clearing auth state"),e({user:null,session:null,isAuthenticated:!1,error:null}),t.log("[POCKETBASE_AUTH_STORE]","END - signOut (success)")}catch(a){t.error("[POCKETBASE_AUTH_STORE]","SignOut error",{error:a,stack:a instanceof Error?a.stack:void 0}),e({error:a instanceof Error?a.message:"Logout failed"})}},resetPassword:async a=>{t.log("[POCKETBASE_AUTH_STORE]","START - resetPassword",{email:a}),e({isLoading:!0,error:null});try{await r.collection("users").requestPasswordReset(a),e({isLoading:!1,error:null}),t.log("[POCKETBASE_AUTH_STORE]","END - resetPassword (success)")}catch(s){t.error("[POCKETBASE_AUTH_STORE]","Reset password error",{error:s,stack:s instanceof Error?s.stack:void 0});let r="Password reset failed";s instanceof Error&&(r=s.message.includes("Invalid email")?"Please enter a valid email address.":s.message.includes("not found")?"No account found with this email address.":s.message),e({error:r,isLoading:!1})}},updatePassword:async s=>{t.log("[POCKETBASE_AUTH_STORE]","START - updatePassword",{passwordLength:s.length});const n=a();t.log("[POCKETBASE_AUTH_STORE]","Current auth state",{hasUser:!!n.user,hasSession:!!n.session,isAuthenticated:n.isAuthenticated}),e({isLoading:!0,error:null});try{if(!s||s.length<6)throw new Error("Password must be at least 6 characters long.");if(!n.user?.id)throw new Error("No authenticated user found");t.log("[POCKETBASE_AUTH_STORE]","Calling pb.collection.update"),await r.collection("users").update(n.user.id,{password:s,passwordConfirm:s}),t.log("[POCKETBASE_AUTH_STORE]","Password update successful"),e({isLoading:!1,error:null}),t.log("[POCKETBASE_AUTH_STORE]","END - updatePassword (success)")}catch(o){const r=o instanceof Error?o.message:"An unknown error occurred during password update.";throw t.error("[POCKETBASE_AUTH_STORE]","UpdatePassword failed",{error:r,errorType:o?.constructor?.name,stack:o instanceof Error?o.stack:void 0}),e({isLoading:!1,error:r}),new Error(r)}},updateProfile:async s=>{const{user:n}=a();if(t.log("[POCKETBASE_AUTH_STORE]","START - updateProfile",{userId:n?.id,updates:Object.keys(s)}),n)try{const a={username:s.username,level:s.level,total_xp:s.totalXp,coins:s.coins,gems:s.gems,preferences:s.preferences,last_active:(new Date).toISOString()};t.log("[POCKETBASE_AUTH_STORE]","Updating profile in database",a),await r.collection("users").update(n.id,a),t.log("[POCKETBASE_AUTH_STORE]","Updating local user state"),e({user:{...n,...s}}),t.log("[POCKETBASE_AUTH_STORE]","END - updateProfile (success)")}catch(o){t.error("[POCKETBASE_AUTH_STORE]","Profile update error",{error:o,stack:o instanceof Error?o.stack:void 0}),e({error:o instanceof Error?o.message:"Profile update failed"})}else t.warn("[POCKETBASE_AUTH_STORE]","No user found for profile update")},clearError:()=>{t.log("[POCKETBASE_AUTH_STORE]","Clearing error state"),e({error:null})},initializeAuth:async()=>{t.log("[POCKETBASE_AUTH_STORE]","START - initializeAuth");try{if(r.authStore.isValid&&r.authStore.model){t.log("[POCKETBASE_AUTH_STORE]","Valid auth store found, converting user",{userId:r.authStore.model.id,email:r.authStore.model.email});const a=await convertPocketbaseUser(r.authStore.model);t.log("[POCKETBASE_AUTH_STORE]","Setting authenticated state from initialization"),e({user:a,session:{record:r.authStore.model,token:r.authStore.token},isAuthenticated:!0})}else t.info("[POCKETBASE_AUTH_STORE]","No valid auth store found during initialization");t.log("[POCKETBASE_AUTH_STORE]","END - initializeAuth")}catch(a){t.error("[POCKETBASE_AUTH_STORE]","Auth initialization error",{error:a,stack:a instanceof Error?a.stack:void 0}),e({user:null,session:null,isAuthenticated:!1})}},login:async(e,t)=>{const{signIn:r}=a();await r(e,t)},register:async(e,t,r)=>{const{signUp:s}=a();await s(e,r,t)},logout:()=>{const{signOut:e}=a();e()},updateUser:t=>{const{user:r}=a();r&&e({user:{...r,...t}})}}));r.authStore.onChange((e,r)=>{t.info("[POCKETBASE_AUTH_STORE]","Auth state change detected",{hasToken:!!e,hasRecord:!!r,userId:r?.id,timestamp:(new Date).toISOString()}),e&&r?(t.log("[POCKETBASE_AUTH_STORE]","Processing auth state change - user logged in"),convertPocketbaseUser(r).then(a=>{t.log("[POCKETBASE_AUTH_STORE]","Updating auth store for logged in user"),u.setState({user:a,session:{record:r,token:e},isAuthenticated:!0})}).catch(e=>{t.error("[POCKETBASE_AUTH_STORE]","Failed to convert user during auth change",{error:e,userId:r.id})})):(t.log("[POCKETBASE_AUTH_STORE]","Processing auth state change - user logged out"),u.setState({user:null,session:null,isAuthenticated:!1}))});const g=e()(a((e,t)=>({theme:"system",systemTheme:"light",setTheme:r=>{e({theme:r});const{systemTheme:a}=t();"dark"===("system"===r?a:r)?document.documentElement.classList.add("dark"):document.documentElement.classList.remove("dark")},toggleTheme:()=>{const{theme:e}=t(),r="light"===e?"dark":"light";t().setTheme(r)},initializeTheme:()=>{const r=window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light";e({systemTheme:r}),window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change",r=>{const a=r.matches?"dark":"light";e({systemTheme:a});const{theme:s}=t();"system"===s&&("dark"===a?document.documentElement.classList.add("dark"):document.documentElement.classList.remove("dark"))});const{theme:a}=t();"dark"===("system"===a?r:a)?document.documentElement.classList.add("dark"):document.documentElement.classList.remove("dark")}}),{name:"theme-storage",partialize:e=>({theme:e.theme})})),m=[{id:"1",name:"First Steps",description:"Complete your first study session",icon:"ðŸŽ¯",category:"study_milestones",requirements:[{type:"sessions_completed",value:1,operator:"gte"}],xpReward:50,coinReward:10,isSecret:!1,rarity:"common"},{id:"2",name:"Streak Master",description:"Maintain a 7-day study streak",icon:"ðŸ”¥",category:"streaks",requirements:[{type:"current_streak",value:7,operator:"gte"}],xpReward:200,coinReward:50,isSecret:!1,rarity:"rare"},{id:"3",name:"Perfect Score",description:"Get 100% accuracy in a 20+ card session",icon:"ðŸ’¯",category:"accuracy",requirements:[{type:"session_accuracy",value:100,operator:"eq"},{type:"session_cards",value:20,operator:"gte"}],xpReward:150,coinReward:30,isSecret:!1,rarity:"rare"},{id:"4",name:"Speed Demon",description:"Complete 50 cards in under 10 minutes",icon:"âš¡",category:"special",requirements:[{type:"cards_in_session",value:50,operator:"gte"},{type:"session_time",value:600,operator:"lte"}],xpReward:300,coinReward:75,isSecret:!1,rarity:"epic"},{id:"5",name:"Scholar",description:"Study 1000 cards total",icon:"ðŸ“š",category:"study_milestones",requirements:[{type:"total_cards",value:1e3,operator:"gte"}],xpReward:500,coinReward:100,isSecret:!1,rarity:"epic"},{id:"6",name:"Legend",description:"Reach level 20",icon:"ðŸ‘‘",category:"special",requirements:[{type:"user_level",value:20,operator:"gte"}],xpReward:1e3,coinReward:500,isSecret:!1,rarity:"legendary"}],p=[{id:"1",title:"Daily Grind",description:"Study 25 cards today",type:"daily",requirements:[{type:"cards_studied_today",target:25,description:"Study 25 cards"}],rewards:[{type:"xp",amount:50},{type:"coins",amount:10}],startDate:(new Date).toISOString(),endDate:new Date(Date.now()+864e5).toISOString(),isActive:!0,participantCount:1247},{id:"2",title:"Weekly Warrior",description:"Complete 200 cards this week",type:"weekly",requirements:[{type:"cards_studied_week",target:200,description:"Study 200 cards this week"}],rewards:[{type:"xp",amount:200},{type:"coins",amount:50},{type:"gems",amount:5}],startDate:new Date(Date.now()-2592e5).toISOString(),endDate:new Date(Date.now()+3456e5).toISOString(),isActive:!0,participantCount:892},{id:"3",title:"Accuracy Master",description:"Maintain 90%+ accuracy for 5 sessions",type:"weekly",requirements:[{type:"accuracy_sessions",target:5,description:"Complete 5 sessions with 90%+ accuracy"}],rewards:[{type:"xp",amount:300},{type:"coins",amount:75},{type:"badge",itemId:"accuracy_master"}],startDate:new Date(Date.now()-1728e5).toISOString(),endDate:new Date(Date.now()+432e6).toISOString(),isActive:!0,participantCount:456}],h={xp_weekly:{id:"xp_weekly",type:"xp",period:"weekly",entries:[{userId:"1",username:"DemoUser",score:2500,rank:1,change:0},{userId:"2",username:"StudyMaster",score:2350,rank:2,change:1},{userId:"3",username:"FlashcardPro",score:2200,rank:3,change:-1},{userId:"4",username:"LearnFast",score:2100,rank:4,change:2},{userId:"5",username:"MemoryKing",score:2050,rank:5,change:-1},{userId:"6",username:"QuizWhiz",score:1980,rank:6,change:0},{userId:"7",username:"CardShark",score:1920,rank:7,change:3},{userId:"8",username:"BrainBoost",score:1850,rank:8,change:-2},{userId:"9",username:"StudyBuddy",score:1800,rank:9,change:1},{userId:"10",username:"FlashGenius",score:1750,rank:10,change:-1}],updatedAt:(new Date).toISOString()},streak_all_time:{id:"streak_all_time",type:"streak",period:"all_time",entries:[{userId:"2",username:"StudyMaster",score:45,rank:1,change:0},{userId:"3",username:"FlashcardPro",score:38,rank:2,change:0},{userId:"4",username:"LearnFast",score:32,rank:3,change:1},{userId:"1",username:"DemoUser",score:28,rank:4,change:-1},{userId:"5",username:"MemoryKing",score:25,rank:5,change:0},{userId:"6",username:"QuizWhiz",score:22,rank:6,change:2},{userId:"7",username:"CardShark",score:20,rank:7,change:-1},{userId:"8",username:"BrainBoost",score:18,rank:8,change:-1},{userId:"9",username:"StudyBuddy",score:15,rank:9,change:0},{userId:"10",username:"FlashGenius",score:12,rank:10,change:0}],updatedAt:(new Date).toISOString()}},calculateLevel=e=>Math.floor(Math.sqrt(e/100))+1,calculateXPToNextLevel=e=>100*Math.pow(e,2),getInitialUserStats=()=>({totalCards:0,cardsStudiedToday:0,cardsStudiedThisWeek:0,cardsStudiedThisMonth:0,averageAccuracy:0,totalStudyTime:0,studyTimeToday:0,studyTimeThisWeek:0,decksCreated:0,decksCompleted:0,longestStreak:0,currentStreak:0,gold:0,diamonds:0,level:1,xp:0,xpToNextLevel:100}),getDemoUserStats=()=>({totalCards:1250,cardsStudiedToday:45,cardsStudiedThisWeek:180,cardsStudiedThisMonth:720,averageAccuracy:87.5,totalStudyTime:2400,studyTimeToday:35,studyTimeThisWeek:240,decksCreated:8,decksCompleted:3,longestStreak:28,currentStreak:12,gold:100,diamonds:10,level:8,xp:6400,xpToNextLevel:8100}),S=e()(a((e,t)=>({userStats:getInitialUserStats(),isFirstTimeUser:!0,isInitialized:!1,achievements:m,userAchievements:[],userStreak:null,activeChallenges:p,userChallengeParticipations:[],leaderboards:h,updateUserStats:t=>{e(e=>{const r={...e.userStats,...t};return void 0!==t.xp&&(r.level=calculateLevel(r.xp),r.xpToNextLevel=calculateXPToNextLevel(r.level)),{userStats:r,isFirstTimeUser:!1,isInitialized:!0}})},addUserAchievement:r=>{const{userAchievements:a}=t();a.find(e=>e.achievementId===r)||e(e=>({userAchievements:[...e.userAchievements,{id:Date.now().toString(),userId:"1",achievementId:r,earnedAt:(new Date).toISOString()}]}))},updateStreak:t=>{e(e=>({userStreak:e.userStreak?{...e.userStreak,...t}:null}))},joinChallenge:r=>{const{userChallengeParticipations:a}=t();a.find(e=>e.challengeId===r)||e(e=>({userChallengeParticipations:[...e.userChallengeParticipations,{id:Date.now().toString(),userId:"1",challengeId:r,progress:{},completed:!1,joinedAt:(new Date).toISOString(),milestoneProgress:{},weeklyProgress:[],currentStreak:0,bestWeek:0}]}))},updateChallengeProgress:(t,r)=>{e(e=>({userChallengeParticipations:e.userChallengeParticipations.map(e=>e.challengeId===t?{...e,progress:{...e.progress,...r}}:e)}))},claimChallengeReward:r=>{const{activeChallenges:a,userChallengeParticipations:s}=t(),n=a.find(e=>e.id===r),o=s.find(e=>e.challengeId===r);if(n&&o&&o.completed){let t=0,a=0;n.rewards.forEach(e=>{"xp"===e.type&&e.amount?t+=e.amount:"coins"===e.type&&e.amount&&(a+=e.amount)}),e(e=>({userStats:{...e.userStats,totalCards:e.userStats.totalCards+t/10},userChallengeParticipations:e.userChallengeParticipations.filter(e=>e.challengeId!==r)}))}},initializeMockData:()=>{e({userStats:getDemoUserStats(),achievements:m,activeChallenges:p,leaderboards:h,userAchievements:[{id:"1",userId:"1",achievementId:"1",earnedAt:new Date(Date.now()-864e6).toISOString()},{id:"2",userId:"1",achievementId:"2",earnedAt:new Date(Date.now()-432e6).toISOString()}],userStreak:{id:"1",userId:"1",currentStreak:12,longestStreak:28,lastStudyDate:(new Date).toISOString(),freezeCount:2,createdAt:new Date(Date.now()-2592e6).toISOString()},userChallengeParticipations:[{id:"1",userId:"1",challengeId:"1",progress:{cards_studied_today:45},completed:!0,joinedAt:(new Date).toISOString(),completedAt:(new Date).toISOString(),milestoneProgress:{milestone_1:!0},weeklyProgress:[],currentStreak:5,bestWeek:1},{id:"2",userId:"1",challengeId:"2",progress:{cards_studied_week:180},completed:!1,joinedAt:new Date(Date.now()-2592e5).toISOString(),milestoneProgress:{milestone_1:!0,milestone_2:!1},weeklyProgress:[{week:1,startDate:new Date(Date.now()-6048e5).toISOString(),endDate:(new Date).toISOString(),progress:{cards_studied_week:180},completed:!0,completedAt:(new Date).toISOString(),storyUnlocked:!0}],currentStreak:3,bestWeek:1}],isFirstTimeUser:!1,isInitialized:!0})},initializeNewUser:()=>{e({userStats:getInitialUserStats(),userAchievements:[],userStreak:null,userChallengeParticipations:[],isFirstTimeUser:!1,isInitialized:!0})},resetAllUserData:()=>{e({userStats:getInitialUserStats(),userAchievements:[],userStreak:null,userChallengeParticipations:[],isFirstTimeUser:!0,isInitialized:!0})},addCurrency:(t,r)=>{e(e=>({userStats:{...e.userStats,gold:e.userStats.gold+t,diamonds:e.userStats.diamonds+r}}))},spendCurrency:(r,a)=>{const{userStats:s}=t();return s.gold>=r&&s.diamonds>=a&&(e(e=>({userStats:{...e.userStats,gold:e.userStats.gold-r,diamonds:e.userStats.diamonds-a}})),!0)},initializeUserData:(r=!1)=>{t().isInitialized||e(r?{userStats:getDemoUserStats(),achievements:m,activeChallenges:p,leaderboards:h,userAchievements:[{id:"1",userId:"1",achievementId:"1",earnedAt:new Date(Date.now()-864e6).toISOString()},{id:"2",userId:"1",achievementId:"2",earnedAt:new Date(Date.now()-432e6).toISOString()}],userStreak:{id:"1",userId:"1",currentStreak:12,longestStreak:28,lastStudyDate:(new Date).toISOString(),freezeCount:2,createdAt:new Date(Date.now()-2592e6).toISOString()},userChallengeParticipations:[{id:"1",userId:"1",challengeId:"1",progress:{cards_studied_today:45},completed:!0,joinedAt:(new Date).toISOString(),completedAt:(new Date).toISOString()},{id:"2",userId:"1",challengeId:"2",progress:{cards_studied_week:180},completed:!1,joinedAt:new Date(Date.now()-2592e5).toISOString()}],isFirstTimeUser:!1,isInitialized:!0}:{userStats:getInitialUserStats(),userAchievements:[],userStreak:null,userChallengeParticipations:[],isFirstTimeUser:!1,isInitialized:!0})},updateMilestoneProgress:(t,r,a)=>{e(e=>({userChallengeParticipations:e.userChallengeParticipations.map(e=>e.challengeId===t?{...e,milestoneProgress:{...e.milestoneProgress,[r]:a}}:e)}))},updateWeeklyProgress:(t,r)=>{e(e=>({userChallengeParticipations:e.userChallengeParticipations.map(e=>e.challengeId===t?{...e,weeklyProgress:e.weeklyProgress?[...e.weeklyProgress.filter(e=>e.week!==r.week),r]:[r]}:e)}))},updateChallengeStreak:(t,r)=>{e(e=>({userChallengeParticipations:e.userChallengeParticipations.map(e=>e.challengeId===t?{...e,currentStreak:r}:e)}))},unlockStoryChapter:(t,r)=>{e(e=>({userChallengeParticipations:e.userChallengeParticipations.map(e=>e.challengeId===t?{...e,weeklyProgress:e.weeklyProgress?.map(e=>e.week===r?{...e,storyUnlocked:!0}:e)||[]}:e)}))},claimMilestoneReward:(r,a)=>{const{activeChallenges:s}=t();s.find(e=>e.id===r)&&e(e=>({userChallengeParticipations:e.userChallengeParticipations.map(e=>e.challengeId===r?{...e,milestoneProgress:{...e.milestoneProgress,[`${a}_claimed`]:!0}}:e)}))},contributeToCommunityGoal:(t,r)=>{console.log(`Contributing ${r} to community goal ${t}`),e(e=>({userStats:{...e.userStats}}))},awardStudyXP:(t,r)=>{let a=t;a+=r;const s=10*Math.floor(r/10);a+=s,a>0&&e(e=>{const n=e.userStats.xp+a,o=calculateLevel(n),i=calculateXPToNextLevel(o);return console.log(`ðŸŽ‰ XP Awarded: +${a} XP (${t} cards, ${r} correct, ${s} milestone bonus)`),console.log(`ðŸ“Š Total XP: ${e.userStats.xp} â†’ ${n} (Level ${e.userStats.level} â†’ ${o})`),{userStats:{...e.userStats,xp:n,level:o,xpToNextLevel:i,totalCards:e.userStats.totalCards+t,cardsStudiedToday:e.userStats.cardsStudiedToday+t}}})}}),{name:"gamification-storage",partialize:e=>({userStats:e.userStats,userAchievements:e.userAchievements,userStreak:e.userStreak,userChallengeParticipations:e.userChallengeParticipations,isFirstTimeUser:e.isFirstTimeUser,isInitialized:e.isInitialized})}));function createNewCard(e,t,r={type:"basic"},a=[]){return{frontContent:e,backContent:t,cardType:r,mediaRefs:a,state:"new",queue:0,due:0,ivl:0,factor:2500,reps:0,lapses:0,left:0,learningStep:0,graduationInterval:1,easyInterval:4,totalStudyTime:0,averageAnswerTime:0,flags:0,originalDue:0,originalDeck:"",xpAwarded:0,difficultyRating:3}}const nowTs=()=>Date.now();async function createDeckIndexedDB(e){await s();const t=nowTs(),r={deckId:e.deckId,name:e.name,description:e.description,cardCount:0,mediaCount:0,meta:e.meta,createdAt:t,updatedAt:t};return await n.decks.add(r),r}async function getDeckIndexedDB(e){return await s(),await n.decks.get(e)??null}async function listDecksIndexedDB(){return await s(),n.decks.orderBy("updatedAt").reverse().toArray()}async function updateDeckIndexedDB(e,t){await s();const r=await n.decks.get(e);if(!r)throw new Error(`Deck not found: ${e}`);const a={...r,...t,updatedAt:nowTs()};return await n.decks.put(a),a}async function removeDeckIndexedDB(e){await s(),await n.decks.delete(e)}async function createCardIndexedDB(e){await s();const t=nowTs(),r={cardId:e.cardId,deckId:e.deckId,fields:e.fields,mediaRefs:e.mediaRefs??[],dueAt:e.dueAt??null,interval:e.interval??0,ease:e.ease??250,lapses:e.lapses??0,state:e.state??"new",createdAt:t,updatedAt:t};return await n.transaction("rw",n.cards,n.decks,async()=>{await n.cards.add(r);const e=await n.decks.get(r.deckId);e&&await n.decks.put({...e,cardCount:(e.cardCount??0)+1,updatedAt:nowTs()})}),r}async function getCardIndexedDB(e){return await s(),await n.cards.get(e)??null}async function listCardsByDeckIndexedDB(e){return await s(),n.cards.where("deckId").equals(e).sortBy("updatedAt")}async function updateCardIndexedDB(e,t){await s();const r=await n.cards.get(e);if(!r)throw new Error(`Card not found: ${e}`);const a={...r,...t,updatedAt:nowTs()};return await n.cards.put(a),a}async function removeCardIndexedDB(e){await s();const t=await n.cards.get(e);await n.transaction("rw",n.cards,n.decks,async()=>{if(await n.cards.delete(e),t){const e=await n.decks.get(t.deckId);e&&await n.decks.put({...e,cardCount:Math.max(0,(e.cardCount??0)-1),updatedAt:nowTs()})}})}async function addReviewIndexedDB(e){await s();const t={...e};return await n.reviews.add(t),t}async function listReviewsByCardIndexedDB(e,t=50){return await s(),n.reviews.where("cardId").equals(e).reverse().sortBy("reviewedAt").then(e=>e.slice(0,t))}async function putMediaIndexedDB(e){await s();const t=nowTs(),r={mediaHash:e.mediaHash,blob:e.blob,opfsPointer:e.opfsPointer,mimeType:e.mimeType,byteLength:e.byteLength??(e.blob?e.blob.size:0),validationMeta:e.validationMeta,securityFlags:e.securityFlags,createdAt:t,updatedAt:t};return await n.media.put(r),r}async function getMediaIndexedDB(e){return await s(),await n.media.get(e)??null}async function hasMediaIndexedDB(e){await s();return!!(await n.media.get(e))}async function removeMediaIndexedDB(e){await s(),await n.media.delete(e)}async function upsertAchievementIndexedDB(e){await s();const t=await n.achievements.get(e.achievementId),r={achievementId:e.achievementId,userId:e.userId,unlockedAt:e.unlockedAt??t?.unlockedAt,progress:e.progress??t?.progress??0,meta:{...t?.meta??{},...e.meta??{}}};return await n.achievements.put(r),r}async function listAchievementsByUserIndexedDB(e){return await s(),n.achievements.where("userId").equals(e).toArray()}async function setLeaderboardCacheIndexedDB(e){await s();const t={scope:e.scope,entries:e.entries,fetchedAt:e.fetchedAt??nowTs(),ttlMs:e.ttlMs};return await n.leaderboardCache.put(t),t}async function getLeaderboardCacheIndexedDB(e,t){await s();const r=await n.leaderboardCache.get(e);if(!r)return null;if(t?.ignoreTTL)return r;return nowTs()-r.fetchedAt>r.ttlMs?null:r}function createIndexedDBRepositories(){return{decks:{create:createDeckIndexedDB,get:getDeckIndexedDB,list:listDecksIndexedDB,update:updateDeckIndexedDB,remove:removeDeckIndexedDB},cards:{create:createCardIndexedDB,get:getCardIndexedDB,listByDeck:listCardsByDeckIndexedDB,update:updateCardIndexedDB,remove:removeCardIndexedDB},reviews:{add:addReviewIndexedDB,listByCard:listReviewsByCardIndexedDB},media:{put:putMediaIndexedDB,get:getMediaIndexedDB,has:hasMediaIndexedDB,remove:removeMediaIndexedDB},achievements:{upsert:upsertAchievementIndexedDB,listByUser:listAchievementsByUserIndexedDB},leaderboardCache:{set:setLeaderboardCacheIndexedDB,get:getLeaderboardCacheIndexedDB}}}const w=createIndexedDBRepositories();function uuid(){try{const e=globalThis.crypto;if(e&&"function"==typeof e.randomUUID)return e.randomUUID()}catch{}return"id_"+Math.random().toString(36).slice(2,10)}function buildNewDeckFromDomain(e){return{deckId:uuid(),name:e.title,description:e.description,meta:{userId:e.userId,tags:e.tags??[],category:e.category??null,settings:e.settings??null,advancedSettings:e.advancedSettings??null,isPublic:e.isPublic??!1}}}function buildNewCardFromDomain(e){const t=new Set(["new","learning","review","relearning"]).has(e.state)?e.state:"new";return{cardId:uuid(),deckId:e.deckId,fields:{front:e.frontContent,back:e.backContent},mediaRefs:(e.mediaRefs??[]).map(e=>e.id).filter(Boolean),state:t,ease:e.easeFactor??250,interval:e.intervalDays??0,dueAt:null,lapses:0}}function mapDeckUpdatesToRepo(e){const t={};"string"==typeof e.title&&(t.name=e.title),"string"==typeof e.description&&(t.description=e.description);const r={};return e.tags&&(r.tags=e.tags),e.category&&(r.category=e.category),e.settings&&(r.settings=e.settings),e.advancedSettings&&(r.advancedSettings=e.advancedSettings),Object.keys(r).length&&(t.meta=r),t}const k={newCardsPerDay:20,maxReviewsPerDay:100,easyBonus:1.3,intervalModifier:1,maximumInterval:36500,minimumInterval:1};async function persistCreateDeck(e){try{await w.decks.create(buildNewDeckFromDomain(e))}catch(t){console.warn("[deckStore] repo createDeck failed",t)}}async function persistAddCard(e,t){try{await w.cards.create(buildNewCardFromDomain({deckId:e,frontContent:t.frontContent,backContent:t.backContent,mediaRefs:t.mediaRefs,state:t.state,easeFactor:t.easeFactor,intervalDays:t.intervalDays}))}catch(r){console.warn("[deckStore] repo addCard failed",r)}}const cleanFieldContent=e=>e.replace(/<[^>]*>/g,"").replace(/&nbsp;/g," ").replace(/&lt;/g,"<").replace(/&gt;/g,">").replace(/&amp;/g,"&").replace(/\[sound:[^\]]*\]/g,"").trim(),detectBestFieldCombination=e=>{if(0===e.length)return{frontIndex:0,backIndex:1};const t=e[0].length,r=[];for(let a=0;a<t;a++)for(let s=a+1;s<t;s++){let t=0,n=0;for(const r of e){const e=cleanFieldContent(r[a]||""),o=cleanFieldContent(r[s]||"");e&&o&&(n++,e.length>2&&o.length>2&&(t+=10),e!==o&&(t+=5),e.match(/^\[sound:/)||o.match(/^\[sound:/)||(t+=3),e.match(/^\d+$/)||o.match(/^\d+$/)||(t+=2))}const o=n>0?t/n:0;r.push({frontIndex:a,backIndex:s,score:o})}return r.sort((e,t)=>t.score-e.score),r.length>0&&r[0].score>0?(console.log(`Best field combination: ${r[0].frontIndex} -> ${r[0].backIndex} (score: ${r[0].score})`),{frontIndex:r[0].frontIndex,backIndex:r[0].backIndex}):t>=3?{frontIndex:0,backIndex:2}:{frontIndex:0,backIndex:1}},parseApkgFile=async e=>{try{const[{default:r},{default:a}]=await Promise.all([d(()=>import("./zip-vendor-C6asOhRA.js").then(e=>e.j),__vite__mapDeps([0,1,2,3])),d(()=>import("./sql-vendor-BY3SVwKM.js").then(e=>e.s),__vite__mapDeps([4,1,2,3]))]),s=await a({locateFile:e=>e.endsWith(".wasm")?"/sql-wasm.wasm":`/${e}`}),n=await e.arrayBuffer(),o=new r,i=(await o.loadAsync(n)).file("collection.anki2");if(!i)throw new Error("Invalid .apkg file: collection.anki2 not found");const c=await i.async("arraybuffer"),l=new s.Database(new Uint8Array(c)),u=l.exec("SELECT decks FROM col LIMIT 1");let g=e.name.replace(/\.apkg$/,"");if(u.length>0&&u[0].values.length>0)try{const e=u[0].values[0][0],t=JSON.parse(e),r=Object.keys(t).filter(e=>"1"!==e);r.length>0&&(g=t[r[0]].name||g)}catch(t){console.warn("Could not parse deck names from .apkg file, using filename")}const m=l.exec("\n      SELECT n.flds, n.tags, c.type\n      FROM notes n\n      JOIN cards c ON n.id = c.nid\n      WHERE c.type >= 0\n      ORDER BY n.id\n    "),p=[];if(m.length>0){const e=Math.min(10,m[0].values.length),t=[];for(let s=0;s<e;s++){const e=m[0].values[s][0].split("");t.push(e)}const{frontIndex:r,backIndex:a}=detectBestFieldCombination(t);console.log(`Using field combination: ${r} (front) -> ${a} (back)`);for(const s of m[0].values){const e=s[0].split("");if(e.length>Math.max(r,a)){const t=cleanFieldContent(e[r]||""),s=cleanFieldContent(e[a]||"");t&&s&&t!==s&&p.push({front:t,back:s})}}}if(l.close(),0===p.length)throw new Error("No valid cards found in the .apkg file");return console.log(`Successfully parsed ${p.length} cards from .apkg file`),{name:g,cards:p}}catch(r){throw console.error("Error parsing .apkg file:",r),new Error(`Failed to parse .apkg file: ${r instanceof Error?r.message:"Unknown error"}`)}},f=e()(a((e,t)=>({decks:[],cards:{},currentStudySession:null,isLoading:!1,error:null,importProgress:0,importStatus:null,createDeck:async t=>{e({isLoading:!0,error:null});try{const r={...t,id:crypto.randomUUID(),createdAt:(new Date).toISOString(),updatedAt:(new Date).toISOString(),settings:{...k,...t.settings}};return e(e=>({decks:[...e.decks,r],cards:{...e.cards,[r.id]:[]},isLoading:!1})),persistCreateDeck(t),r}catch(r){throw e({error:"Failed to create deck",isLoading:!1}),r}},updateDeck:async(t,r)=>{e({isLoading:!0,error:null});try{e(e=>({decks:e.decks.map(e=>e.id===t?{...e,...r,updatedAt:(new Date).toISOString()}:e),isLoading:!1}));try{w.decks.update(t,mapDeckUpdatesToRepo(r))}catch(a){console.warn("[deckStore] repo updateDeck failed",a)}}catch(s){throw e({error:"Failed to update deck",isLoading:!1}),s}},deleteDeck:async t=>{e({isLoading:!0,error:null});try{e(e=>{const{[t]:r,...a}=e.cards;return{decks:e.decks.filter(e=>e.id!==t),cards:a,isLoading:!1}});try{w.decks.remove(t)}catch(r){console.warn("[deckStore] repo deleteDeck failed",r)}}catch(a){throw e({error:"Failed to delete deck",isLoading:!1}),a}},getDeck:e=>t().decks.find(t=>t.id===e),addCard:async(t,r)=>{e({isLoading:!0,error:null});try{const a={...r,id:crypto.randomUUID(),deckId:t,createdAt:(new Date).toISOString(),easeFactor:2.5,intervalDays:0,nextReview:(new Date).toISOString(),reviewCount:0,lapseCount:0};return e(e=>{const r=[...e.cards[t]||[],a];return{cards:{...e.cards,[t]:r},decks:e.decks.map(e=>e.id===t?{...e,cardCount:r.length,updatedAt:(new Date).toISOString()}:e),isLoading:!1}}),persistAddCard(t,a),a}catch(a){throw e({error:"Failed to add card",isLoading:!1}),a}},addCardBulk:async(r,a)=>{try{const s=t().cards[r]||[],n=`${a.frontContent.trim().toLowerCase()}|${a.backContent.trim().toLowerCase()}`;if(s.some(e=>`${e.frontContent.trim().toLowerCase()}|${e.backContent.trim().toLowerCase()}`===n))return console.log("Skipping duplicate card:",a.frontContent),{...a,id:"duplicate-skipped",deckId:r,createdAt:(new Date).toISOString(),easeFactor:2.5,intervalDays:0,nextReview:(new Date).toISOString(),reviewCount:0,lapseCount:0};const o={...a,id:crypto.randomUUID(),deckId:r,createdAt:(new Date).toISOString(),easeFactor:2.5,intervalDays:0,nextReview:(new Date).toISOString(),reviewCount:0,lapseCount:0};return e(e=>{const t=[...e.cards[r]||[],o];return{cards:{...e.cards,[r]:t},decks:e.decks.map(e=>e.id===r?{...e,cardCount:t.length,updatedAt:(new Date).toISOString()}:e)}}),"duplicate-skipped"!==o.id&&persistAddCard(r,o),o}catch(s){throw console.error("Failed to add card during bulk import:",s),s}},createDeckBulk:async t=>{try{const r={...t,id:crypto.randomUUID(),createdAt:(new Date).toISOString(),updatedAt:(new Date).toISOString(),settings:{...k,...t.settings}};return e(e=>({decks:[...e.decks,r],cards:{...e.cards,[r.id]:[]}})),persistCreateDeck(t),r}catch(r){throw console.error("Failed to create deck during bulk import:",r),r}},addCardsBatch:async(r,a)=>{try{const s=t().cards[r]||[],n=new Set(s.map(e=>`${e.frontContent.trim().toLowerCase()}|${e.backContent.trim().toLowerCase()}`)),o=a.filter(e=>{const t=`${e.frontContent.trim().toLowerCase()}|${e.backContent.trim().toLowerCase()}`;return!n.has(t)});if(console.log(`Batch processing: ${a.length} cards submitted, ${o.length} unique cards to add`),0===o.length)return console.log("No new unique cards to add in this batch"),[];const i=o.map(e=>({...e,id:crypto.randomUUID(),deckId:r,createdAt:(new Date).toISOString(),easeFactor:2.5,intervalDays:0,nextReview:(new Date).toISOString(),reviewCount:0,lapseCount:0}));e(e=>{const t=[...e.cards[r]||[],...i];return{cards:{...e.cards,[r]:t},decks:e.decks.map(e=>e.id===r?{...e,cardCount:t.length,updatedAt:(new Date).toISOString()}:e)}});for(const e of i)persistAddCard(r,e);return i}catch(s){throw console.error("Failed to add cards during batch import:",s),s}},updateCard:async(t,r)=>{e({isLoading:!0,error:null});try{e(e=>{const a={...e.cards};for(const s in a)a[s]=a[s].map(e=>e.id===t?{...e,...r}:e);return{cards:a,isLoading:!1}})}catch(a){throw e({error:"Failed to update card",isLoading:!1}),a}},deleteCard:async t=>{e({isLoading:!0,error:null});try{let a="";e(e=>{const r={...e.cards};for(const s in r){if(-1!==r[s].findIndex(e=>e.id===t)){r[s]=r[s].filter(e=>e.id!==t),a=s;break}}return{cards:r,decks:e.decks.map(e=>e.id===a?{...e,cardCount:r[a].length,updatedAt:(new Date).toISOString()}:e),isLoading:!1}});try{w.cards.remove(t)}catch(r){console.warn("[deckStore] repo deleteCard failed",r)}}catch(a){throw e({error:"Failed to delete card",isLoading:!1}),a}},getCards:e=>t().cards[e]||[],importAnkiDeck:async r=>{const{setImportProgress:a,resetImportProgress:s}=t();e({isLoading:!0,error:null}),s();try{const i=r.name.toLowerCase();if(i.endsWith(".apkg")){a(10,"Reading file...");const{name:i,cards:d}=await parseApkgFile(r);if(t().decks.find(e=>e.title===i))throw new Error(`A deck named "${i}" already exists. Please rename the deck or the file before importing.`);a(30,"Creating deck...");const c=await t().createDeckBulk({userId:"current-user",title:i,description:`Imported Anki deck with ${d.length} cards`,cardCount:0,isPublic:!1,settings:k,category:"imported"});a(40,`Importing ${d.length} cards...`);const l=[],u=new Set;for(const e of d){const t=`${e.front.trim().toLowerCase()}|${e.back.trim().toLowerCase()}`;u.has(t)||(u.add(t),l.push(e))}console.log(`Removed ${d.length-l.length} duplicates from Anki cards. Processing ${l.length} unique cards.`);const g=100;let m=0;const p=l.length;console.log(`Starting batch import of ${p} unique cards`);for(let e=0;e<p;e+=g){const r=l.slice(e,e+g),s=r.map(e=>createNewCard(e.front,e.back,{type:"basic"},[]));try{console.log(`Processing batch ${Math.floor(e/g)+1}/${Math.ceil(p/g)} (${r.length} cards)`),await t().addCardsBatch(c.id,s),m+=r.length;const n=40+50*Math.min(e+g,p)/p;a(n,`Imported ${m}/${p} cards...`),console.log(`Batch completed. Progress: ${n.toFixed(1)}%`),await new Promise(e=>setTimeout(e,50))}catch(n){console.error("Failed to import batch:",n);for(const e of r)try{await t().addCardBulk(c.id,createNewCard(e.front,e.back,{type:"basic"},[])),m++}catch(o){console.warn("Failed to import individual card:",e,o)}a(40+50*Math.min(e+g,p)/p,`Imported ${m}/${p} cards...`)}}return console.log(`Batch import completed. Total successful: ${m}`),a(95,"Finalizing import..."),await t().updateDeck(c.id,{description:`Imported Anki deck with ${m} cards`}),a(100,"Import completed!"),setTimeout(()=>{s()},1e3),e({isLoading:!1}),c}if(i.endsWith(".txt")||i.endsWith(".tsv")||i.endsWith(".csv")){a(10,"Reading text file...");const s=await r.text();let n="\t";i.endsWith(".csv")&&(n=","),a(20,"Processing text content...");const o=s.replace(/\r\n/g,"\n").replace(/\r/g,"\n").trim(),d=await t().importFromText(r.name.replace(/\.[^/.]+$/,""),o,n);return e({isLoading:!1}),d}{a(10,"Reading file as text...");const s=await r.text();a(20,"Processing content...");const n=s.replace(/\r\n/g,"\n").replace(/\r/g,"\n").trim(),o=await t().importFromText(r.name.replace(/\.[^/.]+$/,""),n,"\t");return e({isLoading:!1}),o}}catch(i){const t=i instanceof Error?i.message:"Failed to import Anki deck";throw e({error:t,isLoading:!1}),s(),i}},importFromText:async(r,a,s="\t")=>{const{setImportProgress:n,resetImportProgress:o}=t();e({isLoading:!0,error:null});try{n(30,"Processing text content...");const c=a.replace(/\r\n/g,"\n").replace(/\r/g,"\n").replace(/\\u0000/g,"").replace(/[\\u0001-\\u0008\\u000B\\u000C\\u000E-\\u001F\\u007F]/g,"").trim().split("\n").map(e=>e.trim()).filter(e=>e.length>0);if(0===c.length)throw new Error("No valid content found in the file");n(40,"Creating deck...");const l=await t().createDeckBulk({userId:"current-user",title:r,description:`Imported deck with ${c.length} cards`,cardCount:0,isPublic:!1,settings:k,category:"imported"});n(50,`Importing ${c.length} cards...`);const u=[];let g=0;for(let e=0;e<c.length;e++){const t=c[e];try{let e;if(e=","===s&&t.includes('"')?t.split(",").map(e=>e.replace(/^"(.*)"$/,"$1").trim()):t.split(s),e.length>=2){const t=e[0].trim(),r=e[1].trim();t&&r?u.push(createNewCard(t,r,{type:"basic"},[])):g++}else g++}catch(i){console.warn("Failed to parse line:",t,i),g++}}const m=[],p=new Set;for(const e of u){const t=`${e.frontContent.trim().toLowerCase()}|${e.backContent.trim().toLowerCase()}`;p.has(t)||(p.add(t),m.push(e))}console.log(`Removed ${u.length-m.length} duplicates from parsed cards. Processing ${m.length} unique cards.`);const h=100;let S=0;console.log(`Starting text import batch processing of ${m.length} unique cards`);for(let e=0;e<m.length;e+=h){const r=m.slice(e,e+h);try{console.log(`Processing text batch ${Math.floor(e/h)+1}/${Math.ceil(m.length/h)} (${r.length} cards)`);const a=await t().addCardsBatch(l.id,r);S+=a.length;const s=50+40*Math.min(e+h,m.length)/m.length;n(s,`Imported ${S}/${m.length} cards...`),console.log(`Text batch completed. Progress: ${s.toFixed(1)}%, Added: ${a.length} cards`),await new Promise(e=>setTimeout(e,50))}catch(i){console.error("Failed to import text batch:",i);for(const e of r)try{"duplicate-skipped"!==(await t().addCardBulk(l.id,e)).id&&S++}catch(d){console.warn("Failed to import individual text card:",e,d)}n(50+40*Math.min(e+h,m.length)/m.length,`Imported ${S}/${m.length} cards...`)}}if(console.log(`Text import batch processing completed. Total successful: ${S}`),n(95,"Finalizing import..."),await t().updateDeck(l.id,{description:`Imported deck with ${S} cards${g>0?` (${g} lines skipped)`:""}`}),0===S)throw new Error("No valid cards could be imported. Please check the file format.");return n(100,"Import completed!"),setTimeout(()=>{o()},1e3),e({isLoading:!1}),l}catch(c){throw e({error:"Failed to import from text",isLoading:!1}),o(),c}},loadExampleDecks:async()=>{e({isLoading:!0,error:null});try{const r=t(),a=new Set(r.decks.map(e=>e.title));if(["Spanish Vocabulary","JavaScript Concepts","World Capitals"].some(e=>a.has(e)))return console.log("Example decks already exist, skipping load"),void e({isLoading:!1});const s=[{title:"Spanish Vocabulary",description:"Essential Spanish words for beginners",category:"language",cards:[{front:"Hello",back:"Hola"},{front:"Goodbye",back:"AdiÃ³s"},{front:"Thank you",back:"Gracias"},{front:"Please",back:"Por favor"},{front:"Yes",back:"SÃ­"},{front:"No",back:"No"},{front:"Water",back:"Agua"},{front:"Food",back:"Comida"},{front:"House",back:"Casa"},{front:"Car",back:"Coche"}]},{title:"JavaScript Concepts",description:"Important JavaScript programming concepts",category:"programming",cards:[{front:"What is a closure?",back:"A closure is a function that has access to variables in its outer (enclosing) scope even after the outer function has returned."},{front:"What is hoisting?",back:"Hoisting is JavaScript's default behavior of moving declarations to the top of their scope."},{front:"What is the difference between let and var?",back:"let has block scope and cannot be redeclared, while var has function scope and can be redeclared."},{front:"What is a Promise?",back:"A Promise is an object representing the eventual completion or failure of an asynchronous operation."},{front:"What is async/await?",back:"async/await is syntactic sugar for working with Promises, making asynchronous code look more like synchronous code."}]},{title:"World Capitals",description:"Capital cities of countries around the world",category:"geography",cards:[{front:"France",back:"Paris"},{front:"Germany",back:"Berlin"},{front:"Italy",back:"Rome"},{front:"Spain",back:"Madrid"},{front:"United Kingdom",back:"London"},{front:"Japan",back:"Tokyo"},{front:"China",back:"Beijing"},{front:"Australia",back:"Canberra"},{front:"Brazil",back:"BrasÃ­lia"},{front:"Canada",back:"Ottawa"}]}];console.log("Loading example decks...");for(const e of s){const r=await t().createDeck({userId:"current-user",title:e.title,description:e.description,cardCount:0,isPublic:!1,settings:k,category:e.category,tags:[e.category]});for(const a of e.cards)await t().addCard(r.id,createNewCard(a.front,a.back,{type:"basic"},[]))}console.log("Example decks loaded successfully"),e({isLoading:!1})}catch(r){throw e({error:"Failed to load example decks",isLoading:!1}),r}},clearError:()=>e({error:null}),setLoading:t=>e({isLoading:t}),removeDuplicateCards:async r=>{try{const a=t().cards[r]||[];if(0===a.length)return 0;const s=new Map;let n=0;for(const e of a){const t=`${e.frontContent.trim().toLowerCase()}|${e.backContent.trim().toLowerCase()}`;s.has(t)?(n++,console.log(`Removing duplicate card: ${e.frontContent}`)):s.set(t,e)}const o=Array.from(s.values());return n>0&&(e(e=>({cards:{...e.cards,[r]:o},decks:e.decks.map(e=>e.id===r?{...e,cardCount:o.length,updatedAt:(new Date).toISOString()}:e)})),console.log(`Removed ${n} duplicate cards from deck. ${o.length} unique cards remaining.`)),n}catch(a){throw console.error("Failed to remove duplicate cards:",a),a}},setImportProgress:(t,r)=>e({importProgress:t,importStatus:r}),resetImportProgress:()=>e({importProgress:0,importStatus:null}),startStudySession:(t,r)=>{const a=r.map(e=>e.id);e({currentStudySession:{deckId:t,currentCardIndex:0,studyCards:r,studyCardIds:a,sessionStats:{total:r.length,correct:0,incorrect:0},startedAt:(new Date).toISOString()}})},updateStudySession:(t,r)=>{e(e=>({currentStudySession:e.currentStudySession?{...e.currentStudySession,currentCardIndex:t,sessionStats:r}:null}))},clearStudySession:()=>{e({currentStudySession:null})},getStudySession:e=>{const r=t();return r.currentStudySession?.deckId===e?r.currentStudySession:null},resetAllStudyData:()=>{e(e=>{const t={};for(const[r,a]of Object.entries(e.cards))t[r]=a.map(e=>({...e,easeFactor:2.5,intervalDays:0,nextReview:(new Date).toISOString(),reviewCount:0,lapseCount:0}));return{cards:t,currentStudySession:null}})}}),{name:"deck-storage",partialize:e=>{const{cards:t,currentStudySession:r,...a}=e;return{...a,currentStudySession:r?{deckId:r.deckId,currentCardIndex:r.currentCardIndex,studyCardIds:r.studyCardIds,sessionStats:r.sessionStats,startedAt:r.startedAt}:null}}})),useCurrentCard=()=>{const e=f(),t=e.currentStudySession;if(!t||!t.studyCardIds||0===t.studyCardIds.length)return null;const r=t.studyCardIds[t.currentCardIndex];if(!r)return null;return(e.cards[t.deckId]||[]).find(e=>e.id===r)||null};export{g as a,u as b,f as c,useCurrentCard as d,createNewCard as e,S as u};
//# sourceMappingURL=stores-DWHkcQm5.js.map
